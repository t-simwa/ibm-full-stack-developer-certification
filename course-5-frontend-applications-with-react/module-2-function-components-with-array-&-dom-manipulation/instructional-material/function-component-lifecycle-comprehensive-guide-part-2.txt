================================================================================
FUNCTION COMPONENT LIFECYCLE IN REACT
Comprehensive Study Guide - Part 2
================================================================================

CONTINUATION FROM PART 1
------------------------
This is Part 2 of the comprehensive study guide. Part 1 covered:
• Understanding Functional Components
• The Mounting Phase (Initialization, State, Side Effects)

Part 2 will cover:
• The Updating Phase
• The Unmounting Phase
• The Error Handling Phase
• Complete lifecycle examples
• Best practices

================================================================================
TABLE OF CONTENTS
================================================================================

PART 5: THE UPDATING PHASE
  SECTION 5.1: WHAT IS THE UPDATING PHASE?
  SECTION 5.2: HOW THE UPDATING PHASE WORKS
  SECTION 5.3: UPDATING WITH PROPS
  SECTION 5.4: useEffect DURING UPDATES

PART 6: THE UNMOUNTING PHASE
  SECTION 6.1: WHAT IS THE UNMOUNTING PHASE?
  SECTION 6.2: MORE CLEANUP EXAMPLES
  SECTION 6.3: CLEANUP DURING UPDATES

PART 7: THE ERROR HANDLING PHASE
  SECTION 7.1: WHAT IS THE ERROR HANDLING PHASE?
  SECTION 7.2: ERROR HANDLING BEST PRACTICES

PART 8: COMPLETE LIFECYCLE EXAMPLE
  SECTION 8.1: FULL LIFECYCLE WALKTHROUGH

PART 9: SUMMARY AND KEY TAKEAWAYS
  SECTION 9.1: THE FOUR PHASES SUMMARY
  SECTION 9.2: KEY CONCEPTS TO REMEMBER
  SECTION 9.3: COMMON PATTERNS

PART 10: STUDY TIPS AND BEST PRACTICES

================================================================================
NAVIGATION TIP
================================================================================
Search for section numbers (e.g., "SECTION 5.1:") to quickly jump to any section.

================================================================================
PART 5: THE UPDATING PHASE
================================================================================

SECTION 5.1: WHAT IS THE UPDATING PHASE?
------------------------------------------

DEFINITION
----------
During the updating phase, React responds to changes in the component state or 
props by re-invoking the function body of the component. This phase triggers a 
re-evaluation of the JavaScript XML (JSX), allowing React to determine the new 
UI to render.

DETAILED EXPLANATION
--------------------
The updating phase is like "refreshing" your component. It happens whenever:
• State changes (using setState or useState setter)
• Props change (parent component passes new props)
• Parent component re-renders (causing child to re-render)

Think of updating like updating a document:
• You make a change (state or props change)
• The document needs to be refreshed (component re-renders)
• Only the changed parts are updated (React optimizes this)
• The new version is displayed (updated UI appears)

KEY CONCEPTS:
------------
• Updating happens MULTIPLE times (unlike mounting which happens once)
• React re-runs the entire component function
• React compares old and new JSX to optimize updates
• Only changed parts of the DOM are actually updated

WHAT TRIGGERS AN UPDATE?
------------------------
An update is triggered when:
1. State changes - When you call a state setter function (like setCount)
2. Props change - When parent component passes new props
3. Parent re-renders - When parent component updates, children may update
4. Context changes - When React Context value changes (advanced topic)
5. Force update - When you explicitly force a re-render (rarely needed)

================================================================================

SECTION 5.2: HOW THE UPDATING PHASE WORKS
------------------------------------------

STEP-BY-STEP PROCESS:
---------------------
1. Trigger Event - Something causes an update (state change, prop change, etc.)
2. Function Re-execution - React calls the component function again
3. State Re-evaluation - useState hooks return current state values (not initial)
4. JSX Re-evaluation - Component function returns new JSX
5. Virtual DOM Comparison - React compares new JSX with previous JSX
6. DOM Update - React updates only the changed parts in the real DOM
7. Side Effects - useEffect may run again (depending on dependencies)

EXAMPLE: UPDATING PHASE IN ACTION
----------------------------------
Here's the example from the original material:

  function MyComponent() {
    const [count, setCount] = useState(0);
    
    const increment = () => {
      setCount(count + 1);
    };
    
    return (
      <div>
        <p>Count: {count}</p>
        <button onClick={increment}>Increment</button>
      </div>
    );
  }

DETAILED CODE EXPLANATION:
--------------------------
Let's understand what happens during the updating phase:

1. `const [count, setCount] = useState(0);`
   - During MOUNTING: count = 0 (initial value)
   - During UPDATING: count = current value (could be 1, 2, 3, etc.)
   - useState remembers the current state between renders

2. `const increment = () => { setCount(count + 1); };`
   - This is a function that updates the state
   - `count + 1` takes the current count and adds 1
   - `setCount(...)` updates the state, triggering a re-render
   - This function is recreated on every render (but that's okay)

3. `<p>Count: {count}</p>`
   - Displays the current count value
   - During mounting: shows "Count: 0"
   - After first click: shows "Count: 1"
   - After second click: shows "Count: 2"
   - And so on...

4. `<button onClick={increment}>Increment</button>`
   - Button that calls increment when clicked
   - onClick is an event handler
   - When clicked, it triggers the update phase

WHAT HAPPENS WHEN USER CLICKS THE BUTTON:
------------------------------------------
Let's trace through what happens step by step:

INITIAL STATE (After Mounting):
  • count = 0
  • Screen shows: "Count: 0"

USER CLICKS BUTTON:
  Step 1: increment() function is called
  Step 2: setCount(0 + 1) is called → setCount(1)
  Step 3: React schedules a re-render
  Step 4: React calls MyComponent() again
  Step 5: useState(0) returns [1, setCount] (current value is 1, not 0!)
  Step 6: Component function runs with count = 1
  Step 7: New JSX is created: <p>Count: 1</p>
  Step 8: React compares old JSX with new JSX
  Step 9: React updates only the text "0" to "1" in the DOM
  Step 10: Screen now shows: "Count: 1"

IMPORTANT: useState BEHAVIOR DURING UPDATES
--------------------------------------------
This is crucial to understand:

  function MyComponent() {
    const [count, setCount] = useState(0);
    // During MOUNTING: count = 0
    // During UPDATING: count = whatever the current value is!
    
    console.log("Current count:", count);
    // This will log different values on each render
    
    return <div>{count}</div>;
  }

When the component updates:
• useState(0) is called again
• BUT it doesn't reset to 0!
• It returns the CURRENT state value
• The 0 is only used during the FIRST render (mounting)

MORE COMPLEX UPDATE EXAMPLE:
-----------------------------
Let's see a component that updates based on user input:

  function Counter() {
    const [count, setCount] = useState(0);
    const [step, setStep] = useState(1);
    
    const increment = () => {
      setCount(count + step);
    };
    
    const decrement = () => {
      setCount(count - step);
    };
    
    return (
      <div>
        <p>Count: {count}</p>
        <p>Step: {step}</p>
        <button onClick={increment}>+{step}</button>
        <button onClick={decrement}>-{step}</button>
        <input 
          type="number" 
          value={step} 
          onChange={(e) => setStep(Number(e.target.value))}
        />
      </div>
    );
  }

DETAILED EXPLANATION:
---------------------
This component has TWO state variables:

1. `const [count, setCount] = useState(0);`
   - Stores the current count value
   - Starts at 0

2. `const [step, setStep] = useState(1);`
   - Stores the step size (how much to add/subtract)
   - Starts at 1

3. `const increment = () => { setCount(count + step); };`
   - Adds the step value to count
   - Uses current values of both count and step

4. `const decrement = () => { setCount(count - step); };`
   - Subtracts the step value from count

5. `<input ... onChange={(e) => setStep(Number(e.target.value))} />`
   - Input field to change the step value
   - `e.target.value` gets the input value (always a string)
   - `Number(...)` converts string to number
   - `setStep(...)` updates the step state
   - When step changes, component re-renders

UPDATE SCENARIOS:
----------------
Scenario 1: User clicks "+1" button
  • increment() called
  • setCount(0 + 1) → count becomes 1
  • Component re-renders
  • Screen shows "Count: 1"

Scenario 2: User changes step to 5
  • onChange fires
  • setStep(5) → step becomes 5
  • Component re-renders
  • Screen shows "Step: 5"
  • Buttons now show "+5" and "-5"

Scenario 3: User clicks "+5" button
  • increment() called
  • setCount(1 + 5) → count becomes 6
  • Component re-renders
  • Screen shows "Count: 6"

================================================================================

SECTION 5.3: UPDATING WITH PROPS
---------------------------------

DEFINITION
----------
Components can also update when their props change. When a parent component 
passes new props, the child component enters the updating phase.

DETAILED EXPLANATION
--------------------
Props are data passed from parent to child. When props change:
• Parent component re-renders with new props
• Child component receives new props
• Child component function is called again
• Child component enters updating phase

EXAMPLE: COMPONENT WITH PROPS
------------------------------
Parent Component:

  function App() {
    const [name, setName] = useState("John");
    
    return (
      <div>
        <Greeting name={name} />
        <button onClick={() => setName("Jane")}>Change Name</button>
      </div>
    );
  }

Child Component:

  function Greeting({ name }) {
    return <h1>Hello, {name}!</h1>;
  }

WHAT HAPPENS:
------------
MOUNTING PHASE:
  • App mounts with name = "John"
  • Greeting receives prop name = "John"
  • Screen shows: "Hello, John!"

UPDATING PHASE (User clicks button):
  • setName("Jane") is called
  • App re-renders with name = "Jane"
  • Greeting receives NEW prop name = "Jane"
  • Greeting function is called again (updating phase)
  • New JSX: <h1>Hello, Jane!</h1>
  • React updates the text in the DOM
  • Screen shows: "Hello, Jane!"

DETAILED CODE EXPLANATION:
--------------------------
1. `function App() { ... }`
   - Parent component
   - Manages the name state

2. `<Greeting name={name} />`
   - Passes name as a prop to Greeting
   - When name changes, Greeting receives new prop

3. `function Greeting({ name }) { ... }`
   - Child component
   - Receives name as a prop
   - Uses destructuring: `{ name }` extracts name from props object
   - Could also be written as: `function Greeting(props) { return <h1>Hello, {props.name}!</h1>; }`

4. `onClick={() => setName("Jane")}`
   - Arrow function that calls setName
   - Updates the name state
   - Triggers re-render of App
   - Which triggers re-render of Greeting

MORE COMPLEX PROPS EXAMPLE:
---------------------------
  function UserCard({ user, onUpdate }) {
    const [isEditing, setIsEditing] = useState(false);
    
    return (
      <div>
        <h2>{user.name}</h2>
        <p>Email: {user.email}</p>
        <button onClick={() => setIsEditing(!isEditing)}>
          {isEditing ? "Cancel" : "Edit"}
        </button>
        {isEditing && (
          <button onClick={() => onUpdate(user.id)}>Save</button>
        )}
      </div>
    );
  }

EXPLANATION:
• Receives user object and onUpdate function as props
• Has its own local state (isEditing)
• When user prop changes, component updates
• When isEditing state changes, component also updates
• Both props and state can trigger updates

================================================================================

SECTION 5.4: useEffect DURING UPDATES
--------------------------------------

DEFINITION
----------
useEffect can also run during the updating phase, depending on its dependency 
array. If dependencies change, the effect runs again.

DETAILED EXPLANATION
--------------------
During the updating phase, useEffect behavior depends on its dependency array:

1. Empty array `[]` - Runs only once (during mounting)
2. No array - Runs after every render (including updates)
3. Array with dependencies `[count, name]` - Runs when dependencies change

EXAMPLE: useEffect WITH DEPENDENCIES
------------------------------------
  function MyComponent() {
    const [count, setCount] = useState(0);
    const [name, setName] = useState("John");
    
    // This runs only once (mounting)
    useEffect(() => {
      console.log("Component mounted");
    }, []);
    
    // This runs whenever count changes
    useEffect(() => {
      console.log("Count changed to:", count);
    }, [count]);
    
    // This runs whenever name changes
    useEffect(() => {
      console.log("Name changed to:", name);
    }, [name]);
    
    // This runs whenever count OR name changes
    useEffect(() => {
      console.log("Count or name changed");
    }, [count, name]);
    
    return (
      <div>
        <p>Count: {count}</p>
        <p>Name: {name}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
        <button onClick={() => setName("Jane")}>Change Name</button>
      </div>
    );
  }

WHAT HAPPENS:
------------
MOUNTING:
  • All useEffect hooks are registered
  • Component renders
  • First useEffect runs: "Component mounted"
  • Other useEffects run if their dependencies exist

UPDATING (User clicks "Increment"):
  • setCount(count + 1) updates count
  • Component re-renders
  • useEffect with [count] runs: "Count changed to: 1"
  • useEffect with [count, name] runs: "Count or name changed"
  • Other useEffects don't run (their dependencies didn't change)

UPDATING (User clicks "Change Name"):
  • setName("Jane") updates name
  • Component re-renders
  • useEffect with [name] runs: "Name changed to: Jane"
  • useEffect with [count, name] runs: "Count or name changed"
  • Other useEffects don't run

REAL-WORLD EXAMPLE: FETCHING DATA WHEN PROPS CHANGE
----------------------------------------------------
  function UserProfile({ userId }) {
    const [user, setUser] = useState(null);
    
    useEffect(() => {
      // Fetch user data whenever userId prop changes
      fetch(`/api/users/${userId}`)
        .then(res => res.json())
        .then(data => setUser(data));
    }, [userId]); // Dependency: userId
    
    if (!user) return <div>Loading...</div>;
    
    return (
      <div>
        <h1>{user.name}</h1>
        <p>{user.email}</p>
      </div>
    );
  }

EXPLANATION:
• Component receives userId as prop
• When userId changes, useEffect runs again
• Fetches new user data for the new userId
• Updates user state with new data
• Component re-renders with new user info

This is very useful for:
• Loading data when route parameters change
• Refreshing data when filters change
• Updating content when selections change

================================================================================
PART 6: THE UNMOUNTING PHASE
================================================================================

SECTION 6.1: WHAT IS THE UNMOUNTING PHASE?
-------------------------------------------

DEFINITION
----------
During the unmounting phase, React executes cleanup operations when removing a 
component from the DOM. These operations involve the component itself, actively 
cleaning up event listeners, subscriptions, timers, or any other resources it 
created during its lifecycle.

DETAILED EXPLANATION
--------------------
The unmounting phase is like "moving out" of your component. It happens when:
• Component is removed from the page
• Parent component stops rendering the child
• User navigates away
• Conditional rendering hides the component

Think of unmounting like cleaning up when you leave:
• Turn off the lights (cleanup timers)
• Cancel subscriptions (cleanup subscriptions)
• Close connections (cleanup network requests)
• Remove event listeners (cleanup event handlers)

WHY CLEANUP IS IMPORTANT:
------------------------
Without proper cleanup, you can have:
• Memory leaks - Resources not released
• Performance issues - Unnecessary operations continue
• Bugs - Event handlers firing on removed components
• Wasted resources - Timers, subscriptions still running

EXAMPLE: UNMOUNTING WITH CLEANUP
---------------------------------
Here's the example from the original material:

  function MyComponent() {
    useEffect(() => {
      const intervalId = setInterval(() => {
        console.log("Interval tick");
      }, 1000);
      
      // Cleanup function
      return () => {
        clearInterval(intervalId);
      };
    }, []);
    
    return <div>My Component</div>;
  }

DETAILED CODE EXPLANATION:
--------------------------
Let's break down every piece:

1. `useEffect(() => { ... }, []);`
   - Effect runs once after mounting
   - Empty array means it only runs once

2. `const intervalId = setInterval(() => { ... }, 1000);`
   - setInterval creates a timer
   - Timer runs the function every 1000 milliseconds (1 second)
   - Logs "Interval tick" every second
   - Returns an ID that identifies this timer
   - intervalId stores this ID

3. `return () => { clearInterval(intervalId); };`
   - This is the CLEANUP FUNCTION
   - useEffect can return a function
   - This function runs when component unmounts
   - clearInterval(intervalId) stops the timer
   - This prevents the timer from continuing after component is removed

WHAT HAPPENS:
------------
MOUNTING:
  • Component mounts
  • useEffect runs
  • setInterval starts (logs every second)
  • Cleanup function is registered

COMPONENT IS ACTIVE:
  • Timer continues running
  • Logs "Interval tick" every second
  • Component displays on screen

UNMOUNTING (Component removed):
  • React detects component is being removed
  • React calls the cleanup function
  • clearInterval(intervalId) stops the timer
  • Timer stops logging
  • Component is removed from DOM
  • No memory leaks!

WITHOUT CLEANUP (BAD):
----------------------
If we didn't have cleanup:

  function MyComponent() {
    useEffect(() => {
      setInterval(() => {
        console.log("Interval tick");
      }, 1000);
      // NO CLEANUP FUNCTION!
    }, []);
    
    return <div>My Component</div>;
  }

PROBLEM:
• Timer keeps running even after component is removed
• Memory leak - timer is never cleared
• Console keeps logging even though component is gone
• Wasted resources

================================================================================

SECTION 6.2: MORE CLEANUP EXAMPLES
-----------------------------------

EXAMPLE 1: CLEANING UP EVENT LISTENERS
---------------------------------------
  function WindowSize() {
    const [width, setWidth] = useState(window.innerWidth);
    
    useEffect(() => {
      const handleResize = () => {
        setWidth(window.innerWidth);
      };
      
      window.addEventListener('resize', handleResize);
      
      // Cleanup: remove event listener
      return () => {
        window.removeEventListener('resize', handleResize);
      };
    }, []);
    
    return <div>Window width: {width}px</div>;
  }

EXPLANATION:
• Adds event listener for window resize
• Updates width state when window is resized
• Cleanup removes event listener when component unmounts
• Prevents memory leak (listener would continue otherwise)

EXAMPLE 2: CLEANING UP SUBSCRIPTIONS
-------------------------------------
  function ChatRoom({ roomId }) {
    const [messages, setMessages] = useState([]);
    
    useEffect(() => {
      // Simulate WebSocket subscription
      const subscription = subscribeToRoom(roomId, (message) => {
        setMessages(prev => [...prev, message]);
      });
      
      // Cleanup: unsubscribe
      return () => {
        unsubscribeFromRoom(subscription);
      };
    }, [roomId]);
    
    return (
      <div>
        {messages.map(msg => <div key={msg.id}>{msg.text}</div>)}
      </div>
    );
  }

EXPLANATION:
• Subscribes to a chat room when component mounts
• Receives messages and updates state
• When component unmounts or roomId changes, unsubscribes
• Prevents receiving messages for removed components

EXAMPLE 3: CLEANING UP API REQUESTS
------------------------------------
  function UserData({ userId }) {
    const [user, setUser] = useState(null);
    
    useEffect(() => {
      let cancelled = false;
      
      fetch(`/api/users/${userId}`)
        .then(res => res.json())
        .then(data => {
          if (!cancelled) {
            setUser(data);
          }
        });
      
      // Cleanup: cancel the request
      return () => {
        cancelled = true;
      };
    }, [userId]);
    
    return user ? <div>{user.name}</div> : <div>Loading...</div>;
  }

EXPLANATION:
• Fetches user data when component mounts or userId changes
• Uses a flag (cancelled) to prevent state update if component unmounts
• If user navigates away before request completes, state won't update
• Prevents "Can't update state on unmounted component" errors

EXAMPLE 4: CLEANING UP MULTIPLE RESOURCES
------------------------------------------
  function ComplexComponent() {
    useEffect(() => {
      // Set up timer
      const timerId = setInterval(() => {
        console.log("Timer tick");
      }, 1000);
      
      // Set up event listener
      const handleClick = () => console.log("Clicked");
      document.addEventListener('click', handleClick);
      
      // Set up subscription
      const subscription = subscribe();
      
      // Cleanup ALL resources
      return () => {
        clearInterval(timerId);
        document.removeEventListener('click', handleClick);
        unsubscribe(subscription);
      };
    }, []);
    
    return <div>Complex Component</div>;
  }

EXPLANATION:
• Sets up multiple resources (timer, event listener, subscription)
• Single cleanup function handles all of them
• Ensures everything is cleaned up when component unmounts

================================================================================

SECTION 6.3: CLEANUP DURING UPDATES
------------------------------------

DEFINITION
----------
Cleanup functions also run when dependencies change, not just during unmounting. 
This allows you to clean up before setting up new effects.

DETAILED EXPLANATION
--------------------
When useEffect has dependencies and those dependencies change:
1. Cleanup function runs first (cleans up old effect)
2. Effect function runs again (sets up new effect)

This pattern is useful when:
• Switching between different subscriptions
• Changing API endpoints
• Updating event listeners for different elements

EXAMPLE: CLEANUP ON DEPENDENCY CHANGE
--------------------------------------
  function ChatRoom({ roomId }) {
    const [messages, setMessages] = useState([]);
    
    useEffect(() => {
      console.log(`Subscribing to room ${roomId}`);
      
      const subscription = subscribeToRoom(roomId, (message) => {
        setMessages(prev => [...prev, message]);
      });
      
      // Cleanup runs when roomId changes OR component unmounts
      return () => {
        console.log(`Unsubscribing from room ${roomId}`);
        unsubscribeFromRoom(subscription);
      };
    }, [roomId]); // Dependency: roomId
    
    return (
      <div>
        <h2>Room: {roomId}</h2>
        {messages.map(msg => <div key={msg.id}>{msg.text}</div>)}
      </div>
    );
  }

WHAT HAPPENS:
------------
SCENARIO 1: Component mounts with roomId = "general"
  • Effect runs: "Subscribing to room general"
  • Subscription active for "general"

SCENARIO 2: roomId changes to "private"
  • Cleanup runs FIRST: "Unsubscribing from room general"
  • Old subscription is cleaned up
  • Effect runs AGAIN: "Subscribing to room private"
  • New subscription active for "private"

SCENARIO 3: Component unmounts
  • Cleanup runs: "Unsubscribing from room private"
  • Subscription is cleaned up
  • Component removed

This ensures:
• No duplicate subscriptions
• No memory leaks
• Proper cleanup when switching rooms

================================================================================
PART 7: THE ERROR HANDLING PHASE
================================================================================

SECTION 7.1: WHAT IS THE ERROR HANDLING PHASE?
----------------------------------------------

DEFINITION
----------
But what happens if an error occurs during rendering or within a child 
component's lifecycle method in React? React will handle the error in such cases 
by routing it to the nearest error boundary. This error-handling mechanism is 
the final phase of the functional component's lifecycle.

DETAILED EXPLANATION
--------------------
Errors can happen in React applications:
• During rendering (component tries to render invalid data)
• In event handlers (user interaction causes error)
• In useEffect (side effect fails)
• In child components (child component has an error)

Without error handling, a single error can crash the entire application. Error 
boundaries prevent this by catching errors and showing a fallback UI instead.

WHAT ARE ERROR BOUNDARIES?
--------------------------
Error boundaries are special components in React that catch errors during the 
rendering phase or lifecycle methods of their child components. Instead of 
crashing the entire application, error boundaries display a fallback UI, 
preventing the error from propagating further up the component tree and ensuring 
the rest of the application remains functional despite the error in a specific 
component.

KEY CHARACTERISTICS:
• Catch errors in child components
• Display fallback UI instead of crashing
• Prevent error from propagating up
• Keep rest of app functional
• Only catch errors during rendering and lifecycle

WHAT ERRORS DO ERROR BOUNDARIES CATCH?
--------------------------------------
Error boundaries catch:
✓ Errors during rendering
✓ Errors in lifecycle methods
✓ Errors in constructors of child components

Error boundaries DO NOT catch:
✗ Errors in event handlers
✗ Errors in asynchronous code (setTimeout, promises)
✗ Errors during server-side rendering
✗ Errors in the error boundary itself

EXAMPLE: COMPONENT WITH ERROR
------------------------------
  function BuggyComponent() {
    const [items, setItems] = useState([1, 2, 3]);
    
    // This will cause an error if items is null
    return (
      <div>
        {items.map(item => (
          <div key={item}>{item}</div>
        ))}
      </div>
    );
  }

If items becomes null or undefined, this will crash without an error boundary.

EXAMPLE: ERROR BOUNDARY COMPONENT
----------------------------------
Error boundaries are class components (or use special libraries for functional 
components). Here's a basic example:

  class ErrorBoundary extends React.Component {
    constructor(props) {
      super(props);
      this.state = { hasError: false };
    }
    
    static getDerivedStateFromError(error) {
      // Update state so next render shows fallback UI
      return { hasError: true };
    }
    
    componentDidCatch(error, errorInfo) {
      // Log error to error reporting service
      console.error('Error caught:', error, errorInfo);
    }
    
    render() {
      if (this.state.hasError) {
        // Fallback UI
        return <h1>Something went wrong.</h1>;
      }
      
      return this.props.children;
    }
  }

USAGE:
  function App() {
    return (
      <ErrorBoundary>
        <BuggyComponent />
      </ErrorBoundary>
    );
  }

EXPLANATION:
• ErrorBoundary wraps BuggyComponent
• If BuggyComponent throws an error, ErrorBoundary catches it
• ErrorBoundary shows fallback UI instead of crashing
• Rest of app continues to work

MODERN APPROACH: REACT ERROR BOUNDARY LIBRARY
----------------------------------------------
For functional components, you can use libraries like `react-error-boundary`:

  import { ErrorBoundary } from 'react-error-boundary';
  
  function ErrorFallback({ error, resetErrorBoundary }) {
    return (
      <div role="alert">
        <h2>Something went wrong:</h2>
        <pre>{error.message}</pre>
        <button onClick={resetErrorBoundary}>Try again</button>
      </div>
    );
  }
  
  function App() {
    return (
      <ErrorBoundary FallbackComponent={ErrorFallback}>
        <BuggyComponent />
      </ErrorBoundary>
    );
  }

================================================================================

SECTION 7.2: ERROR HANDLING BEST PRACTICES
-------------------------------------------

PRACTICE 1: WRAP COMPONENTS IN ERROR BOUNDARIES
-----------------------------------------------
Wrap potentially error-prone components:

  function App() {
    return (
      <ErrorBoundary>
        <Header />
        <ErrorBoundary>
          <MainContent />
        </ErrorBoundary>
        <ErrorBoundary>
          <Sidebar />
        </ErrorBoundary>
        <Footer />
      </ErrorBoundary>
    );
  }

This way, if one section fails, others continue working.

PRACTICE 2: HANDLE ERRORS IN EVENT HANDLERS
--------------------------------------------
Error boundaries don't catch errors in event handlers, so handle them manually:

  function MyComponent() {
    const handleClick = () => {
      try {
        // Code that might throw error
        riskyOperation();
      } catch (error) {
        console.error('Error in click handler:', error);
        // Show error to user
        alert('An error occurred. Please try again.');
      }
    };
    
    return <button onClick={handleClick}>Click me</button>;
  }

PRACTICE 3: HANDLE ERRORS IN ASYNC CODE
---------------------------------------
Error boundaries don't catch errors in async code, so handle them:

  function MyComponent() {
    useEffect(() => {
      async function fetchData() {
        try {
          const response = await fetch('/api/data');
          const data = await response.json();
          setData(data);
        } catch (error) {
          console.error('Fetch error:', error);
          setError('Failed to load data');
        }
      }
      
      fetchData();
    }, []);
    
    // ... rest of component
  }

================================================================================
PART 8: COMPLETE LIFECYCLE EXAMPLE
================================================================================

SECTION 8.1: FULL LIFECYCLE WALKTHROUGH
---------------------------------------

Let's see a complete example that demonstrates all four phases:

  function LifecycleDemo({ userId }) {
    // MOUNTING: State initialization
    const [count, setCount] = useState(0);
    const [data, setData] = useState(null);
    const [error, setError] = useState(null);
    
    // MOUNTING & UPDATING: Side effects
    useEffect(() => {
      console.log('Component mounted or userId changed');
      
      // Fetch data
      fetch(`/api/users/${userId}`)
        .then(res => res.json())
        .then(data => setData(data))
        .catch(err => setError(err.message));
      
      // Set up timer
      const timerId = setInterval(() => {
        console.log('Timer tick');
      }, 1000);
      
      // UNMOUNTING: Cleanup function
      return () => {
        console.log('Cleaning up...');
        clearInterval(timerId);
      };
    }, [userId]); // Runs when userId changes
    
    // UPDATING: This runs on every render
    console.log('Component rendering, count:', count);
    
    // ERROR HANDLING: Display error if fetch failed
    if (error) {
      return <div>Error: {error}</div>;
    }
    
    if (!data) {
      return <div>Loading...</div>;
    }
    
    return (
      <div>
        <h1>{data.name}</h1>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>
          Increment
        </button>
      </div>
    );
  }

LIFECYCLE TIMELINE:
-------------------
MOUNTING (userId = "123"):
  1. useState hooks initialize (count=0, data=null, error=null)
  2. Component renders (shows "Loading...")
  3. useEffect runs:
     - Fetches user data
     - Sets up timer
     - Registers cleanup function
  4. Component is mounted

UPDATING (User clicks "Increment"):
  1. setCount(1) called
  2. Component function runs again
  3. useState returns current values (count=1)
  4. Component re-renders (shows count: 1)
  5. useEffect doesn't run (userId didn't change)

UPDATING (userId prop changes to "456"):
  1. Parent passes new userId
  2. Component function runs again
  3. useEffect cleanup runs (clears old timer)
  4. useEffect runs again (fetches new user, sets up new timer)

UNMOUNTING (Component removed):
  1. React detects component removal
  2. Cleanup function runs:
     - clearInterval stops timer
     - Logs "Cleaning up..."
  3. Component removed from DOM

ERROR HANDLING (If fetch fails):
  1. Error caught in .catch()
  2. setError() updates state
  3. Component re-renders
  4. Shows error message instead of crashing

================================================================================
PART 9: SUMMARY AND KEY TAKEAWAYS
================================================================================

SECTION 9.1: THE FOUR PHASES SUMMARY
-------------------------------------

1. MOUNTING PHASE
   • Component is created and added to DOM
   • Happens ONCE when component first appears
   • Steps:
     - Initialization (function body runs)
     - State initialization (useState with initial values)
     - Side effects (useEffect with empty array runs once)

2. UPDATING PHASE
   • Component re-renders when state or props change
   • Happens MULTIPLE times during component's life
   • Steps:
     - Trigger (state/prop change)
     - Function re-execution
     - State returns current values (not initial)
     - JSX re-evaluation
     - DOM update (only changed parts)
     - Side effects may run (if dependencies changed)

3. UNMOUNTING PHASE
   • Component is removed from DOM
   • Happens ONCE when component is removed
   • Steps:
     - Cleanup functions run
     - Resources are freed (timers, subscriptions, etc.)
     - Component removed from DOM

4. ERROR HANDLING PHASE
   • Errors are caught and handled
   • Can happen at any time
   • Steps:
     - Error occurs (rendering, lifecycle, etc.)
     - Error boundary catches it
     - Fallback UI displayed
     - Rest of app continues working

SECTION 9.2: KEY CONCEPTS TO REMEMBER
--------------------------------------

USEState BEHAVIOR:
• Initial value only used during mounting
• Returns current value during updates
• State persists between renders
• State is lost when component unmounts

useEffect BEHAVIOR:
• Empty array [] = runs once after mount
• No array = runs after every render
• Dependencies [a, b] = runs when a or b changes
• Cleanup function runs before effect runs again or on unmount

CLEANUP IS CRITICAL:
• Always clean up timers (clearInterval, clearTimeout)
• Always clean up subscriptions
• Always clean up event listeners
• Always cancel pending requests
• Prevents memory leaks and bugs

ERROR HANDLING:
• Use error boundaries for rendering errors
• Handle async errors with try/catch
• Handle event handler errors manually
• Provide fallback UIs for better UX

SECTION 9.3: COMMON PATTERNS
-----------------------------

PATTERN 1: DATA FETCHING ON MOUNT
  useEffect(() => {
    fetchData().then(setData);
  }, []);

PATTERN 2: DATA FETCHING ON PROP CHANGE
  useEffect(() => {
    fetchData(id).then(setData);
  }, [id]);

PATTERN 3: CLEANUP TIMER
  useEffect(() => {
    const id = setInterval(() => {}, 1000);
    return () => clearInterval(id);
  }, []);

PATTERN 4: CLEANUP EVENT LISTENER
  useEffect(() => {
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

PATTERN 5: CONDITIONAL EFFECT
  useEffect(() => {
    if (shouldFetch) {
      fetchData();
    }
  }, [shouldFetch]);

================================================================================
PART 10: STUDY TIPS AND BEST PRACTICES
================================================================================

STUDY TIP 1: UNDERSTAND THE ORDER
----------------------------------
Remember the order of operations:
1. Component function runs (initialization)
2. useState hooks initialize/return values
3. Component renders
4. useEffect runs (after render)
5. Cleanup runs (before next effect or unmount)

STUDY TIP 2: PRACTICE WITH CONSOLE.LOGS
---------------------------------------
Add console.logs to see the lifecycle in action:

  function MyComponent() {
    console.log('1. Function body running');
    
    const [count, setCount] = useState(() => {
      console.log('2. useState initializing');
      return 0;
    });
    
    console.log('3. About to render, count:', count);
    
    useEffect(() => {
      console.log('4. useEffect running');
      return () => {
        console.log('5. Cleanup running');
      };
    }, []);
    
    return <div>{count}</div>;
  }

STUDY TIP 3: USE REACT DEVTOOLS
-------------------------------
React DevTools browser extension shows:
• Component tree
• Props and state values
• When components render
• Hook values and dependencies

STUDY TIP 4: START SIMPLE
-------------------------
• Master mounting first
• Then understand updating
• Then learn cleanup
• Finally tackle error handling

BEST PRACTICE 1: ALWAYS CLEAN UP
---------------------------------
If you set something up in useEffect, clean it up:

  useEffect(() => {
    // Setup
    const resource = createResource();
    
    // Cleanup
    return () => {
      destroyResource(resource);
    };
  }, []);

BEST PRACTICE 2: USE DEPENDENCY ARRAYS CORRECTLY
------------------------------------------------
• Empty [] for mount-only effects
• Include all dependencies that effect uses
• Use ESLint plugin to catch missing dependencies

BEST PRACTICE 3: HANDLE LOADING AND ERROR STATES
------------------------------------------------
Always handle:
• Loading state (data fetching)
• Error state (something went wrong)
• Empty state (no data to show)

BEST PRACTICE 4: KEEP EFFECTS FOCUSED
------------------------------------
One effect per concern:

  // Good: Separate effects
  useEffect(() => {
    fetchUser();
  }, [userId]);
  
  useEffect(() => {
    setupTimer();
    return () => clearTimer();
  }, []);

  // Bad: One effect doing everything
  useEffect(() => {
    fetchUser();
    setupTimer();
    // ... too many things
  }, [userId]);

================================================================================
FINAL NOTES
-----------
This comprehensive study guide has expanded on the original content while 
maintaining all original definitions and information. Each concept has been 
explained in detail with numerous examples to ensure thorough understanding.

Remember that learning React lifecycle is a journey:
• Start with understanding mounting
• Practice with simple state updates
• Learn cleanup patterns
• Master error handling
• Build projects to reinforce learning

The lifecycle of functional components is fundamental to React development. 
Understanding these phases will help you build better, more efficient, and more 
maintainable React applications.

Good luck with your React learning journey!

================================================================================
END OF STUDY GUIDE
================================================================================

