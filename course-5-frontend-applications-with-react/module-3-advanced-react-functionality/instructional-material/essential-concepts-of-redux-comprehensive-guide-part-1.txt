================================================================================
REDUX ESSENTIAL CONCEPTS
Comprehensive Study Guide - Part 1
================================================================================

WELCOME
-------
Welcome to Essential Concepts of Redux. This comprehensive guide will teach you 
everything you need to know about Redux, from the basics to understanding how 
all the pieces work together.

ESTIMATED TIME NEEDED
---------------------
5 minutes (for basic reading)
60-90 minutes (for comprehensive study with practice)

LEARNING OBJECTIVES
-------------------
After studying this guide, you will be able to:
• Discuss Redux concepts such as action, store, and reducer
• Describe the principles behind Redux architecture
• Explain the terms dispatching and action creators
• Relate the concepts action, store, and reducer to a user interface example
• Understand how Redux manages state at the application level
• Explain why Redux uses immutable state updates
• Understand the role of pure functions in Redux

OVERVIEW
--------
Redux offers a centralized state management system for your application. When 
you use Redux, you do not need to manage component states. Redux manages the 
states at the application level, not the individual components. Using this 
approach, you should treat the component properties as immutable. You create 
new state objects rather than changing existing ones.

Redux uses actions, stores, and reducers when updating component properties. 
These three concepts work together to create a predictable and maintainable 
way to manage application state.

================================================================================
TABLE OF CONTENTS - PART 1
================================================================================

PART 1: INTRODUCTION TO REDUX
  SECTION 1.1: WHAT IS REDUX?
  SECTION 1.2: WHY USE REDUX?
  SECTION 1.3: CENTRALIZED STATE MANAGEMENT
  SECTION 1.4: IMMUTABILITY IN REDUX

PART 2: CORE REDUX CONCEPTS
  SECTION 2.1: THE THREE PILLARS OF REDUX
  SECTION 2.2: THE STORE
  SECTION 2.3: ACTIONS
  SECTION 2.4: REDUCERS

NOTE: Parts 3-6 are covered in Part 2 of this guide, which includes:
• How Redux works together (data flow)
• Action creators and dispatching
• Complete e-commerce cart example
• Redux principles and benefits
• Summary and quick reference

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 1.3:") to quickly jump to any section.

================================================================================
PART 1: INTRODUCTION TO REDUX
================================================================================

SECTION 1.1: WHAT IS REDUX?
----------------------------

DEFINITION
----------
Redux offers a centralized state management system for your application. When 
you use Redux, you do not need to manage component states. Redux manages the 
states at the application level, not the individual components.

DETAILED EXPLANATION
--------------------
Redux is a JavaScript library designed to help you manage the state of your 
application in a predictable and organized way. Think of it as a single source 
of truth for all your application's data.

KEY CHARACTERISTICS:
• Centralized: All state lives in one place (the store)
• Application-level: State is managed globally, not per component
• Predictable: State changes follow a strict pattern
• Immutable: State is never directly modified, always replaced

REAL-WORLD ANALOGY
------------------
Think of Redux like a bank vault:
• The vault (store) holds all the money (state)
• To access or change money, you must follow specific procedures (actions)
• The bank teller (reducer) processes your request according to rules
• Every transaction is recorded (predictable state changes)
• You can't just walk in and grab money - you must go through the proper 
  process (dispatch actions)

WITHOUT REDUX (Component-Level State):
--------------------------------------
In a typical React app without Redux, each component manages its own state:

  function ShoppingCart() {
    const [items, setItems] = useState([]);
    const [total, setTotal] = useState(0);
    // Component manages its own state
  }

  function ProductList() {
    const [products, setProducts] = useState([]);
    // This component has separate state
  }

Problem: If ShoppingCart needs to know about products, you must pass data 
through props, which can become complicated.

WITH REDUX (Application-Level State):
-------------------------------------
With Redux, all state lives in one central store:

  // All state in one place
  store = {
    cart: { items: [], total: 0 },
    products: [...],
    user: {...}
  }

Benefit: Any component can access any part of the state it needs, without 
prop drilling.

[END SECTION 1.1]
================================================================================

SECTION 1.2: WHY USE REDUX?
----------------------------

THE PROBLEM REDUX SOLVES
------------------------
As applications grow larger and more complex, managing state becomes difficult:

1. PROP DRILLING
   • Passing data through many component layers
   • Components that don't need data must still pass it along
   • Makes code harder to maintain

2. STATE SYNCHRONIZATION
   • Multiple components need the same data
   • Keeping them in sync is error-prone
   • Changes in one place don't automatically update others

3. COMPLEX STATE LOGIC
   • State updates scattered across many components
   • Hard to track where state changes occur
   • Difficult to debug when something goes wrong

HOW REDUX HELPS
---------------
1. SINGLE SOURCE OF TRUTH
   • All state in one place (the store)
   • No confusion about where data lives
   • Easy to see current state of entire application

2. PREDICTABLE UPDATES
   • All state changes follow the same pattern
   • Actions describe what happened
   • Reducers describe how state changes
   • Easy to trace any state change

3. EASIER DEBUGGING
   • Can see every action that was dispatched
   • Can replay actions to reproduce bugs
   • Time-travel debugging possible

4. BETTER CODE ORGANIZATION
   • Logic separated from UI components
   • Easier to test business logic
   • More maintainable codebase

WHEN TO USE REDUX
-----------------
Use Redux when:
• You have large amounts of application state
• State is needed in many places
• State updates are complex
• You need to track state changes for debugging
• Multiple developers are working on the same codebase

Consider simpler alternatives when:
• Your app is small and simple
• State is mostly local to components
• You don't need complex state management
• Props and local state are sufficient

[END SECTION 1.2]
================================================================================

SECTION 1.3: CENTRALIZED STATE MANAGEMENT
-------------------------------------------

WHAT "CENTRALIZED" MEANS
-------------------------
When we say Redux offers centralized state management, we mean:

• ONE PLACE: All application state lives in a single store
• GLOBAL ACCESS: Any component can access any part of the state
• SINGLE SOURCE OF TRUTH: No duplicate state, no confusion about where data lives

COMPARISON: DECENTRALIZED VS CENTRALIZED
----------------------------------------

DECENTRALIZED (Without Redux):
------------------------------
  Component A has state: { count: 5 }
  Component B has state: { count: 3 }
  Component C has state: { count: 8 }
  
  Problem: Three different components, three different counts!
  How do you know which one is correct?

CENTRALIZED (With Redux):
-------------------------
  Store has state: { count: 5 }
  
  Component A reads: count = 5
  Component B reads: count = 5
  Component C reads: count = 5
  
  Benefit: All components see the same value!

THE STATE TREE
--------------
The store itself uses a data structure called a state tree to store and manage 
the application states. The tree is a JavaScript object with methods for 
managing its properties.

EXAMPLE OF A STATE TREE:
------------------------
  {
    cart: {
      items: [
        { id: 1, name: 'Product A', quantity: 2 },
        { id: 2, name: 'Product B', quantity: 1 }
      ],
      total: 99.99
    },
    user: {
      name: 'John Doe',
      email: 'john@example.com',
      isLoggedIn: true
    },
    products: {
      items: [...],
      loading: false,
      error: null
    }
  }

This is a tree structure because:
• Root level: The entire store
• Branches: Different sections (cart, user, products)
• Leaves: Individual values (name, email, total, etc.)

BENEFITS OF CENTRALIZED STATE
-----------------------------
1. CONSISTENCY
   • All components see the same data
   • No synchronization issues
   • Single source of truth

2. EASIER DEBUGGING
   • Can inspect entire application state
   • See exactly what data exists
   • Understand relationships between data

3. BETTER PERFORMANCE
   • Can optimize when components re-render
   • Only update components that need specific data
   • Avoid unnecessary re-renders

4. SIMPLER DATA FLOW
   • Data flows in one direction
   • Easy to understand how data moves
   • Predictable updates

[END SECTION 1.3]
================================================================================

SECTION 1.4: IMMUTABILITY IN REDUX
-----------------------------------

WHAT IS IMMUTABILITY?
---------------------
Immutability means "not changeable." In Redux, you should treat component 
properties as immutable. You create new state objects rather than changing 
existing ones.

SIMPLE EXPLANATION
------------------
Instead of modifying existing state:
  state.count = state.count + 1  // ❌ DON'T DO THIS

You create a new state object:
  newState = { ...state, count: state.count + 1 }  // ✅ DO THIS

WHY IMMUTABILITY MATTERS
------------------------
1. PREDICTABILITY
   • Old state remains unchanged
   • New state is clearly separate
   • Easy to compare old vs new state

2. DEBUGGING
   • Can see exactly what changed
   • Can track state history
   • Can undo changes if needed

3. PERFORMANCE
   • React can quickly detect changes
   • Only re-renders when state actually changes
   • Optimizations work better

4. TIME-TRAVEL DEBUGGING
   • Can go back to any previous state
   • Can replay actions
   • Powerful debugging tool

EXAMPLES: MUTABLE VS IMMUTABLE
-------------------------------

EXAMPLE 1: UPDATING A NUMBER
-----------------------------
MUTABLE (Wrong):
  let state = { count: 5 };
  state.count = 6;  // Changed original object
  // state is now { count: 6 }

IMMUTABLE (Correct):
  let state = { count: 5 };
  let newState = { ...state, count: 6 };  // New object
  // state is still { count: 5 }
  // newState is { count: 6 }

EXAMPLE 2: ADDING TO AN ARRAY
------------------------------
MUTABLE (Wrong):
  let state = { items: ['apple', 'banana'] };
  state.items.push('orange');  // Modified original array
  // state.items is now ['apple', 'banana', 'orange']

IMMUTABLE (Correct):
  let state = { items: ['apple', 'banana'] };
  let newState = { 
    ...state, 
    items: [...state.items, 'orange']  // New array
  };
  // state.items is still ['apple', 'banana']
  // newState.items is ['apple', 'banana', 'orange']

EXAMPLE 3: UPDATING NESTED OBJECTS
-----------------------------------
MUTABLE (Wrong):
  let state = { 
    user: { name: 'John', age: 30 }
  };
  state.user.age = 31;  // Modified nested object
  // state.user.age is now 31

IMMUTABLE (Correct):
  let state = { 
    user: { name: 'John', age: 30 }
  };
  let newState = {
    ...state,
    user: {
      ...state.user,
      age: 31  // New nested object
    }
  };
  // state.user.age is still 30
  // newState.user.age is 31

THE SPREAD OPERATOR (...)
-------------------------
The spread operator (...) is essential for creating immutable updates:

  const newState = { ...oldState };
  // Creates a shallow copy of oldState

  const newArray = [...oldArray];
  // Creates a copy of oldArray

  const newNested = {
    ...oldState,
    nested: { ...oldState.nested, newProp: value }
  };
  // Copies outer object and nested object

WHY REDUX REQUIRES IMMUTABILITY
-------------------------------
Redux requires immutability because:
• Reducers must be pure functions
• State comparisons need to work correctly
• Time-travel debugging requires state snapshots
• React's optimization relies on reference equality

[END SECTION 1.4]
[END PART 1]
================================================================================

PART 2: CORE REDUX CONCEPTS
================================================================================

SECTION 2.1: THE THREE PILLARS OF REDUX
----------------------------------------

OVERVIEW
--------
Redux uses actions, stores, and reducers when updating component properties. 
These three concepts work together to create a predictable state management 
system.

THE THREE PILLARS:
------------------
1. STORE - Contains all the current states of the application
2. ACTIONS - Indicate the need for a state update (what happened)
3. REDUCERS - Tell the store how to change the state (how to update)

HOW THEY WORK TOGETHER
----------------------
1. Component dispatches an ACTION (describes what happened)
2. STORE receives the action
3. STORE calls the REDUCER (determines how state changes)
4. REDUCER returns new state
5. STORE updates with new state
6. Components re-render with new state

VISUAL REPRESENTATION
---------------------
  Component → Action → Store → Reducer → New State → Component
     ↑                                                    ↓
     └────────────────── Re-render ←──────────────────────┘

ANALOGY: RESTAURANT ORDER
-------------------------
Think of Redux like ordering food at a restaurant:

1. ACTION = Your Order
   • "I want a burger" (describes what you want)
   • Doesn't say how to make it

2. STORE = The Kitchen
   • Contains all ingredients (current state)
   • Receives your order

3. REDUCER = The Recipe
   • Tells the chef how to make the burger
   • Takes ingredients (current state) and order (action)
   • Produces the burger (new state)

4. RESULT = Your Food
   • New state is delivered
   • You consume it (component uses new state)

[END SECTION 2.1]
================================================================================

SECTION 2.2: THE STORE
----------------------

DEFINITION
----------
The store contains all the current states of the application. The store itself 
uses a data structure called a state tree to store and manage the application 
states. The tree is a JavaScript object with methods for managing its properties.

DETAILED EXPLANATION
--------------------
The store is the heart of Redux. It's a single JavaScript object that holds 
your entire application state. Think of it as a database for your frontend 
application.

KEY CHARACTERISTICS:
• Single store for entire application
• Immutable - never directly modified
• Has methods to read state and dispatch actions
• Notifies subscribers when state changes

WHAT THE STORE CONTAINS
-----------------------
The store contains:
• Current application state (the state tree)
• Methods to access state (getState())
• Methods to update state (dispatch())
• Methods to listen for changes (subscribe())

EXAMPLE STORE STRUCTURE
------------------------
  {
    // State tree - all your application data
    cart: {
      items: [],
      total: 0,
      itemCount: 0
    },
    user: {
      name: '',
      email: '',
      isLoggedIn: false
    },
    products: {
      items: [],
      loading: false,
      error: null
    }
  }

STORE METHODS
-------------

1. getState()
   • Returns the current state tree
   • Use this to read state in components
   
   Example:
     const currentState = store.getState();
     console.log(currentState.cart.items);

2. dispatch(action)
   • Sends an action to the store
   • This is how you update state
   • Returns the action that was dispatched
   
   Example:
     store.dispatch({ type: 'ADD_ITEM', payload: item });

3. subscribe(listener)
   • Registers a function to be called when state changes
   • Returns a function to unsubscribe
   • Used by React-Redux to update components
   
   Example:
     const unsubscribe = store.subscribe(() => {
       console.log('State changed!');
     });

CREATING A STORE
----------------
To create a Redux store, you need:
• A reducer function
• (Optional) Initial state
• (Optional) Middleware

Basic Example:
  import { createStore } from 'redux';
  
  // Reducer function (we'll learn about this next)
  function reducer(state = initialState, action) {
    // ... reducer logic
  }
  
  // Create the store
  const store = createStore(reducer);

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: import { createStore } from 'redux';
        • Imports the createStore function from Redux library
        • createStore is the function that creates a Redux store

Line 2: (empty line for readability)

Line 3: function reducer(state = initialState, action) {
        • Defines a reducer function
        • state = initialState - default parameter, sets initial state
        • action - the action object that was dispatched
        • This function determines how state changes

Line 4: // ... reducer logic
        • Placeholder for reducer logic
        • We'll see full examples later

Line 5: }
        • Closes the reducer function

Line 6: (empty line)

Line 7: const store = createStore(reducer);
        • Creates the Redux store
        • Passes the reducer function to createStore
        • store now contains all application state
        • store has methods: getState(), dispatch(), subscribe()

THE STATE TREE EXPLAINED
------------------------
The state tree is a nested JavaScript object that represents your entire 
application state. It's called a "tree" because:

• ROOT: The entire store object
• BRANCHES: Major sections (cart, user, products)
• LEAVES: Individual values (name, total, items)

Example Tree Structure:
  Store (Root)
  ├── cart (Branch)
  │   ├── items (Leaf - array)
  │   ├── total (Leaf - number)
  │   └── itemCount (Leaf - number)
  ├── user (Branch)
  │   ├── name (Leaf - string)
  │   ├── email (Leaf - string)
  │   └── isLoggedIn (Leaf - boolean)
  └── products (Branch)
      ├── items (Leaf - array)
      ├── loading (Leaf - boolean)
      └── error (Leaf - string or null)

WHY A SINGLE STORE?
-------------------
Redux uses a single store because:
• Single source of truth
• Easier to debug (one place to look)
• Simpler mental model
• Better performance (one place to optimize)
• Easier to serialize/deserialize state

[END SECTION 2.2]
================================================================================

SECTION 2.3: ACTIONS
--------------------

DEFINITION
----------
You call an action object to indicate the need for a state update, but the 
action does not specify how to change that state. The action object describes 
the action that needs to be performed. It contains properties including type 
and payload.

DETAILED EXPLANATION
--------------------
An action is a plain JavaScript object that describes something that happened 
in your application. It's like a message that says "this event occurred" but 
doesn't say how to handle it.

KEY CHARACTERISTICS:
• Plain JavaScript object
• Must have a 'type' property
• Can have a 'payload' property (or other properties)
• Describes WHAT happened, not HOW to handle it

ACTION STRUCTURE
----------------
Every action must have:
• type: A string describing the action (required)
• payload: Data needed for the update (optional, can be named anything)

BASIC ACTION FORMAT:
--------------------
  {
    type: 'ACTION_TYPE',
    payload: data  // Optional
  }

EXAMPLES OF ACTIONS
-------------------

EXAMPLE 1: ADD ITEM TO CART
----------------------------
  {
    type: 'ADD_ITEM',
    payload: {
      id: 1,
      name: 'Product A',
      price: 29.99,
      quantity: 1
    }
  }

Explanation:
• type: 'ADD_ITEM' - Describes what happened (item was added)
• payload: Contains the item data needed to update state
• This action says "an item was added" but doesn't say how to add it

EXAMPLE 2: REMOVE ITEM FROM CART
--------------------------------
  {
    type: 'REMOVE_ITEM',
    payload: {
      id: 1  // ID of item to remove
    }
  }

Explanation:
• type: 'REMOVE_ITEM' - Describes what happened
• payload: Contains ID of item to remove
• Action describes the event, reducer will handle the logic

EXAMPLE 3: UPDATE QUANTITY
--------------------------
  {
    type: 'UPDATE_QUANTITY',
    payload: {
      id: 1,
      quantity: 3  // New quantity
    }
  }

Explanation:
• type: 'UPDATE_QUANTITY' - Describes what happened
• payload: Contains item ID and new quantity
• Action is descriptive of the event

EXAMPLE 4: SIMPLE ACTION (NO PAYLOAD)
--------------------------------------
  {
    type: 'CLEAR_CART'
  }

Explanation:
• type: 'CLEAR_CART' - Describes what happened
• No payload needed - action is self-explanatory
• Reducer will know to clear all items

ACTION TYPE NAMING CONVENTIONS
-------------------------------
Action types are usually:
• UPPERCASE - Makes them stand out
• DESCRIPTIVE - Clearly describe what happened
• NOUN_VERB format - e.g., 'ITEM_ADDED', 'USER_LOGGED_IN'

Good Examples:
  'ADD_ITEM'
  'REMOVE_ITEM'
  'UPDATE_QUANTITY'
  'CLEAR_CART'
  'USER_LOGIN'
  'FETCH_PRODUCTS_SUCCESS'

Bad Examples:
  'add'  // Too vague
  'update'  // Not specific
  'doStuff'  // Not descriptive
  'action1'  // Meaningless

WHY ACTIONS DON'T SPECIFY HOW
------------------------------
Actions describe WHAT happened, not HOW to handle it. This separation is 
important because:

1. FLEXIBILITY
   • Same action can be handled differently in different reducers
   • Can change how state updates without changing actions
   • Easier to test actions separately from logic

2. CLARITY
   • Actions are simple, easy to understand
   • Focus on describing events, not implementation
   • Makes code more readable

3. PREDICTABILITY
   • Can see all possible events in your app
   • Easy to track what actions are dispatched
   • Better debugging

ACTION CREATORS (PREVIEW)
-------------------------
Instead of creating action objects directly, you use action creator functions:

  // Action creator function
  function addItem(item) {
    return {
      type: 'ADD_ITEM',
      payload: item
    };
  }

  // Usage
  store.dispatch(addItem({ id: 1, name: 'Product A' }));

We'll cover action creators in detail in Part 3.

[END SECTION 2.3]
================================================================================

SECTION 2.4: REDUCERS
---------------------

DEFINITION
----------
Instead of specifying the how in the action, you write a reducer function to 
how to update the state in the store. When the store receives the action, it 
calls the appropriate reducer and passes both the action object and the state 
object to the reducer function to calculate the new state. Note that the reducer 
is a pure function, meaning it always returns the same output when given the 
same inputs, it has no side effects or mutating functions.

DETAILED EXPLANATION
--------------------
A reducer is a function that takes the current state and an action, then 
returns the new state. It's called a "reducer" because it reduces the current 
state and an action into a new state.

KEY CHARACTERISTICS:
• Pure function (same input = same output)
• No side effects
• Never mutates state directly
• Returns new state object
• Determines HOW state changes based on action type

REDUCER FUNCTION SIGNATURE
--------------------------
  function reducer(state, action) {
    // Determine how to update state based on action.type
    return newState;
  }

Parameters:
• state - Current state from the store
• action - Action object that was dispatched

Returns:
• newState - New state object (never modify state directly)

REDUCER RULES
-------------
1. MUST RETURN STATE
   • Always return a state object
   • Even if state doesn't change, return current state

2. MUST BE PURE
   • No API calls
   • No random numbers
   • No Date.now()
   • Same inputs always produce same output

3. MUST NOT MUTATE STATE
   • Never modify state directly
   • Always create new objects/arrays
   • Use spread operator or Object.assign

4. MUST HANDLE UNKNOWN ACTIONS
   • Return current state for unknown action types
   • Use default case in switch statement

BASIC REDUCER EXAMPLE
---------------------
  function cartReducer(state = { items: [], total: 0 }, action) {
    switch (action.type) {
      case 'ADD_ITEM':
        return {
          ...state,
          items: [...state.items, action.payload],
          total: state.total + action.payload.price
        };
      
      case 'REMOVE_ITEM':
        return {
          ...state,
          items: state.items.filter(item => item.id !== action.payload.id),
          total: state.total - action.payload.price
        };
      
      default:
        return state;
    }
  }

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: function cartReducer(state = { items: [], total: 0 }, action) {
        • Defines reducer function named cartReducer
        • state = { items: [], total: 0 } - default parameter
          - If state is undefined, uses this initial state
          - items: [] - empty array for cart items
          - total: 0 - starting total is zero
        • action - the action object dispatched to the store

Line 2: switch (action.type) {
        • Switch statement checks the action's type property
        • Determines which case to execute based on action type
        • This is how reducer knows what to do

Line 3: case 'ADD_ITEM':
        • If action.type === 'ADD_ITEM', execute this case
        • Handles adding an item to the cart

Line 4: return {
        • Returns a new state object
        • This replaces the old state in the store

Line 5: ...state,
        • Spread operator copies all properties from current state
        • Keeps existing state properties (if any)
        • Creates a new object (immutable update)

Line 6: items: [...state.items, action.payload],
        • Creates new items array
        • ...state.items - copies all existing items
        • action.payload - adds the new item from action
        • New array, doesn't modify original

Line 7: total: state.total + action.payload.price
        • Calculates new total
        • Adds the new item's price to current total
        • Creates new state with updated total

Line 8: };
        • Closes the return object
        • Closes the case statement

Line 9: (empty line)

Line 10: case 'REMOVE_ITEM':
         • If action.type === 'REMOVE_ITEM', execute this case
         • Handles removing an item from the cart

Line 11: return {
         • Returns new state object

Line 12: ...state,
         • Copies current state properties

Line 13: items: state.items.filter(item => item.id !== action.payload.id),
         • Creates new items array without removed item
         • filter() creates new array (doesn't modify original)
         • Keeps items where id doesn't match payload id
         • Removes the item with matching id

Line 14: total: state.total - action.payload.price
         • Subtracts removed item's price from total
         • Updates total in new state

Line 15: };
         • Closes return object and case

Line 16: (empty line)

Line 17: default:
         • Handles any action types not explicitly handled
         • Important: must return state for unknown actions

Line 18: return state;
         • Returns current state unchanged
         • Prevents errors if unknown action is dispatched

Line 19: }
         • Closes switch statement

Line 20: }
         • Closes reducer function

WHY REDUCERS ARE PURE FUNCTIONS
-------------------------------
Pure functions have these characteristics:
• Same input always produces same output
• No side effects (no API calls, no mutations)
• No dependencies on external state

Example of Pure Function:
  function add(a, b) {
    return a + b;  // Always returns same result for same inputs
  }

Example of Impure Function:
  function addRandom(a) {
    return a + Math.random();  // Different result each time!
  }

Why Reducers Must Be Pure:
• Predictable - same action always produces same state change
• Testable - easy to test with known inputs
• Debuggable - can replay actions and get same result
• Time-travel - can go back to any previous state

WHAT REDUCERS CANNOT DO
-----------------------
Reducers cannot:
• Mutate state directly (state.items.push() ❌)
• Call APIs or make network requests
• Generate random numbers
• Call non-pure functions (Date.now(), Math.random())
• Have side effects (console.log is okay for debugging)

WHAT REDUCERS MUST DO
---------------------
Reducers must:
• Return a new state object
• Handle all action types (use default case)
• Return current state for unknown actions
• Be pure functions

COMBINING MULTIPLE REDUCERS
---------------------------
For larger applications, you can split reducers:

  function cartReducer(state = { items: [] }, action) {
    // Handles cart-related actions
  }

  function userReducer(state = { name: '' }, action) {
    // Handles user-related actions
  }

  // Combine them
  const rootReducer = combineReducers({
    cart: cartReducer,
    user: userReducer
  });

We'll see more examples in the practical section.

[END SECTION 2.4]
[END PART 2]
================================================================================

END OF PART 1
================================================================================

Continue to Part 2 for:
• How Redux works together (data flow)
• Action creators and dispatching
• Complete e-commerce cart example
• Redux principles and benefits
• Summary and quick reference

================================================================================

Author(s)
---------
Based on: Essential Concepts of Redux video transcript

Original Content Maintained
----------------------------
All original definitions, explanations, and concepts from the source material 
have been preserved and expanded upon in this comprehensive guide.

