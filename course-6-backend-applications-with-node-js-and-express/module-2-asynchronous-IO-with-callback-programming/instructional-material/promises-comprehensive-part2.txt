================================================================================
JAVASCRIPT PROMISES
Comprehensive Study Guide - Part 2
================================================================================

This is Part 2 of the comprehensive guide. Part 1 covered:
• Introduction to Promises
• Promise States (pending, resolved, rejected)
• Creating Promises

This part covers:
• Using promises with .then() and .catch() methods
• File reading example with detailed explanations
• HTTP requests with axios example with detailed explanations
• Summary, key definitions, and best practices

================================================================================
TABLE OF CONTENTS - PART 2
================================================================================

PART 4: USING PROMISES
  SECTION 4.1: THE .THEN() METHOD
  SECTION 4.2: THE .CATCH() METHOD
  SECTION 4.3: CHAINING PROMISES

PART 5: FILE READING WITH PROMISES
  SECTION 5.1: FILE READING OVERVIEW
  SECTION 5.2: COMPLETE FILE READING EXAMPLE
  SECTION 5.3: HANDLING FILE READING ERRORS

PART 6: HTTP REQUESTS WITH PROMISES
  SECTION 6.1: HTTP REQUESTS AND BLOCKING
  SECTION 6.2: THE AXIOS PACKAGE
  SECTION 6.3: COMPLETE AXIOS EXAMPLE WITH VALID URL
  SECTION 6.4: COMPLETE AXIOS EXAMPLE WITH INVALID URL

PART 7: SUMMARY AND KEY TAKEAWAYS
  SECTION 7.1: CONCEPT SUMMARY
  SECTION 7.2: KEY DEFINITIONS
  SECTION 7.3: QUICK REFERENCE GUIDE
  SECTION 7.4: BEST PRACTICES

================================================================================
PART 4: USING PROMISES
================================================================================

SECTION 4.1: THE .THEN() METHOD
--------------------------------

DEFINITION
----------
The promise object has a "then" method which is called after the promise is 
fulfilled.

DETAILED EXPLANATION
--------------------
The .then() method is used to handle a Promise when it is resolved (fulfilled). 
It attaches a callback function that will execute when the Promise transitions 
from pending to resolved state.

BASIC SYNTAX
------------
  promise.then(onFulfilled);

OR WITH BOTH SUCCESS AND ERROR HANDLERS:
  promise.then(onFulfilled, onRejected);

BREAKDOWN:
----------
• promise - The Promise object you want to handle
• .then() - Method that attaches a handler
• onFulfilled - Function that runs when Promise is resolved
• onRejected - Optional function that runs when Promise is rejected

WHAT .THEN() DOES
-----------------
1. Attaches a handler function to the Promise
2. Returns a new Promise (allowing chaining)
3. Executes the handler when the original Promise resolves
4. Passes the resolved value to the handler function

BASIC EXAMPLE
-------------
  const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Hello, World!');
    }, 1000);
  });
  
  promise.then(result => {
    console.log(result); // "Hello, World!" - executed after 1 second
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: const promise = new Promise((resolve, reject) => {
        • Creates a new Promise
        • Promise starts in pending state

Line 2: setTimeout(() => {
        • Simulates async operation (1 second delay)

Line 3: resolve('Hello, World!');
        • After 1 second, resolves with 'Hello, World!'
        • Promise transitions from pending to resolved

Line 4: }, 1000);
        • Closes setTimeout with 1 second delay

Line 5: });
        • Closes Promise constructor

Line 7: promise.then(result => {
        • Attaches a handler to the Promise
        • .then() is called immediately (doesn't wait)
        • The handler function will execute when Promise resolves
        • result - Parameter that receives the resolved value
        • In this case, result will be 'Hello, World!'

Line 8: console.log(result);
        • Logs the resolved value
        • This executes after the Promise resolves (after 1 second)
        • Will output: "Hello, World!"

Line 9: });
        • Closes the .then() handler function

IMPORTANT NOTES
---------------
• .then() returns immediately (doesn't wait for Promise to resolve)
• The handler function executes later (when Promise resolves)
• You can attach .then() even after the Promise is already resolved
• .then() always returns a new Promise (enables chaining)

REAL-WORLD ANALOGY
------------------
Think of .then() like setting up a notification:
• You order food (create Promise) → Promise is pending
• You give your phone number (.then() handler) → Handler is attached
• Food arrives (Promise resolves) → You get a call (handler executes)
• You receive the food (get the resolved value)

[END SECTION 4.1]
================================================================================

SECTION 4.2: THE .CATCH() METHOD
---------------------------------

DEFINITION
----------
The catch is executed if the promise is rejected.

DETAILED EXPLANATION
--------------------
The .catch() method is used to handle a Promise when it is rejected. It 
attaches a callback function that will execute when the Promise transitions 
from pending to rejected state.

BASIC SYNTAX
------------
  promise.catch(onRejected);

BREAKDOWN:
----------
• promise - The Promise object you want to handle
• .catch() - Method that attaches an error handler
• onRejected - Function that runs when Promise is rejected

WHAT .CATCH() DOES
------------------
1. Attaches an error handler function to the Promise
2. Returns a new Promise (allowing chaining)
3. Executes the handler when the original Promise rejects
4. Passes the rejection reason (error) to the handler function

BASIC EXAMPLE
-------------
  const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error('Something went wrong!'));
    }, 1000);
  });
  
  promise.catch(error => {
    console.log(error.message); // "Something went wrong!" - executed after 1 second
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: const promise = new Promise((resolve, reject) => {
        • Creates a new Promise
        • Promise starts in pending state

Line 2: setTimeout(() => {
        • Simulates async operation (1 second delay)

Line 3: reject(new Error('Something went wrong!'));
        • After 1 second, rejects with an Error
        • Promise transitions from pending to rejected
        • new Error() creates an Error object with a message

Line 4: }, 1000);
        • Closes setTimeout with 1 second delay

Line 5: });
        • Closes Promise constructor

Line 7: promise.catch(error => {
        • Attaches an error handler to the Promise
        • .catch() is called immediately (doesn't wait)
        • The handler function will execute when Promise rejects
        • error - Parameter that receives the rejection reason
        • In this case, error will be the Error object

Line 8: console.log(error.message);
        • Logs the error message
        • .message is a property of Error objects
        • This executes after the Promise rejects (after 1 second)
        • Will output: "Something went wrong!"

Line 9: });
        • Closes the .catch() handler function

IMPORTANT NOTES
---------------
• .catch() returns immediately (doesn't wait for Promise to reject)
• The handler function executes later (when Promise rejects)
• You can attach .catch() even after the Promise is already rejected
• .catch() always returns a new Promise (enables chaining)
• .catch() is equivalent to .then(null, onRejected)

REAL-WORLD ANALOGY
------------------
Think of .catch() like an error notification system:
• You place an order (create Promise) → Promise is pending
• You set up error alerts (.catch() handler) → Handler is attached
• Order fails (Promise rejects) → You get an alert (handler executes)
• You see what went wrong (get the error information)

[END SECTION 4.2]
================================================================================

SECTION 4.3: CHAINING PROMISES
-------------------------------

COMBINING .THEN() AND .CATCH()
-------------------------------
You can use both .then() and .catch() together on the same Promise:

  promise
    .then(result => {
      // Handle success
      console.log('Success:', result);
    })
    .catch(error => {
      // Handle error
      console.log('Error:', error.message);
    });

HOW IT WORKS:
------------
• If Promise resolves → .then() handler executes
• If Promise rejects → .catch() handler executes
• Only one will execute (never both)

CHAINING MULTIPLE .THEN() CALLS
--------------------------------
You can chain multiple .then() calls to perform sequential operations:

  promise
    .then(result1 => {
      // Process result1
      return processResult(result1);
    })
    .then(result2 => {
      // Process result2 (from previous .then())
      return processResult(result2);
    })
    .then(result3 => {
      // Final result
      console.log('Final:', result3);
    })
    .catch(error => {
      // Handles errors from any step
      console.log('Error:', error);
    });

HOW CHAINING WORKS:
-------------------
1. First .then() receives the original resolved value
2. If it returns a value, that becomes the input for the next .then()
3. If it returns a Promise, the next .then() waits for that Promise
4. If any step rejects, the .catch() handles it
5. Errors "bubble up" to the nearest .catch()

EXAMPLE: CHAINING OPERATIONS
----------------------------
  function step1() {
    return new Promise(resolve => {
      setTimeout(() => resolve(1), 1000);
    });
  }
  
  function step2(value) {
    return new Promise(resolve => {
      setTimeout(() => resolve(value + 1), 1000);
    });
  }
  
  function step3(value) {
    return new Promise(resolve => {
      setTimeout(() => resolve(value + 1), 1000);
    });
  }
  
  step1()
    .then(result1 => {
      console.log('Step 1 result:', result1); // 1
      return step2(result1);
    })
    .then(result2 => {
      console.log('Step 2 result:', result2); // 2
      return step3(result2);
    })
    .then(result3 => {
      console.log('Step 3 result:', result3); // 3
    })
    .catch(error => {
      console.log('Error in any step:', error);
    });

OUTPUT (after 3 seconds):
--------------------------
Step 1 result: 1
Step 2 result: 2
Step 3 result: 3

[END SECTION 4.3]
[END PART 4]
================================================================================

PART 5: FILE READING WITH PROMISES
================================================================================

SECTION 5.1: FILE READING OVERVIEW
-----------------------------------

WHY FILE READING USES PROMISES
--------------------------------
File reading operations are input/output (I/O) operations that are time 
consuming and can block resources. Reading a file involves:
• Opening the file from disk
• Reading the file contents
• Closing the file

These operations take time because:
• Disk access is slower than memory access
• File size affects reading time
• Multiple files take longer

PROMISES FOR FILE OPERATIONS
----------------------------
You can create a promise object if you know that the operations you are going 
to perform could be blocking. File reading is a perfect example of a 
blocking operation that benefits from Promises.

NODE.JS FILE READING
--------------------
In Node.js, you can read files using:
• fs.promises.readFile() - Returns a Promise (modern approach)
• fs.readFile() with callbacks - Uses callbacks (older approach)

We'll focus on the Promise-based approach.

[END SECTION 5.1]
================================================================================

SECTION 5.2: COMPLETE FILE READING EXAMPLE
-------------------------------------------

ORIGINAL CONTEXT
----------------
In the original content, there's an example where "methCall is a promise which 
is fulfilled or rejected depending on whether the file is successfully read 
or not. You can see on the output screen that the content of the file is read 
if the filename is valid and displayed. In this case the promise is resolved. 
If the filename is invalid, the promise is rejected and the error message is 
displayed."

COMPLETE EXAMPLE WITH DETAILED EXPLANATIONS
-------------------------------------------
  const fs = require('fs').promises;
  
  // Function that reads a file and returns a Promise
  function readFilePromise(filename) {
    return fs.readFile(filename, 'utf8');
  }
  
  // Using the Promise
  const methCall = readFilePromise('data.txt');
  
  methCall
    .then(data => {
      console.log('File content:', data);
      console.log('Promise is resolved - file read successfully!');
    })
    .catch(error => {
      console.log('Error:', error.message);
      console.log('Promise is rejected - file read failed!');
    });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: const fs = require('fs').promises;
        • require('fs') - Imports Node.js file system module
        • .promises - Accesses the Promise-based version of fs
        • This gives us functions that return Promises instead of using callbacks
        • fs.promises.readFile() returns a Promise

Line 2: (empty line for readability)

Line 3: // Function that reads a file and returns a Promise
        • Comment explaining the next function

Line 4: function readFilePromise(filename) {
        • Defines a function that reads a file
        • filename - Parameter: the name/path of the file to read
        • This function returns a Promise

Line 5: return fs.readFile(filename, 'utf8');
        • fs.readFile() - Reads a file asynchronously
        • filename - First argument: which file to read
        • 'utf8' - Second argument: encoding (how to interpret file contents)
        • 'utf8' means interpret as text (not binary)
        • This returns a Promise that resolves with file contents
        • If file doesn't exist or can't be read, Promise rejects

Line 6: }
        • Closes the readFilePromise function

Line 7: (empty line)

Line 8: // Using the Promise
        • Comment explaining the next code

Line 9: const methCall = readFilePromise('data.txt');
        • const methCall - Creates a variable to store the Promise
        • readFilePromise('data.txt') - Calls the function with filename 'data.txt'
        • This creates a Promise object immediately
        • The Promise is in pending state
        • File reading starts in the background
        • methCall is the promise which is fulfilled or rejected depending on 
          whether the file is successfully read or not

Line 10: (empty line)

Line 11: methCall
         • References the Promise object
         • We're about to attach handlers to it

Line 12: .then(data => {
         • Attaches a success handler
         • .then() is called after the promise is fulfilled
         • data - Parameter that receives the file contents
         • This handler executes if the file is read successfully

Line 13: console.log('File content:', data);
         • Logs the file contents to the console
         • data contains the text from the file
         • You can see on the output screen that the content of the file is 
           read if the filename is valid and displayed

Line 14: console.log('Promise is resolved - file read successfully!');
         • Logs a success message
         • In this case the promise is resolved
         • This confirms the file was read successfully

Line 15: })
         • Closes the .then() handler

Line 16: .catch(error => {
         • Attaches an error handler
         • The catch is executed if the promise is rejected
         • error - Parameter that receives the error object
         • This handler executes if the file cannot be read

Line 17: console.log('Error:', error.message);
         • Logs the error message
         • error.message contains a description of what went wrong
         • If the filename is invalid, the promise is rejected and the error 
           message is displayed

Line 18: console.log('Promise is rejected - file read failed!');
         • Logs a failure message
         • This confirms the file read failed

Line 19: });
         • Closes the .catch() handler

SCENARIO 1: VALID FILENAME
--------------------------
If 'data.txt' exists and can be read:

OUTPUT:
-------
File content: [contents of data.txt]
Promise is resolved - file read successfully!

WHAT HAPPENS:
------------
1. readFilePromise('data.txt') is called
2. Promise is created in pending state
3. File reading starts in background
4. File is found and read successfully
5. Promise transitions to resolved state
6. .then() handler executes with file contents
7. File content is displayed
8. Success message is logged

SCENARIO 2: INVALID FILENAME
-----------------------------
If 'data.txt' doesn't exist or can't be read:

OUTPUT:
-------
Error: ENOENT: no such file or directory, open 'data.txt'
Promise is rejected - file read failed!

WHAT HAPPENS:
------------
1. readFilePromise('data.txt') is called
2. Promise is created in pending state
3. File reading starts in background
4. File is not found (or permission denied)
5. Promise transitions to rejected state
6. .catch() handler executes with error object
7. Error message is displayed
8. Failure message is logged

ALTERNATIVE: USING ASYNC/AWAIT
------------------------------
Modern JavaScript also supports async/await syntax (which uses Promises under 
the hood):

  const fs = require('fs').promises;
  
  async function readFileExample() {
    try {
      const data = await fs.readFile('data.txt', 'utf8');
      console.log('File content:', data);
      console.log('Promise is resolved - file read successfully!');
    } catch (error) {
      console.log('Error:', error.message);
      console.log('Promise is rejected - file read failed!');
    }
  }
  
  readFileExample();

This does the same thing but with different syntax. The await keyword waits 
for the Promise to resolve, and try/catch handles both success and error cases.

[END SECTION 5.2]
================================================================================

SECTION 5.3: HANDLING FILE READING ERRORS
------------------------------------------

COMMON FILE READING ERRORS
---------------------------
When reading files, Promises can be rejected for various reasons:

1. FILE NOT FOUND (ENOENT)
   Error: ENOENT: no such file or directory
   Cause: The file doesn't exist at the specified path
   Solution: Check the file path and ensure the file exists

2. PERMISSION DENIED (EACCES)
   Error: EACCES: permission denied
   Cause: The process doesn't have permission to read the file
   Solution: Check file permissions or run with appropriate privileges

3. DIRECTORY INSTEAD OF FILE (EISDIR)
   Error: EISDIR: illegal operation on a directory
   Cause: The path points to a directory, not a file
   Solution: Ensure the path points to a file, not a directory

4. FILE TOO LARGE
   Error: File size exceeds limit
   Cause: The file is too large to read into memory
   Solution: Use streaming instead of reading entire file

EXAMPLE: COMPREHENSIVE ERROR HANDLING
--------------------------------------
  const fs = require('fs').promises;
  
  function readFileSafely(filename) {
    return fs.readFile(filename, 'utf8')
      .then(data => {
        // Success case
        return {
          success: true,
          data: data,
          message: 'File read successfully'
        };
      })
      .catch(error => {
        // Error case
        let errorMessage = 'Unknown error';
        
        if (error.code === 'ENOENT') {
          errorMessage = 'File not found';
        } else if (error.code === 'EACCES') {
          errorMessage = 'Permission denied';
        } else if (error.code === 'EISDIR') {
          errorMessage = 'Path is a directory, not a file';
        } else {
          errorMessage = error.message;
        }
        
        return {
          success: false,
          data: null,
          message: errorMessage,
          error: error
        };
      });
  }
  
  // Usage
  readFileSafely('data.txt')
    .then(result => {
      if (result.success) {
        console.log('Success:', result.message);
        console.log('Content:', result.data);
      } else {
        console.log('Error:', result.message);
      }
    });

This example shows how to handle different types of file reading errors and 
provide user-friendly error messages.

[END SECTION 5.3]
[END PART 5]
================================================================================

PART 6: HTTP REQUESTS WITH PROMISES
================================================================================

SECTION 6.1: HTTP REQUESTS AND BLOCKING
-----------------------------------------

WHY HTTP REQUESTS USE PROMISES
--------------------------------
You know that hypertext transfer protocol (HTTP) requests when called 
synchronously can be blocking. HTTP requests involve:
• Sending a request over the network
• Waiting for the server to process it
• Receiving the response

These operations take time because:
• Network latency (time for data to travel)
• Server processing time
• Response size affects download time
• Network conditions vary

BLOCKING NATURE OF HTTP REQUESTS
---------------------------------
If HTTP requests were synchronous (blocking):
• Your application would freeze while waiting
• Users couldn't interact with the UI
• Other operations would be delayed
• Poor user experience

PROMISES SOLVE THIS
-------------------
By using Promises with HTTP requests:
• Request is sent asynchronously (non-blocking)
• Your code continues executing
• Response is handled when it arrives
• Better user experience

PACKAGES FOR HTTP REQUESTS
--------------------------
There are many packages in the Node.js ecosystem that wrap promises around 
HTTP requests. These packages make HTTP requests and return Promise objects, 
making it easy to handle asynchronous HTTP operations.

[END SECTION 6.1]
================================================================================

SECTION 6.2: THE AXIOS PACKAGE
--------------------------------

DEFINITION
----------
The axios package is one such package to handle HTTP requests. It returns a 
promise object.

DETAILED EXPLANATION
--------------------
Axios is a popular JavaScript library for making HTTP requests. It's commonly 
used in both Node.js and browser environments. Axios automatically returns 
Promise objects for all HTTP methods (GET, POST, PUT, DELETE, etc.).

INSTALLATION
------------
To use axios, you need to install it first:

  npm install axios

Or with yarn:

  yarn add axios

BASIC USAGE
-----------
  const axios = require('axios');
  
  axios.get('https://api.example.com/data')
    .then(response => {
      console.log(response.data);
    })
    .catch(error => {
      console.log(error.message);
    });

KEY FEATURES OF AXIOS
---------------------
• Returns Promises automatically
• Supports all HTTP methods (GET, POST, PUT, DELETE, etc.)
• Automatic JSON data transformation
• Request and response interceptors
• Better error handling
• Works in both Node.js and browsers

PROMISE STATES WITH AXIOS
-------------------------
The status of the promise until it hears back from the uniform resource 
locator (URL) requested is pending. This means:
• When you call axios.get(), a Promise is created immediately
• The Promise is in pending state
• The HTTP request is sent in the background
• Promise remains pending until response arrives
• Then Promise resolves (success) or rejects (error)

[END SECTION 6.2]
================================================================================

SECTION 6.3: COMPLETE AXIOS EXAMPLE WITH VALID URL
----------------------------------------------------

ORIGINAL CONTEXT
----------------
In the original content: "In this example, you first pass a valid URL. It 
creates a pending promise. Once the promise is fulfilled, then the response 
is logged on the console."

COMPLETE EXAMPLE WITH DETAILED EXPLANATIONS
-------------------------------------------
  const axios = require('axios');
  
  // Making a request with a valid URL
  const validUrl = 'https://jsonplaceholder.typicode.com/posts/1';
  
  const promise = axios.get(validUrl);
  
  promise
    .then(response => {
      console.log('Response received:');
      console.log('Status:', response.status);
      console.log('Data:', response.data);
      console.log('Promise is fulfilled - request successful!');
    })
    .catch(error => {
      console.log('Error:', error.message);
      console.log('Promise is rejected - request failed!');
    });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: const axios = require('axios');
        • require('axios') - Imports the axios library
        • axios - The axios object with methods for HTTP requests
        • This must be installed first: npm install axios

Line 2: (empty line for readability)

Line 3: // Making a request with a valid URL
        • Comment explaining what comes next

Line 4: const validUrl = 'https://jsonplaceholder.typicode.com/posts/1';
        • const validUrl - Creates a constant to store the URL
        • 'https://...' - A valid URL string
        • This is a test API that returns sample data
        • /posts/1 means get post with ID 1
        • This URL exists and will return data

Line 5: (empty line)

Line 6: const promise = axios.get(validUrl);
        • const promise - Creates a variable to store the Promise
        • axios.get() - Makes a GET HTTP request
        • validUrl - The URL to request data from
        • This creates a promise object immediately
        • It creates a pending promise
        • The HTTP request starts in the background
        • The status of the promise until it hears back from the uniform 
          resource locator (URL) requested is pending

Line 7: (empty line)

Line 8: promise
         • References the Promise object
         • We're about to attach handlers

Line 9: .then(response => {
         • Attaches a success handler
         • The promise object has a "then" method which is called after the 
           promise is fulfilled
         • response - Parameter that receives the HTTP response object
         • This handler executes when the request succeeds
         • Once the promise is fulfilled, then the response is logged on the 
           console

Line 10: console.log('Response received:');
         • Logs a message indicating response was received
         • This executes after the Promise resolves

Line 11: console.log('Status:', response.status);
         • Logs the HTTP status code
         • response.status - Property containing the status code (e.g., 200)
         • 200 means success
         • Other codes: 404 (not found), 500 (server error), etc.

Line 12: console.log('Data:', response.data);
         • Logs the response data
         • response.data - Property containing the actual data from the server
         • For JSON responses, this is automatically parsed
         • This contains the post data from the API

Line 13: console.log('Promise is fulfilled - request successful!');
         • Logs a success message
         • Confirms the Promise was fulfilled (resolved)
         • You can see the console log for the resolve

Line 14: })
         • Closes the .then() handler

Line 15: .catch(error => {
         • Attaches an error handler
         • The catch is executed if the promise is rejected
         • error - Parameter that receives the error object
         • This handler executes if the request fails

Line 16: console.log('Error:', error.message);
         • Logs the error message
         • error.message contains a description of the error
         • This would execute if the request failed

Line 17: console.log('Promise is rejected - request failed!');
         • Logs a failure message
         • This would execute if the request failed

Line 18: });
         • Closes the .catch() handler

EXPECTED OUTPUT (with valid URL):
----------------------------------
Response received:
Status: 200
Data: { userId: 1, id: 1, title: '...', body: '...' }
Promise is fulfilled - request successful!

WHAT HAPPENS:
-------------
1. axios.get(validUrl) is called
2. Promise is created in pending state
3. HTTP request is sent in the background
4. Code continues (doesn't wait)
5. Server processes request and sends response
6. Promise transitions to resolved state
7. .then() handler executes with response object
8. Response data is logged to console
9. Success message is displayed

TIMING:
-------
• Promise creation: Immediate (0ms)
• HTTP request sent: Immediate (0ms)
• Promise state: Pending (waiting for response)
• Response arrives: ~100-500ms (depends on network)
• Promise resolves: When response arrives
• .then() executes: Immediately after resolution

[END SECTION 6.3]
================================================================================

SECTION 6.4: COMPLETE AXIOS EXAMPLE WITH INVALID URL
-----------------------------------------------------

ORIGINAL CONTEXT
----------------
In the original content: "Next, you pass an invalid URL. This also creates a 
promise object which is pending. This promise will be rejected. This state is 
being dealt with in the catch block. You can see the console log for the 
resolve and reject."

COMPLETE EXAMPLE WITH DETAILED EXPLANATIONS
-------------------------------------------
  const axios = require('axios');
  
  // Making a request with an invalid URL
  const invalidUrl = 'https://invalid-url-that-does-not-exist.com/api/data';
  
  const promise = axios.get(invalidUrl);
  
  promise
    .then(response => {
      console.log('Response received:');
      console.log('Status:', response.status);
      console.log('Data:', response.data);
      console.log('Promise is fulfilled - request successful!');
    })
    .catch(error => {
      console.log('Error occurred:');
      console.log('Error message:', error.message);
      if (error.response) {
        console.log('Status code:', error.response.status);
      } else if (error.request) {
        console.log('No response received - network error');
      }
      console.log('Promise is rejected - request failed!');
      console.log('You can see the console log for the resolve and reject');
    });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: const axios = require('axios');
        • Imports the axios library
        • Same as in the previous example

Line 2: (empty line)

Line 3: // Making a request with an invalid URL
        • Comment explaining this is an invalid URL example

Line 4: const invalidUrl = 'https://invalid-url-that-does-not-exist.com/api/data';
        • const invalidUrl - Creates a constant with an invalid URL
        • This URL doesn't exist or can't be reached
        • This will cause the request to fail
        • The domain might not exist, or the path might be wrong

Line 5: (empty line)

Line 6: const promise = axios.get(invalidUrl);
        • const promise - Creates a variable to store the Promise
        • axios.get() - Makes a GET HTTP request
        • invalidUrl - The invalid URL to request
        • This also creates a promise object which is pending
        • The HTTP request starts in the background
        • Promise is in pending state while waiting for response (or error)

Line 7: (empty line)

Line 8: promise
         • References the Promise object

Line 9: .then(response => {
         • Attaches a success handler
         • This would execute if the request succeeded
         • With an invalid URL, this typically won't execute

Line 10-13: (Success handler code - same as before)
         • These lines would execute if request succeeded
         • But with invalid URL, they usually won't execute

Line 14: })
         • Closes the .then() handler

Line 15: .catch(error => {
         • Attaches an error handler
         • This promise will be rejected
         • This state is being dealt with in the catch block
         • error - Parameter that receives the error object
         • This handler executes when the request fails

Line 16: console.log('Error occurred:');
         • Logs a message indicating an error occurred
         • This executes when Promise rejects

Line 17: console.log('Error message:', error.message);
         • Logs the error message
         • error.message contains a description of what went wrong
         • Common messages: "Network Error", "getaddrinfo ENOTFOUND", etc.

Line 18: if (error.response) {
         • Checks if error has a response property
         • error.response exists if server responded with an error status
         • This means the request reached the server but got an error response

Line 19: console.log('Status code:', error.response.status);
         • Logs the HTTP status code from error response
         • Examples: 404 (not found), 500 (server error)
         • This only executes if error.response exists

Line 20: } else if (error.request) {
         • Checks if error has a request property
         • error.request exists if request was made but no response received
         • This means network error or server didn't respond

Line 21: console.log('No response received - network error');
         • Logs a message about network error
         • This executes if request was sent but no response received
         • Common with invalid URLs or network issues

Line 22: }
         • Closes the if-else statement

Line 23: console.log('Promise is rejected - request failed!');
         • Logs a failure message
         • Confirms the Promise was rejected
         • You can see the console log for the resolve and reject

Line 24: console.log('You can see the console log for the resolve and reject');
         • Additional message explaining what's happening
         • In this case, we see the reject log, not the resolve log

Line 25: });
         • Closes the .catch() handler

EXPECTED OUTPUT (with invalid URL):
------------------------------------
Error occurred:
Error message: getaddrinfo ENOTFOUND invalid-url-that-does-not-exist.com
No response received - network error
Promise is rejected - request failed!
You can see the console log for the resolve and reject

OR (if URL exists but path is wrong):
-------------------------------------
Error occurred:
Error message: Request failed with status code 404
Status code: 404
Promise is rejected - request failed!
You can see the console log for the resolve and reject

WHAT HAPPENS:
-------------
1. axios.get(invalidUrl) is called
2. Promise is created in pending state
3. HTTP request is sent in the background
4. Code continues (doesn't wait)
5. Request fails (network error, DNS error, or 404/500 response)
6. Promise transitions to rejected state
7. .catch() handler executes with error object
8. Error information is logged to console
9. Failure message is displayed

COMPARING VALID VS INVALID URL:
-------------------------------
VALID URL:
• Promise created → Pending
• Request sent → Still pending
• Response received → Resolved
• .then() executes → Success logged
• .catch() doesn't execute

INVALID URL:
• Promise created → Pending
• Request sent → Still pending
• Request fails → Rejected
• .then() doesn't execute
• .catch() executes → Error logged

You can see the console log for the resolve (valid URL) and reject (invalid URL).

[END SECTION 6.4]
[END PART 6]
================================================================================

PART 7: SUMMARY AND KEY TAKEAWAYS
================================================================================

SECTION 7.1: CONCEPT SUMMARY
-----------------------------

WHAT ARE PROMISES?
------------------
A promise is an object that is returned by an asynchronous method. Promises 
provide a way to handle asynchronous operations in JavaScript and Node.js 
without blocking the main thread.

KEY CONCEPTS
------------
1. PROMISES ARE OBJECTS
   • Promises are JavaScript objects
   • They represent future values
   • They're created by async functions or the Promise constructor

2. THREE STATES
   • Pending: Initial state, operation in progress
   • Resolved/Fulfilled: Operation completed successfully
   • Rejected: Operation failed or encountered an error

3. ASYNCHRONOUS NATURE
   • Promises handle operations that take time
   • They don't block other code from running
   • Results are available when operations complete

4. HANDLING RESULTS
   • .then() handles successful completion
   • .catch() handles errors
   • Both methods return new Promises (enables chaining)

USE CASES
---------
Promises are most useful for:
• Application programming interface (API) requests
• Input/output (I/O) operations
• Time consuming operations that can block resources

[END SECTION 7.1]
================================================================================

SECTION 7.2: KEY DEFINITIONS
-----------------------------

DEFINITION 1: PROMISE OBJECT
----------------------------
A promise is an object returned by an asynchronous method.

DEFINITION 2: PROMISE STATES
----------------------------
The promise has three states, which are pending, resolved, and rejected.

DEFINITION 3: PENDING STATE
---------------------------
The initial state of the promise object is the pending state. It is in this 
state until the operation is complete or some error has caused the operation 
to abort.

DEFINITION 4: RESOLVED STATE
----------------------------
When the operation is complete, the promise is said to be resolved.

DEFINITION 5: REJECTED STATE
----------------------------
When there is an error, the promise is said to be rejected.

DEFINITION 6: CREATING PROMISES
-------------------------------
You can also create a promise object if you know that the operations you are 
going to perform could be blocking.

DEFINITION 7: .THEN() METHOD
----------------------------
The promise object has a "then" method which is called after the promise is 
fulfilled.

DEFINITION 8: .CATCH() METHOD
-----------------------------
The catch is executed if the promise is rejected.

DEFINITION 9: AXIOS PACKAGE
---------------------------
The axios package is one such package to handle HTTP requests. It returns a 
promise object.

DEFINITION 10: HTTP REQUESTS AND BLOCKING
------------------------------------------
You know that hypertext transfer protocol (HTTP) requests when called 
synchronously can be blocking.

DEFINITION 11: PENDING STATUS WITH URLS
----------------------------------------
The status of the promise until it hears back from the uniform resource 
locator (URL) requested is pending.

[END SECTION 7.2]
================================================================================

SECTION 7.3: QUICK REFERENCE GUIDE
-----------------------------------

CREATING A PROMISE
------------------
  const promise = new Promise((resolve, reject) => {
    // Async operation
    if (success) {
      resolve(value);
    } else {
      reject(error);
    }
  });

USING .THEN() AND .CATCH()
--------------------------
  promise
    .then(result => {
      // Handle success
    })
    .catch(error => {
      // Handle error
    });

FILE READING WITH PROMISES
---------------------------
  const fs = require('fs').promises;
  
  fs.readFile('file.txt', 'utf8')
    .then(data => console.log(data))
    .catch(error => console.log(error.message));

HTTP REQUESTS WITH AXIOS
------------------------
  const axios = require('axios');
  
  axios.get('https://api.example.com/data')
    .then(response => console.log(response.data))
    .catch(error => console.log(error.message));

CHAINING PROMISES
-----------------
  promise1
    .then(result1 => promise2(result1))
    .then(result2 => promise3(result2))
    .then(result3 => console.log(result3))
    .catch(error => console.log(error));

[END SECTION 7.3]
================================================================================

SECTION 7.4: BEST PRACTICES
-----------------------------

BEST PRACTICE 1: ALWAYS HANDLE ERRORS
-------------------------------------
Always use .catch() to handle errors:

  promise
    .then(result => {
      // Handle success
    })
    .catch(error => {
      // Always handle errors
      console.error('Error:', error);
    });

BEST PRACTICE 2: RETURN VALUES IN .THEN()
------------------------------------------
Return values or Promises in .then() to enable chaining:

  promise
    .then(result => {
      return processResult(result); // Return for next .then()
    })
    .then(processed => {
      // Use processed result
    });

BEST PRACTICE 3: USE ERROR OBJECTS
-----------------------------------
Always reject with Error objects, not strings:

  // Good
  reject(new Error('Something went wrong'));
  
  // Avoid
  reject('Something went wrong');

BEST PRACTICE 4: HANDLE BOTH SUCCESS AND ERROR
-----------------------------------------------
Use both .then() and .catch() for complete handling:

  promise
    .then(result => {
      // Success case
    })
    .catch(error => {
      // Error case
    });

BEST PRACTICE 5: CREATE PROMISES FOR BLOCKING OPERATIONS
---------------------------------------------------------
Create Promises when operations could block:

  function blockingOperation() {
    return new Promise((resolve, reject) => {
      // Blocking operation here
    });
  }

BEST PRACTICE 6: USE PROMISES FOR ASYNC OPERATIONS
--------------------------------------------------
Use Promises for:
• API requests
• File I/O operations
• Database queries
• Network operations
• Any time-consuming operations

BEST PRACTICE 7: AVOID CALLBACK HELL
-------------------------------------
Use Promises instead of nested callbacks:

  // Avoid (callback hell)
  operation1(function(result1) {
    operation2(result1, function(result2) {
      operation3(result2, function(result3) {
        // Deep nesting
      });
    });
  });
  
  // Prefer (Promises)
  operation1()
    .then(result1 => operation2(result1))
    .then(result2 => operation3(result2))
    .then(result3 => {
      // Clean and readable
    });

[END SECTION 7.4]
[END PART 7]
================================================================================

FINAL NOTES
-----------
This comprehensive study guide has expanded on the original content while 
maintaining all original definitions and information. Each concept has been 
explained in detail with line-by-line code explanations to ensure thorough 
understanding.

Remember:
• A promise is an object returned by an asynchronous method
• Promises have three states: pending, resolved, and rejected
• The initial state of a promise is pending
• Use .then() to handle resolved promises
• Use .catch() to handle rejected promises
• The axios package is used in Node.js to handle HTTP requests
• You can create a promise if you know that operations could be blocking
• Promises are most useful for API requests, I/O operations, and 
  time-consuming operations

You now have a comprehensive understanding of JavaScript Promises. These 
concepts are fundamental to building modern JavaScript and Node.js applications.

Good luck with your Promises journey!

================================================================================
END OF PART 2
================================================================================

