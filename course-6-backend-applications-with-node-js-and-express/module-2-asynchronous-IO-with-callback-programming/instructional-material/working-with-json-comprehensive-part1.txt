================================================================================
WORKING WITH JSON
Comprehensive Study Guide - Part 1
================================================================================

WELCOME
-------
Welcome to Working with JSON. This comprehensive guide will teach you everything 
you need to know about JavaScript Object Notation (JSON), from the basics to 
real-world applications with Node.js and HTTP messages.

ESTIMATED TIME NEEDED
---------------------
5 minutes (for basic reading)
60-90 minutes (for comprehensive study with practice)

LEARNING OBJECTIVES
-------------------
After studying this guide, you will be able to:
• Define JavaScript Object Notation (JSON) and understand its purpose
• Explain why JSON is the standard format for API data exchange
• Understand how JSON represents native JavaScript objects
• Parse JSON data from HTTP messages using JSON.parse()
• Convert JavaScript objects to JSON strings using JSON.stringify()
• Work with JSON in Node.js applications
• Use JSON with real-world API endpoints
• Understand JSON structure and syntax rules
• Handle common JSON operations and patterns

OVERVIEW
--------
JSON (JavaScript Object Notation) is the standard format for application 
programming interface (API) data exchange. It is the standard representation 
of native JavaScript objects, and Node.js handles it easily. JSON provides a 
lightweight, human-readable way to structure data that can be easily 
transmitted between systems and parsed by programming languages.

In this guide, you will learn:
• What JSON is and why it's important
• How JSON structures data using attribute-value pairs
• How to parse JSON strings into JavaScript objects using JSON.parse()
• How to convert JavaScript objects into JSON strings using JSON.stringify()
• How to work with JSON in real-world scenarios, including HTTP messages
• Practical examples using real API endpoints

================================================================================
TABLE OF CONTENTS - PART 1
================================================================================

This part covers the fundamentals of JSON:

PART 1: INTRODUCTION TO JSON
  SECTION 1.1: WHAT IS JSON?
  SECTION 1.2: WHY IS JSON IMPORTANT?
  SECTION 1.3: JSON STRUCTURE AND SYNTAX
  SECTION 1.4: JSON VS JAVASCRIPT OBJECTS

PART 2: PARSING JSON DATA
  SECTION 2.1: UNDERSTANDING JSON.PARSE()
  SECTION 2.2: PARSING JSON FROM STRINGS
  SECTION 2.3: HANDLING PARSING ERRORS
  SECTION 2.4: PARSING JSON FROM HTTP MESSAGES

PART 3: CONVERTING TO JSON
  SECTION 3.1: UNDERSTANDING JSON.STRINGIFY()
  SECTION 3.2: CONVERTING JAVASCRIPT OBJECTS TO JSON
  SECTION 3.3: JSON.STRINGIFY() OPTIONS AND PARAMETERS
  SECTION 3.4: WHAT GETS STRINGIFIED AND WHAT DOESN'T

NOTE: Part 2 of this guide covers:
  • Real-world API examples with detailed code explanations
  • Working with HTTP requests and responses
  • Complete Node.js examples with line-by-line explanations
  • Summary, key definitions, quick reference guide, and best practices

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 1.3:") to quickly jump to any section.

================================================================================
PART 1: INTRODUCTION TO JSON
================================================================================

SECTION 1.1: WHAT IS JSON?
--------------------------

DEFINITION
----------
JSON stands for JavaScript Object Notation. It is a lightweight data 
interchange format that is easy for humans to read and write, and easy for 
machines to parse and generate. JSON is the standard format for application 
programming interface (API) data exchange.

DETAILED EXPLANATION
--------------------
JSON is a text-based data format that uses a syntax similar to JavaScript 
object literals. However, JSON is language-independent, meaning it can be 
used with any programming language, not just JavaScript. JSON was derived 
from JavaScript, but many modern programming languages include code to parse 
and generate JSON data.

KEY CHARACTERISTICS OF JSON:
• Text-based format (stored as strings)
• Human-readable (you can read and understand it)
• Language-independent (works with any programming language)
• Lightweight (small file sizes, fast to transmit)
• Self-describing (the structure tells you what the data represents)
• Standard format for API communication

REAL-WORLD ANALOGY
------------------
Think of JSON like a universal language for data. Just like how people from 
different countries might use English as a common language to communicate, 
different computer systems (web servers, mobile apps, databases) use JSON as 
a common format to exchange data. It's like a standardized form that everyone 
agrees to use, making it easy for different systems to understand each other.

WHY JSON IS POPULAR
-------------------
1. SIMPLICITY
   • Easy to read and write
   • Simple syntax rules
   • No complex formatting requirements

2. UNIVERSAL SUPPORT
   • Supported by virtually all modern programming languages
   • Built into JavaScript/Node.js (no installation needed)
   • Standard format recognized worldwide

3. EFFICIENCY
   • Compact format (smaller than XML)
   • Fast to parse and generate
   • Minimal overhead

4. WEB-NATIVE
   • Perfect for web APIs
   • Works seamlessly with HTTP
   • Native support in browsers and Node.js

[END SECTION 1.1]
================================================================================

SECTION 1.2: WHY IS JSON IMPORTANT?
------------------------------------

THE ROLE OF JSON IN MODERN DEVELOPMENT
---------------------------------------
JSON is the standard format for application programming interface (API) data 
exchange. This means that when different applications, services, or systems 
need to communicate with each other, they most commonly use JSON to format 
the data being exchanged.

WHY JSON BECAME THE STANDARD
-----------------------------
Before JSON became popular, developers used formats like XML (Extensible 
Markup Language) for data exchange. However, XML had several disadvantages:
• More verbose (required more characters)
• Harder to read
• More complex to parse
• Required more bandwidth

JSON solved these problems by providing:
• A simpler, more readable format
• Easier parsing (especially in JavaScript)
• Smaller file sizes
• Native JavaScript support

JSON IN THE WEB ECOSYSTEM
--------------------------
1. API COMMUNICATION
   • REST APIs use JSON for request and response bodies
   • GraphQL APIs use JSON for responses
   • Webhooks send data in JSON format
   • Microservices communicate using JSON

2. CONFIGURATION FILES
   • package.json (Node.js project configuration)
   • tsconfig.json (TypeScript configuration)
   • .eslintrc.json (ESLint configuration)
   • Many other configuration files use JSON

3. DATA STORAGE
   • NoSQL databases like MongoDB store data in JSON-like format
   • JSON files are used for simple data storage
   • Local storage in browsers uses JSON

4. FRONTEND-BACKEND COMMUNICATION
   • Frontend applications send JSON to backend servers
   • Backend servers respond with JSON data
   • Real-time applications exchange JSON messages

REAL-WORLD EXAMPLES
-------------------
• When you use a weather app, it requests weather data from an API, which 
  returns JSON with temperature, humidity, and forecast information.

• When you shop online, the website sends your cart items as JSON to the 
  server, and receives product information back as JSON.

• When you use social media, posts, comments, and user data are all 
  transmitted as JSON between the app and the server.

• When you use a mobile app, it communicates with backend services using 
  JSON to send and receive data.

[END SECTION 1.2]
================================================================================

SECTION 1.3: JSON STRUCTURE AND SYNTAX
---------------------------------------

BASIC JSON STRUCTURE
--------------------
JSON structures data using attribute-value pairs. An attribute (also called 
a "key" or "property") is a name that identifies the data, and a value is 
the actual data associated with that attribute.

UNDERSTANDING ATTRIBUTE-VALUE PAIRS
------------------------------------
In JSON, data is organized as pairs where:
• The attribute (key) is always a string (enclosed in double quotes)
• The value can be a string, number, boolean, null, array, or another object
• Attribute and value are separated by a colon (:)
• Multiple pairs are separated by commas (,)
• The entire structure is enclosed in curly braces { }

BASIC EXAMPLE
-------------
Let's look at a simple JSON example:

{
  "Company": "IBM",
  "Country": "USA",
  "Headquarters": "Armonk, New York"
}

BREAKDOWN OF THIS EXAMPLE:
--------------------------
This JSON object consists of three attribute-value pairs:

1. FIRST ATTRIBUTE-VALUE PAIR:
   • Attribute: "Company"
   • Value: "IBM"
   • This tells us the company name is IBM

2. SECOND ATTRIBUTE-VALUE PAIR:
   • Attribute: "Country"
   • Value: "USA"
   • This tells us the country is USA

3. THIRD ATTRIBUTE-VALUE PAIR:
   • Attribute: "Headquarters"
   • Value: "Armonk, New York"
   • This tells us the headquarters location is Armonk, New York

DETAILED SYNTAX RULES
---------------------
1. KEYS MUST BE STRINGS
   • Keys must always be enclosed in double quotes
   • Single quotes are NOT allowed
   • Keys cannot be unquoted (unlike JavaScript object literals)

   CORRECT:
   {
     "name": "John",
     "age": 30
   }

   INCORRECT:
   {
     name: "John",        // Error: keys must be quoted
     'age': 30            // Error: must use double quotes
   }

2. VALUES CAN BE DIFFERENT TYPES
   • Strings: "Hello World" (must use double quotes)
   • Numbers: 42, 3.14, -10
   • Booleans: true, false
   • Null: null
   • Arrays: [1, 2, 3] or ["a", "b", "c"]
   • Objects: { "key": "value" }

3. COMMAS SEPARATE ITEMS
   • Use commas to separate multiple attribute-value pairs
   • No trailing comma after the last item

   CORRECT:
   {
     "name": "John",
     "age": 30
   }

   INCORRECT:
   {
     "name": "John",
     "age": 30,           // Error: trailing comma
   }

4. CURLY BRACES FOR OBJECTS
   • Objects are enclosed in { }
   • Square brackets [ ] are used for arrays

5. WHITESPACE IS OPTIONAL
   • JSON can be minified (no spaces) or formatted (with spaces)
   • Both are valid JSON

   MINIFIED (valid):
   {"name":"John","age":30}

   FORMATTED (valid):
   {
     "name": "John",
     "age": 30
   }

MORE COMPLEX EXAMPLES
---------------------

EXAMPLE 1: JSON WITH DIFFERENT VALUE TYPES
-------------------------------------------
{
  "name": "John Doe",           // String
  "age": 30,                    // Number
  "isActive": true,              // Boolean
  "salary": null,                // Null
  "hobbies": ["reading", "coding", "music"],  // Array
  "address": {                   // Nested object
    "street": "123 Main St",
    "city": "New York"
  }
}

EXAMPLE 2: JSON WITH ARRAYS OF OBJECTS
---------------------------------------
{
  "employees": [
    {
      "name": "Alice",
      "department": "Engineering"
    },
    {
      "name": "Bob",
      "department": "Marketing"
    }
  ]
}

EXAMPLE 3: NESTED JSON STRUCTURES
----------------------------------
{
  "company": {
    "name": "IBM",
    "location": {
      "country": "USA",
      "city": "Armonk",
      "state": "New York"
    },
    "departments": [
      {
        "name": "Engineering",
        "employees": 500
      },
      {
        "name": "Sales",
        "employees": 200
      }
    ]
  }
}

COMMON JSON MISTAKES TO AVOID
------------------------------
1. USING SINGLE QUOTES
   ❌ { 'name': 'John' }
   ✅ { "name": "John" }

2. TRAILING COMMAS
   ❌ { "name": "John", "age": 30, }
   ✅ { "name": "John", "age": 30 }

3. UNQUOTED KEYS
   ❌ { name: "John" }
   ✅ { "name": "John" }

4. COMMENTS (JSON doesn't support comments)
   ❌ { "name": "John" /* comment */ }
   ✅ { "name": "John" }

5. UNDEFINED VALUES (use null instead)
   ❌ { "name": "John", "age": undefined }
   ✅ { "name": "John", "age": null }

[END SECTION 1.3]
================================================================================

SECTION 1.4: JSON VS JAVASCRIPT OBJECTS
----------------------------------------

THE RELATIONSHIP BETWEEN JSON AND JAVASCRIPT
---------------------------------------------
JSON is the standard representation of native JavaScript objects. This means 
that JSON syntax is very similar to JavaScript object literal syntax, and 
JavaScript objects can be easily converted to JSON and vice versa.

SIMILARITIES
------------
1. Both use curly braces { } for objects
2. Both use square brackets [ ] for arrays
3. Both use colons : to separate keys and values
4. Both use commas , to separate items
5. Both support nested structures

KEY DIFFERENCES
---------------
1. QUOTES ON KEYS
   • JSON: Keys MUST be in double quotes
   • JavaScript: Keys can be unquoted (if they're valid identifiers) or quoted

   JSON:
   { "name": "John" }

   JavaScript (both valid):
   { "name": "John" }      // Quoted key
   { name: "John" }        // Unquoted key (valid in JS, not in JSON)

2. COMMENTS
   • JSON: Does NOT support comments
   • JavaScript: Supports comments (// and /* */)

   JSON:
   { "name": "John" }      // No comments allowed

   JavaScript:
   { "name": "John" }      // Comments are allowed

3. TRAILING COMMAS
   • JSON: Does NOT allow trailing commas
   • JavaScript: Allows trailing commas (in modern versions)

   JSON:
   { "name": "John" }      // No trailing comma

   JavaScript:
   { "name": "John", }     // Trailing comma allowed

4. VALUE TYPES
   • JSON: Only supports string, number, boolean, null, array, object
   • JavaScript: Supports functions, undefined, Date objects, etc.

   JSON:
   { "date": "2024-01-01" }    // Dates must be strings

   JavaScript:
   { date: new Date() }        // Can use Date objects

5. UNDEFINED
   • JSON: Does NOT support undefined
   • JavaScript: Supports undefined (use null in JSON instead)

WHY THESE DIFFERENCES MATTER
-----------------------------
These differences exist because JSON needs to be:
• Language-independent (work with any programming language)
• Simple to parse (no complex features)
• Safe to transmit (no executable code like functions)

CONVERTING BETWEEN JSON AND JAVASCRIPT OBJECTS
-----------------------------------------------
Since JSON is the standard representation of native JavaScript objects, 
Node.js provides built-in methods to convert between them:

1. JavaScript Object → JSON String
   Use JSON.stringify()

2. JSON String → JavaScript Object
   Use JSON.parse()

We'll cover these methods in detail in the next sections.

[END SECTION 1.4]
================================================================================

PART 2: PARSING JSON DATA
================================================================================

SECTION 2.1: UNDERSTANDING JSON.PARSE()
----------------------------------------

DEFINITION
----------
JSON.parse() is a built-in JavaScript method that parses a JSON string and 
converts it into a JavaScript object. To parse a JSON string to a JavaScript 
object, use method JSON.parse.

DETAILED EXPLANATION
--------------------
When you receive JSON data (usually as a string from an HTTP request, a file, 
or an API), you need to convert it from a string format into a JavaScript 
object so you can work with it in your code. JSON.parse() does exactly that.

HOW JSON.PARSE() WORKS
----------------------
1. Takes a JSON string as input
2. Validates that the string is valid JSON
3. Converts the string into a JavaScript object
4. Returns the JavaScript object

BASIC SYNTAX
------------
let javascriptObject = JSON.parse(jsonString);

PARAMETERS
----------
• jsonString (required): A string containing valid JSON

RETURN VALUE
------------
• Returns a JavaScript object (or array, or primitive value) representing 
  the parsed JSON

SIMPLE EXAMPLE
--------------
Let's start with a basic example:

// Step 1: We have a JSON string (this is what you might receive from an API)
let jsonString = '{"name": "John", "age": 30}';

// Step 2: Parse it into a JavaScript object
let person = JSON.parse(jsonString);

// Step 3: Now we can use it as a regular JavaScript object
console.log(person.name);  // Output: "John"
console.log(person.age);   // Output: 30

LINE-BY-LINE EXPLANATION
-------------------------
Line 1: let jsonString = '{"name": "John", "age": 30}';
        • We create a variable called jsonString
        • We assign it a string value (notice the single quotes)
        • The string contains JSON data (notice the double quotes inside)
        • This simulates receiving JSON data as a string

Line 2: let person = JSON.parse(jsonString);
        • We call JSON.parse() and pass the jsonString as an argument
        • JSON.parse() reads the string and converts it to a JavaScript object
        • We store the result in a variable called person
        • Now person is a JavaScript object, not a string

Line 3: console.log(person.name);
        • We access the name property of the person object
        • This works because person is now a JavaScript object
        • Output: "John"

Line 4: console.log(person.age);
        • We access the age property of the person object
        • Output: 30

WHAT HAPPENS UNDER THE HOOD
---------------------------
When JSON.parse() processes the string '{"name": "John", "age": 30}':

1. It reads the string character by character
2. It recognizes { as the start of an object
3. It finds "name" as a key and "John" as its value
4. It finds "age" as a key and 30 as its value
5. It recognizes } as the end of the object
6. It creates a JavaScript object with these properties
7. It returns the object

MORE EXAMPLES
-------------

EXAMPLE 1: PARSING AN ARRAY
----------------------------
let jsonArrayString = '["apple", "banana", "orange"]';
let fruits = JSON.parse(jsonArrayString);

console.log(fruits);        // Output: ["apple", "banana", "orange"]
console.log(fruits[0]);     // Output: "apple"
console.log(fruits.length); // Output: 3

EXPLANATION:
• jsonArrayString contains a JSON array as a string
• JSON.parse() converts it to a JavaScript array
• We can then use array methods and access elements by index

EXAMPLE 2: PARSING NESTED OBJECTS
----------------------------------
let jsonString = '{"company": {"name": "IBM", "country": "USA"}}';
let data = JSON.parse(jsonString);

console.log(data.company.name);    // Output: "IBM"
console.log(data.company.country); // Output: "USA"

EXPLANATION:
• The JSON string contains a nested object (company object inside the main object)
• JSON.parse() preserves the nested structure
• We can access nested properties using dot notation

EXAMPLE 3: PARSING WITH DIFFERENT DATA TYPES
---------------------------------------------
let jsonString = '{"name": "John", "age": 30, "isActive": true, "salary": null}';
let person = JSON.parse(jsonString);

console.log(typeof person.name);     // Output: "string"
console.log(typeof person.age);      // Output: "number"
console.log(typeof person.isActive); // Output: "boolean"
console.log(person.salary);          // Output: null

EXPLANATION:
• JSON.parse() correctly converts JSON types to JavaScript types
• Strings remain strings
• Numbers become JavaScript numbers
• Booleans become JavaScript booleans
• null becomes JavaScript null

[END SECTION 2.1]
================================================================================

SECTION 2.2: PARSING JSON FROM STRINGS
---------------------------------------

COMMON SCENARIOS WHERE YOU PARSE JSON
--------------------------------------
1. Receiving data from an API (HTTP response)
2. Reading JSON from a file
3. Receiving data from a database
4. Getting data from user input (form submissions)
5. Receiving data from WebSocket messages

DETAILED EXAMPLE: PARSING A COMPLETE JSON OBJECT
-------------------------------------------------
Let's use the example from the original material - the IBM company information:

// This is the JSON string we receive (as a string)
let jsonString = `{
  "Company": "IBM",
  "Country": "USA",
  "Headquarters": "Armonk, New York"
}`;

// Parse it into a JavaScript object
let company = JSON.parse(jsonString);

// Now we can access the data
console.log(company.Company);        // Output: "IBM"
console.log(company.Country);       // Output: "USA"
console.log(company.Headquarters);  // Output: "Armonk, New York"

LINE-BY-LINE EXPLANATION
-------------------------
Line 1-5: let jsonString = `{...}`;
          • We create a JSON string using a template literal (backticks)
          • The string contains three attribute-value pairs:
            - "Company": "IBM"
            - "Country": "USA"
            - "Headquarters": "Armonk, New York"
          • This simulates receiving JSON data as a string

Line 7: let company = JSON.parse(jsonString);
        • We call JSON.parse() with the jsonString
        • JSON.parse() converts the string into a JavaScript object
        • The object has three properties: Company, Country, Headquarters
        • We store this object in the company variable

Line 10: console.log(company.Company);
         • We access the Company property using dot notation
         • Output: "IBM"

Line 11: console.log(company.Country);
         • We access the Country property
         • Output: "USA"

Line 12: console.log(company.Headquarters);
         • We access the Headquarters property
         • Output: "Armonk, New York"

WORKING WITH THE PARSED OBJECT
-------------------------------
Once you've parsed JSON into a JavaScript object, you can:

1. ACCESS PROPERTIES
   console.log(company.Company);

2. MODIFY PROPERTIES
   company.Company = "International Business Machines";
   console.log(company.Company); // Output: "International Business Machines"

3. ADD NEW PROPERTIES
   company.Founded = 1911;
   console.log(company.Founded); // Output: 1911

4. DELETE PROPERTIES
   delete company.Country;
   console.log(company.Country); // Output: undefined

5. ITERATE OVER PROPERTIES
   for (let key in company) {
     console.log(key + ": " + company[key]);
   }

EXAMPLE: PARSING JSON FROM A VARIABLE
--------------------------------------
// JSON data stored in a variable as a string
let userDataString = '{"username": "johndoe", "email": "john@example.com", "age": 28}';

// Parse it
let userData = JSON.parse(userDataString);

// Use the data
console.log("Username: " + userData.username);
console.log("Email: " + userData.email);
console.log("Age: " + userData.age);

OUTPUT:
Username: johndoe
Email: john@example.com
Age: 28

EXAMPLE: PARSING JSON ARRAYS
-----------------------------
let productsString = '[
  {"id": 1, "name": "Laptop", "price": 999},
  {"id": 2, "name": "Mouse", "price": 25},
  {"id": 3, "name": "Keyboard", "price": 75}
]';

let products = JSON.parse(productsString);

// Access array elements
console.log(products[0].name);  // Output: "Laptop"
console.log(products[1].price); // Output: 25

// Iterate over the array
products.forEach(product => {
  console.log(product.name + ": $" + product.price);
});

OUTPUT:
Laptop: $999
Mouse: $25
Keyboard: $75

[END SECTION 2.2]
================================================================================

SECTION 2.3: HANDLING PARSING ERRORS
-------------------------------------

WHAT HAPPENS WHEN JSON IS INVALID?
-----------------------------------
If you try to parse an invalid JSON string, JSON.parse() will throw an error. 
This is important to handle because:
• API responses might be malformed
• User input might be invalid
• Files might be corrupted
• Network issues might cause incomplete data

BASIC ERROR HANDLING
--------------------
Use try-catch to handle parsing errors:

try {
  let jsonString = '{"name": "John"}';
  let data = JSON.parse(jsonString);
  console.log(data);
} catch (error) {
  console.error("Error parsing JSON:", error.message);
}

COMMON JSON PARSING ERRORS
--------------------------

ERROR 1: UNEXPECTED TOKEN
-------------------------
let invalidJson = "{name: 'John'}";  // Missing quotes around key

try {
  let data = JSON.parse(invalidJson);
} catch (error) {
  console.error(error.message);
  // Output: "Expected property name or '}' in JSON at position 1"
}

SOLUTION: Ensure all keys are in double quotes
let validJson = '{"name": "John"}';

ERROR 2: TRAILING COMMA
------------------------
let invalidJson = '{"name": "John", "age": 30,}';  // Trailing comma

try {
  let data = JSON.parse(invalidJson);
} catch (error) {
  console.error(error.message);
  // Output: "Unexpected token } in JSON at position 25"
}

SOLUTION: Remove trailing commas
let validJson = '{"name": "John", "age": 30}';

ERROR 3: SINGLE QUOTES
----------------------
let invalidJson = "{'name': 'John'}";  // Single quotes

try {
  let data = JSON.parse(invalidJson);
} catch (error) {
  console.error(error.message);
  // Output: "Unexpected token ' in JSON at position 1"
}

SOLUTION: Use double quotes
let validJson = '{"name": "John"}';

ERROR 4: UNDEFINED VALUES
--------------------------
let invalidJson = '{"name": "John", "age": undefined}';

try {
  let data = JSON.parse(invalidJson);
} catch (error) {
  console.error(error.message);
  // Output: "Unexpected token u in JSON at position 20"
}

SOLUTION: Use null instead of undefined
let validJson = '{"name": "John", "age": null}';

PRACTICAL ERROR HANDLING FUNCTION
----------------------------------
function safeParseJSON(jsonString) {
  try {
    return JSON.parse(jsonString);
  } catch (error) {
    console.error("Failed to parse JSON:", error.message);
    return null;  // or return a default value
  }
}

// Usage
let data = safeParseJSON('{"name": "John"}');
if (data) {
  console.log(data.name);
} else {
  console.log("Invalid JSON data");
}

[END SECTION 2.3]
================================================================================

SECTION 2.4: PARSING JSON FROM HTTP MESSAGES
---------------------------------------------

UNDERSTANDING HTTP MESSAGES AND JSON
-------------------------------------
JSON is commonly used in HTTP messages. When you make an HTTP request to an 
API, the response body often contains JSON data. You need to parse this JSON 
string to convert it into a JavaScript object that you can use in your code.

HTTP MESSAGE STRUCTURE
----------------------
An HTTP message consists of:
1. Headers (metadata about the message)
2. Body (the actual data, often in JSON format)

When you receive an HTTP response, the body is typically a string. If that 
string contains JSON, you need to parse it.

PARSING JSON FROM HTTP RESPONSES IN NODE.JS
-------------------------------------------
In Node.js, when you receive data from an HTTP request, it comes as a string. 
You need to parse it to convert it to a JavaScript object.

EXAMPLE: USING THE HTTP MODULE
-------------------------------
const http = require('http');

// Make an HTTP request
http.get('http://api.example.com/data', (response) => {
  let data = '';
  
  // Collect the response data (it comes in chunks)
  response.on('data', (chunk) => {
    data += chunk;
  });
  
  // When all data is received
  response.on('end', () => {
    // Parse the JSON string into a JavaScript object
    let jsonData = JSON.parse(data);
    
    // Now you can use the data
    console.log(jsonData);
  });
});

LINE-BY-LINE EXPLANATION
-------------------------
Line 1: const http = require('http');
        • We import Node.js's built-in http module
        • This module allows us to make HTTP requests

Line 3: http.get('http://api.example.com/data', (response) => { ... });
        • We make a GET request to the API endpoint
        • http.get() is a method that makes HTTP GET requests
        • The second parameter is a callback function that receives the response

Line 4: let data = '';
        • We create an empty string to accumulate the response data
        • HTTP responses can come in multiple chunks, so we need to collect them

Line 6-8: response.on('data', (chunk) => { data += chunk; });
          • We listen for 'data' events
          • Each time a chunk of data arrives, we add it to our data string
          • This continues until all data is received

Line 11: response.on('end', () => { ... });
         • We listen for the 'end' event
         • This fires when all data has been received

Line 13: let jsonData = JSON.parse(data);
         • We parse the accumulated data string
         • data is a JSON string, so we use JSON.parse() to convert it
         • The result is stored in jsonData as a JavaScript object

Line 16: console.log(jsonData);
         • We can now use jsonData as a regular JavaScript object

EXAMPLE: USING FETCH (MODERN APPROACH)
---------------------------------------
If you're using a modern Node.js version (18+) or a library like node-fetch:

const fetch = require('node-fetch');

fetch('http://api.example.com/data')
  .then(response => response.json())  // Automatically parses JSON
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error('Error:', error);
  });

EXPLANATION:
• fetch() makes an HTTP request
• response.json() automatically parses the JSON response
• The parsed data is available in the next .then()

WHY PARSING IS NECESSARY
-------------------------
HTTP responses are always strings. Even if the content is JSON, it arrives as 
a text string. You must parse it to convert it into a JavaScript object:

// What you receive from HTTP (a string):
'{"name": "John", "age": 30}'

// What you need (a JavaScript object):
{ name: "John", age: 30 }

// How to convert:
let object = JSON.parse('{"name": "John", "age": 30}');

[END SECTION 2.4]
================================================================================

PART 3: CONVERTING TO JSON
================================================================================

SECTION 3.1: UNDERSTANDING JSON.STRINGIFY()
--------------------------------------------

DEFINITION
----------
JSON.stringify() is a built-in JavaScript method that converts a JavaScript 
object (or value) into a JSON string. Method JSON.stringify() converts a 
JavaScript object to a JSON string.

DETAILED EXPLANATION
--------------------
When you need to send data to a server, store it in a file, or transmit it 
over a network, you often need to convert your JavaScript object into a JSON 
string. JSON.stringify() does exactly that - it takes a JavaScript object and 
converts it into a JSON-formatted string.

HOW JSON.STRINGIFY() WORKS
---------------------------
1. Takes a JavaScript object (or value) as input
2. Converts it to a JSON-formatted string
3. Returns the JSON string

BASIC SYNTAX
------------
let jsonString = JSON.stringify(javascriptObject);

PARAMETERS
----------
• value (required): The JavaScript value to convert to JSON
• replacer (optional): A function or array to transform the result
• space (optional): A string or number for indentation

RETURN VALUE
------------
• Returns a JSON string representing the JavaScript object

SIMPLE EXAMPLE
--------------
Let's start with a basic example:

// Step 1: We have a JavaScript object
let person = {
  name: "John",
  age: 30
};

// Step 2: Convert it to a JSON string
let jsonString = JSON.stringify(person);

// Step 3: Now we have a JSON string
console.log(jsonString);
// Output: '{"name":"John","age":30}'

LINE-BY-LINE EXPLANATION
-------------------------
Line 1-4: let person = { name: "John", age: 30 };
          • We create a JavaScript object called person
          • It has two properties: name and age
          • This is a regular JavaScript object (not a string)

Line 6: let jsonString = JSON.stringify(person);
        • We call JSON.stringify() and pass the person object
        • JSON.stringify() converts the object into a JSON string
        • The result is stored in jsonString
        • Now jsonString is a string, not an object

Line 9: console.log(jsonString);
        • We print the JSON string
        • Output: '{"name":"John","age":30}'
        • Notice it's a string with double-quoted keys

WHAT HAPPENS UNDER THE HOOD
---------------------------
When JSON.stringify() processes the object { name: "John", age: 30 }:

1. It examines each property of the object
2. It converts the key "name" to a JSON key (adds quotes if needed)
3. It converts the value "John" to a JSON string value
4. It converts the key "age" to a JSON key
5. It converts the value 30 to a JSON number
6. It formats everything according to JSON syntax rules
7. It returns the complete JSON string

MORE EXAMPLES
-------------

EXAMPLE 1: STRINGIFYING DIFFERENT DATA TYPES
---------------------------------------------
let data = {
  name: "John",        // String
  age: 30,             // Number
  isActive: true,      // Boolean
  salary: null,        // Null
  hobbies: ["reading", "coding"],  // Array
  address: {           // Nested object
    city: "New York"
  }
};

let jsonString = JSON.stringify(data);
console.log(jsonString);

OUTPUT:
'{"name":"John","age":30,"isActive":true,"salary":null,"hobbies":["reading","coding"],"address":{"city":"New York"}}'

EXAMPLE 2: STRINGIFYING ARRAYS
-------------------------------
let fruits = ["apple", "banana", "orange"];
let jsonString = JSON.stringify(fruits);

console.log(jsonString);
// Output: '["apple","banana","orange"]'

EXAMPLE 3: STRINGIFYING PRIMITIVE VALUES
-----------------------------------------
console.log(JSON.stringify("Hello"));     // Output: '"Hello"'
console.log(JSON.stringify(42));          // Output: '42'
console.log(JSON.stringify(true));        // Output: 'true'
console.log(JSON.stringify(null));       // Output: 'null'

[END SECTION 3.1]
================================================================================

SECTION 3.2: CONVERTING JAVASCRIPT OBJECTS TO JSON
---------------------------------------------------

WHY CONVERT OBJECTS TO JSON STRINGS?
-------------------------------------
1. SENDING DATA TO SERVERS
   • HTTP requests require strings in the request body
   • APIs expect JSON strings, not JavaScript objects

2. STORING DATA
   • LocalStorage only stores strings
   • Files are written as strings
   • Databases often require string format

3. TRANSMITTING DATA
   • Network protocols transmit strings
   • WebSocket messages are strings
   • Inter-process communication uses strings

DETAILED EXAMPLE: CONVERTING A COMPLETE OBJECT
-----------------------------------------------
Let's convert the IBM company object to JSON:

// Step 1: Create a JavaScript object
let company = {
  Company: "IBM",
  Country: "USA",
  Headquarters: "Armonk, New York"
};

// Step 2: Convert to JSON string
let jsonString = JSON.stringify(company);

// Step 3: The result is a JSON string
console.log(jsonString);
// Output: '{"Company":"IBM","Country":"USA","Headquarters":"Armonk, New York"}'

LINE-BY-LINE EXPLANATION
-------------------------
Line 1-5: let company = { Company: "IBM", Country: "USA", Headquarters: "Armonk, New York" };
          • We create a JavaScript object with three properties
          • Company: "IBM"
          • Country: "USA"
          • Headquarters: "Armonk, New York"
          • This is a regular JavaScript object

Line 7: let jsonString = JSON.stringify(company);
        • We call JSON.stringify() with the company object
        • The method converts the object to a JSON string
        • Keys are automatically quoted (Company becomes "Company")
        • Values are properly formatted
        • The result is stored in jsonString

Line 10: console.log(jsonString);
         • We print the JSON string
         • Output: '{"Company":"IBM","Country":"USA","Headquarters":"Armonk, New York"}'
         • Notice it's now a string (you can see the quotes)

USING THE JSON STRING
---------------------
Once you have a JSON string, you can:

1. SEND IT IN AN HTTP REQUEST
   const http = require('http');
   
   let data = { name: "John", age: 30 };
   let jsonString = JSON.stringify(data);
   
   // Send in HTTP request body
   // (jsonString would be sent as the request body)

2. STORE IT IN LOCALSTORAGE (Browser)
   let data = { name: "John", age: 30 };
   let jsonString = JSON.stringify(data);
   localStorage.setItem('userData', jsonString);

3. WRITE IT TO A FILE
   const fs = require('fs');
   
   let data = { name: "John", age: 30 };
   let jsonString = JSON.stringify(data);
   fs.writeFileSync('data.json', jsonString);

EXAMPLE: CONVERTING NESTED OBJECTS
-----------------------------------
let company = {
  name: "IBM",
  location: {
    country: "USA",
    city: "Armonk",
    state: "New York"
  },
  employees: 350000
};

let jsonString = JSON.stringify(company);
console.log(jsonString);

OUTPUT:
'{"name":"IBM","location":{"country":"USA","city":"Armonk","state":"New York"},"employees":350000}'

EXAMPLE: CONVERTING ARRAYS OF OBJECTS
-------------------------------------
let employees = [
  { name: "Alice", department: "Engineering" },
  { name: "Bob", department: "Marketing" }
];

let jsonString = JSON.stringify(employees);
console.log(jsonString);

OUTPUT:
'[{"name":"Alice","department":"Engineering"},{"name":"Bob","department":"Marketing"}]'

[END SECTION 3.2]
================================================================================

SECTION 3.3: JSON.STRINGIFY() OPTIONS AND PARAMETERS
-----------------------------------------------------

FORMATTING JSON OUTPUT
-----------------------
JSON.stringify() can take additional parameters to format the output for 
better readability.

BASIC SYNTAX WITH FORMATTING
------------------------------
JSON.stringify(value, replacer, space)

THE SPACE PARAMETER
-------------------
The third parameter (space) controls indentation:

// Without formatting (default)
let data = { name: "John", age: 30 };
console.log(JSON.stringify(data));
// Output: '{"name":"John","age":30}'

// With 2-space indentation
console.log(JSON.stringify(data, null, 2));
// Output:
// {
//   "name": "John",
//   "age": 30
// }

// With 4-space indentation
console.log(JSON.stringify(data, null, 4));
// Output:
// {
//     "name": "John",
//     "age": 30
// }

// With tab indentation
console.log(JSON.stringify(data, null, '\t'));
// Output:
// {
// 	"name": "John",
// 	"age": 30
// }

LINE-BY-LINE EXPLANATION OF FORMATTING
---------------------------------------
let data = { name: "John", age: 30 };
let formatted = JSON.stringify(data, null, 2);

EXPLANATION:
• First parameter (data): The object to stringify
• Second parameter (null): The replacer (we'll cover this next)
• Third parameter (2): Number of spaces for indentation
• Result: A nicely formatted, readable JSON string

EXAMPLE: FORMATTED OUTPUT
--------------------------
let company = {
  Company: "IBM",
  Country: "USA",
  Headquarters: "Armonk, New York"
};

let formatted = JSON.stringify(company, null, 2);
console.log(formatted);

OUTPUT:
{
  "Company": "IBM",
  "Country": "USA",
  "Headquarters": "Armonk, New York"
}

This is much more readable than the minified version!

THE REPLACER PARAMETER
----------------------
The second parameter (replacer) can be:
1. An array of property names to include
2. A function to transform values

EXAMPLE 1: INCLUDING ONLY SPECIFIC PROPERTIES
----------------------------------------------
let person = {
  name: "John",
  age: 30,
  password: "secret123",
  email: "john@example.com"
};

// Only include name and age
let jsonString = JSON.stringify(person, ['name', 'age']);
console.log(jsonString);
// Output: '{"name":"John","age":30}'

// The password and email are excluded for security

EXAMPLE 2: USING A REPLACER FUNCTION
-------------------------------------
let person = {
  name: "John",
  age: 30,
  password: "secret123"
};

let jsonString = JSON.stringify(person, (key, value) => {
  // Hide password
  if (key === 'password') {
    return undefined;  // undefined values are excluded
  }
  return value;
});

console.log(jsonString);
// Output: '{"name":"John","age":30}'

[END SECTION 3.3]
================================================================================

SECTION 3.4: WHAT GETS STRINGIFIED AND WHAT DOESN'T
-----------------------------------------------------

PROPERTIES THAT ARE INCLUDED
----------------------------
JSON.stringify() includes:
• String values
• Number values
• Boolean values
• Null values
• Arrays
• Objects
• Nested objects and arrays

PROPERTIES THAT ARE EXCLUDED
----------------------------
JSON.stringify() automatically excludes:
• Functions
• undefined values
• Symbol properties
• Properties with undefined values

EXAMPLE: WHAT GETS EXCLUDED
----------------------------
let data = {
  name: "John",
  age: 30,
  sayHello: function() {  // Function - will be excluded
    console.log("Hello");
  },
  email: undefined,      // undefined - will be excluded
  [Symbol('id')]: 123     // Symbol - will be excluded
};

let jsonString = JSON.stringify(data);
console.log(jsonString);
// Output: '{"name":"John","age":30}'

// Notice: sayHello, email, and the Symbol property are not included

WHY CERTAIN THINGS ARE EXCLUDED
--------------------------------
1. FUNCTIONS
   • Functions are executable code, not data
   • JSON is for data exchange, not code
   • Functions can't be represented in JSON format

2. UNDEFINED
   • JSON doesn't have an undefined type
   • Only has null for "no value"
   • undefined properties are simply omitted

3. SYMBOLS
   • Symbols are JavaScript-specific
   • Not part of the JSON specification
   • Can't be serialized

HANDLING SPECIAL CASES
----------------------

CASE 1: DATES
-------------
Dates are converted to strings:

let data = {
  name: "John",
  birthDate: new Date()
};

let jsonString = JSON.stringify(data);
console.log(jsonString);
// Output: '{"name":"John","birthDate":"2024-01-15T10:30:00.000Z"}'

// To preserve dates, you need to convert them manually:
let data = {
  name: "John",
  birthDate: new Date().toISOString()  // Convert to string first
};

CASE 2: CUSTOM OBJECTS
----------------------
Some objects might not stringify as expected. You can use a replacer function 
or implement a toJSON() method:

let person = {
  name: "John",
  age: 30,
  toJSON: function() {
    return {
      name: this.name,
      age: this.age,
      displayName: this.name + " (" + this.age + ")"
    };
  }
};

let jsonString = JSON.stringify(person);
console.log(jsonString);
// Output: '{"name":"John","age":30,"displayName":"John (30)"}'

[END SECTION 3.4]
================================================================================

END OF PART 1
=============

This concludes Part 1 of the Working with JSON comprehensive study guide. 
You have learned:

✓ What JSON is and why it's important
✓ JSON structure and syntax rules
✓ How to parse JSON strings using JSON.parse()
✓ How to convert JavaScript objects to JSON using JSON.stringify()
✓ How to handle errors when parsing JSON
✓ How to work with JSON in HTTP messages

In Part 2, you will learn:
• Real-world API examples with detailed code explanations
• Working with the International Space Station (ISS) API example
• Complete Node.js examples with line-by-line explanations
• Best practices for working with JSON
• Common patterns and use cases
• Summary and quick reference guide

Continue to Part 2 for practical, real-world examples and advanced topics.

================================================================================

