================================================================================
JAVASCRIPT PROMISES
Comprehensive Study Guide - Part 1
================================================================================

WELCOME
-------
Welcome to JavaScript Promises. This comprehensive guide will teach you 
everything you need to know about Promises, from the basics to advanced 
patterns and real-world applications in Node.js and JavaScript.

ESTIMATED TIME NEEDED
---------------------
5 minutes (for basic reading)
60-90 minutes (for comprehensive study with practice)

LEARNING OBJECTIVES
-------------------
After studying this guide, you will be able to:
• Define promises in the context of JavaScript and Node.js
• Explain the different states of a promise (pending, resolved, rejected)
• Describe how to use promises with asynchronous methods
• Create promise objects for blocking operations
• Use promises with file I/O operations
• Use promises with HTTP requests using the axios package
• Understand the .then() and .catch() methods
• Handle promise fulfillment and rejection

OVERVIEW
--------
A promise is an object returned by an asynchronous method. The promise has 
three states, which are pending, resolved, and rejected. Promises are most 
useful for application programming interface (API) requests, input/output 
(I/O) operations, and other operations that are time consuming and can block 
resources. A method can be defined to return a promise object, if you know 
it is going to take time for execution and thereby block resources.

Promises provide a cleaner way to handle asynchronous operations compared to 
callbacks, avoiding callback hell and making error handling more straightforward.

================================================================================
TABLE OF CONTENTS - PART 1
================================================================================

This part covers the fundamentals of Promises:

PART 1: INTRODUCTION TO PROMISES
  SECTION 1.1: WHAT IS A PROMISE?
  SECTION 1.2: WHY DO WE NEED PROMISES?
  SECTION 1.3: WHEN TO USE PROMISES

PART 2: PROMISE STATES
  SECTION 2.1: THE THREE STATES OF A PROMISE
  SECTION 2.2: UNDERSTANDING PENDING STATE
  SECTION 2.3: UNDERSTANDING RESOLVED STATE
  SECTION 2.4: UNDERSTANDING REJECTED STATE
  SECTION 2.5: STATE TRANSITIONS

PART 3: CREATING PROMISES
  SECTION 3.1: HOW PROMISES ARE CREATED
  SECTION 3.2: PROMISE CONSTRUCTOR SYNTAX
  SECTION 3.3: CREATING PROMISES FOR BLOCKING OPERATIONS

NOTE: Part 2 of this guide covers:
  • Using promises with .then() and .catch()
  • File reading example with detailed code explanations
  • HTTP requests with axios example with detailed code explanations
  • Summary, key definitions, quick reference guide, and best practices

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 1.3:") to quickly jump to any section.

================================================================================
PART 1: INTRODUCTION TO PROMISES
================================================================================

SECTION 1.1: WHAT IS A PROMISE?
--------------------------------

DEFINITION
----------
A promise is an object returned by an asynchronous method. The promise has 
three states, which are pending, resolved, and rejected.

DETAILED EXPLANATION
--------------------
In JavaScript and Node.js, a Promise is a special object that represents the 
eventual completion (or failure) of an asynchronous operation. Think of it 
as a placeholder for a value that will be available in the future.

When you call a method that returns a promise, a promise object is created. 
This promise object acts as a contract that says: "I will eventually give 
you a result, but it might take some time. Here's a way to handle it when 
it's ready."

KEY CHARACTERISTICS
-------------------
• A Promise is a JavaScript object
• It represents an asynchronous operation
• It has three possible states: pending, resolved, or rejected
• It provides a way to handle asynchronous results
• It can be chained with .then() and .catch() methods
• It helps avoid callback hell

REAL-WORLD ANALOGY
------------------
Think of a Promise like ordering food at a restaurant:
• You place your order (call an async function) → A promise is created
• The order is being prepared (pending state) → Promise is pending
• Your food arrives (operation completes) → Promise is resolved
• Something goes wrong (kitchen error) → Promise is rejected

The promise is like a receipt that guarantees you'll either get your food 
or know why you didn't get it.

TECHNICAL EXPLANATION
---------------------
In JavaScript, a Promise is a built-in object that represents a value that 
may not be available yet. It's part of the JavaScript language (ES6/ES2015) 
and is available in both browser JavaScript and Node.js.

When you create or receive a Promise:
1. It immediately returns a Promise object
2. The Promise starts in the "pending" state
3. The asynchronous operation runs in the background
4. When complete, the Promise transitions to either "resolved" or "rejected"
5. You can attach handlers to respond to these state changes

EXAMPLE: SIMPLE PROMISE
-----------------------
  const myPromise = new Promise((resolve, reject) => {
    // Some asynchronous operation
    setTimeout(() => {
      resolve('Operation completed!');
    }, 1000);
  });

EXPLANATION:
------------
• new Promise() - Creates a new Promise object
• (resolve, reject) => { } - Executor function that runs immediately
• resolve() - Function to call when operation succeeds
• reject() - Function to call when operation fails
• setTimeout() - Simulates an asynchronous operation
• After 1 second, resolve() is called, changing promise to resolved state

[END SECTION 1.1]
================================================================================

SECTION 1.2: WHY DO WE NEED PROMISES?
--------------------------------------

THE PROBLEM WITH CALLBACKS
--------------------------
Before Promises, JavaScript used callbacks to handle asynchronous operations. 
This led to several problems:

1. CALLBACK HELL
   When you have multiple nested callbacks, the code becomes hard to read:
   
   getData(function(a) {
     getMoreData(a, function(b) {
       getMoreData(b, function(c) {
         getMoreData(c, function(d) {
           // Code becomes deeply nested and hard to read
         });
       });
     });
   });

2. ERROR HANDLING DIFFICULTY
   With callbacks, error handling requires checking errors at each level:
   
   readFile('file1.txt', function(err, data1) {
     if (err) {
       // Handle error
       return;
     }
     readFile('file2.txt', function(err, data2) {
       if (err) {
         // Handle error again
         return;
       }
       // Continue...
     });
   });

3. DIFFICULT TO CHAIN OPERATIONS
   Chaining multiple asynchronous operations with callbacks is complex and 
   error-prone.

HOW PROMISES SOLVE THESE PROBLEMS
----------------------------------
1. CLEANER CODE STRUCTURE
   Promises allow you to write asynchronous code that looks more like 
   synchronous code:
   
   getData()
     .then(a => getMoreData(a))
     .then(b => getMoreData(b))
     .then(c => getMoreData(c))
     .catch(error => {
       // Single error handler for all operations
     });

2. BETTER ERROR HANDLING
   With Promises, you can use a single .catch() to handle all errors in a 
   chain:
   
   readFile('file1.txt')
     .then(data1 => readFile('file2.txt'))
     .then(data2 => {
       // Process data
     })
     .catch(error => {
       // Handles errors from any step
     });

3. EASIER CHAINING
   Promises make it easy to chain multiple asynchronous operations together 
   in a readable way.

4. BETTER CONTROL FLOW
   Promises provide better control over when operations execute and how 
   errors are handled.

[END SECTION 1.2]
================================================================================

SECTION 1.3: WHEN TO USE PROMISES
----------------------------------

USE CASE 1: APPLICATION PROGRAMMING INTERFACE (API) REQUESTS
------------------------------------------------------------
Promises are most useful for application programming interface (API) requests. 
When you make an HTTP request to an API, it takes time to:
• Send the request over the network
• Wait for the server to process it
• Receive the response

During this time, you don't want your application to freeze. Promises allow 
the request to happen in the background while your code continues.

EXAMPLE USE CASES:
------------------
• Fetching data from a REST API
• Making POST requests to save data
• Getting user information from a server
• Loading configuration from an API

USE CASE 2: INPUT/OUTPUT (I/O) OPERATIONS
------------------------------------------
Promises are most useful for input/output (I/O) operations. I/O operations 
include:
• Reading files from disk
• Writing files to disk
• Reading from databases
• Writing to databases

These operations are slow because they involve:
• Disk access (mechanical or solid-state)
• Network communication
• Database queries

EXAMPLE USE CASES:
------------------
• Reading configuration files
• Writing log files
• Loading user data from a database
• Saving user preferences to disk

USE CASE 3: TIME CONSUMING OPERATIONS
--------------------------------------
Promises are most useful for other operations that are time consuming and 
can block resources. These include:
• Image processing
• Video encoding
• Large data transformations
• Complex calculations
• Network operations

WHEN TO CREATE YOUR OWN PROMISES
---------------------------------
A method can be defined to return a promise object, if you know it is going 
to take time for execution and thereby block resources. You can also create 
a promise object if you know that the operations you are going to perform 
could be blocking.

This means:
• If you're writing a function that will take time to complete
• If the operation might block other code from running
• If you want to provide a clean API for handling asynchronous results
• If you want to integrate with other Promise-based code

EXAMPLE SCENARIO:
----------------
Imagine you're creating a function to process a large image:

  function processImage(imagePath) {
    return new Promise((resolve, reject) => {
      // This will take time and could block
      // So we wrap it in a Promise
      // ... image processing code ...
    });
  }

This function returns a Promise because:
• Image processing takes time
• It could block the main thread
• Callers can use .then() to handle the result
• Callers can use .catch() to handle errors

[END SECTION 1.3]
[END PART 1]
================================================================================

PART 2: PROMISE STATES
================================================================================

SECTION 2.1: THE THREE STATES OF A PROMISE
-------------------------------------------

DEFINITION
----------
The promise has three states, which are pending, resolved, and rejected.

DETAILED EXPLANATION
--------------------
Every Promise object exists in exactly one of three states at any given time:
1. Pending - The initial state, operation is in progress
2. Resolved (also called Fulfilled) - The operation completed successfully
3. Rejected - The operation failed or encountered an error

These states are mutually exclusive - a Promise can only be in one state at 
a time, and once it leaves the pending state, it cannot change to another 
state.

STATE DIAGRAM
-------------
  Pending
     |
     | (operation succeeds)
     v
  Resolved ──> (Promise is settled, cannot change)
     ^
     | (operation fails)
  Rejected ──> (Promise is settled, cannot change)

IMPORTANT NOTES
--------------
• A Promise starts in the pending state
• Once resolved or rejected, a Promise is "settled" and cannot change
• You can attach handlers to a Promise at any time
• If you attach a handler after the Promise is settled, it still executes

[END SECTION 2.1]
================================================================================

SECTION 2.2: UNDERSTANDING PENDING STATE
-----------------------------------------

DEFINITION
----------
When you call a method that returns a promise, a promise object is created. 
The initial state of the promise is the pending state. It is in this state 
until the operation is complete or some error has caused the operation to abort.

DETAILED EXPLANATION
--------------------
The pending state is the starting point for every Promise. When a Promise is 
pending:
• The asynchronous operation is still running
• The final result is not yet available
• The Promise has not succeeded or failed yet
• You can attach handlers, but they won't execute yet

WHAT HAPPENS IN PENDING STATE
-----------------------------
1. The Promise object is created immediately
2. The asynchronous operation begins
3. The Promise is in "pending" state
4. Your code continues executing (doesn't wait)
5. The Promise waits for the operation to complete

EXAMPLE: PENDING STATE
----------------------
  const filePromise = readFile('data.txt');
  
  console.log(filePromise); 
  // Promise { <pending> }
  
  // At this point:
  // - The file reading has started
  // - But it's not finished yet
  // - The Promise is still pending
  // - We don't have the file contents yet

REAL-WORLD ANALOGY
------------------
Think of pending state like waiting for a package delivery:
• You place an order (create Promise) → Pending state begins
• The package is being shipped (operation running) → Still pending
• You're waiting, but don't have the package yet → Still pending
• Once delivered or lost → Moves to resolved or rejected

HOW LONG DOES PENDING LAST?
---------------------------
A Promise stays in pending state until:
• The operation completes successfully → Becomes resolved
• The operation fails or errors → Becomes rejected
• The operation is cancelled (if supported) → Becomes rejected

The duration depends on the operation:
• File read: milliseconds to seconds (depends on file size)
• HTTP request: hundreds of milliseconds to seconds (depends on network)
• Database query: milliseconds to seconds (depends on query complexity)

[END SECTION 2.2]
================================================================================

SECTION 2.3: UNDERSTANDING RESOLVED STATE
------------------------------------------

DEFINITION
----------
When the operation is complete, the promise is said to be resolved.

DETAILED EXPLANATION
--------------------
The resolved state (also called "fulfilled") means the asynchronous operation 
completed successfully. When a Promise is resolved:
• The operation finished without errors
• The result value is available
• Any .then() handlers attached to the Promise will execute
• The Promise will never change state again (it's settled)

WHAT HAPPENS WHEN RESOLVED
--------------------------
1. The asynchronous operation completes successfully
2. The Promise transitions from pending to resolved
3. The resolve() function is called with a value
4. All attached .then() handlers are called with that value
5. The Promise is now "settled" and won't change

EXAMPLE: RESOLVED STATE
-----------------------
  const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Success!'); // Promise becomes resolved
    }, 1000);
  });
  
  promise.then(result => {
    console.log(result); // "Success!" - executed when resolved
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: const promise = new Promise((resolve, reject) => {
        • Creates a new Promise object
        • Stores it in the variable 'promise'
        • The executor function runs immediately
        • resolve and reject are functions provided by JavaScript

Line 2: setTimeout(() => {
        • setTimeout simulates an asynchronous operation
        • The arrow function will run after 1000ms (1 second)
        • During this 1 second, the Promise is in pending state

Line 3: resolve('Success!');
        • Calls the resolve function
        • 'Success!' is the value the Promise resolves with
        • This changes the Promise from pending to resolved
        • The value 'Success!' becomes available to .then() handlers

Line 4: }, 1000);
        • Closes the setTimeout function
        • 1000 is the delay in milliseconds

Line 5: });
        • Closes the Promise constructor

Line 7: promise.then(result => {
        • Attaches a handler to the Promise
        • .then() is called when the Promise is resolved
        • result will contain the value passed to resolve()
        • In this case, result will be 'Success!'

Line 8: console.log(result);
        • Logs the resolved value to the console
        • This executes after the Promise resolves (after 1 second)

Line 9: });
        • Closes the .then() handler function

REAL-WORLD ANALOGY
------------------
Resolved state is like successfully receiving a package:
• You ordered something (created Promise) → Was pending
• Package arrives undamaged (operation succeeds) → Now resolved
• You open it and get what you wanted (value is available)
• The delivery is complete (Promise is settled)

WHAT VALUES CAN BE RESOLVED?
----------------------------
A Promise can resolve with any JavaScript value:
• Strings: resolve('Hello')
• Numbers: resolve(42)
• Objects: resolve({ name: 'John', age: 30 })
• Arrays: resolve([1, 2, 3])
• Other Promises: resolve(anotherPromise)
• null or undefined: resolve(null)

[END SECTION 2.3]
================================================================================

SECTION 2.4: UNDERSTANDING REJECTED STATE
------------------------------------------

DEFINITION
----------
When there is an error, the promise is said to be rejected.

DETAILED EXPLANATION
--------------------
The rejected state means the asynchronous operation failed or encountered an 
error. When a Promise is rejected:
• The operation did not complete successfully
• An error occurred during execution
• The error information is available
• Any .catch() handlers attached to the Promise will execute
• The Promise will never change state again (it's settled)

WHAT HAPPENS WHEN REJECTED
--------------------------
1. The asynchronous operation encounters an error
2. The Promise transitions from pending to rejected
3. The reject() function is called with an error (usually an Error object)
4. All attached .catch() handlers are called with that error
5. The Promise is now "settled" and won't change

EXAMPLE: REJECTED STATE
----------------------
  const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error('Something went wrong!')); // Promise becomes rejected
    }, 1000);
  });
  
  promise.catch(error => {
    console.log(error.message); // "Something went wrong!" - executed when rejected
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: const promise = new Promise((resolve, reject) => {
        • Creates a new Promise object
        • resolve and reject are functions to change the Promise state

Line 2: setTimeout(() => {
        • Simulates an asynchronous operation
        • Will execute after 1 second

Line 3: reject(new Error('Something went wrong!'));
        • Calls the reject function
        • new Error() creates an Error object with a message
        • 'Something went wrong!' is the error message
        • This changes the Promise from pending to rejected
        • The error becomes available to .catch() handlers

Line 4: }, 1000);
        • Closes setTimeout with 1 second delay

Line 5: });
        • Closes the Promise constructor

Line 7: promise.catch(error => {
        • Attaches an error handler to the Promise
        • .catch() is called when the Promise is rejected
        • error will contain the value passed to reject()
        • In this case, error will be the Error object

Line 8: console.log(error.message);
        • Logs the error message to the console
        • .message is a property of Error objects
        • This executes after the Promise rejects (after 1 second)

Line 9: });
        • Closes the .catch() handler function

REAL-WORLD ANALOGY
------------------
Rejected state is like a failed package delivery:
• You ordered something (created Promise) → Was pending
• Package is lost or damaged (operation fails) → Now rejected
• You get a notification about the problem (error is available)
• The delivery failed (Promise is settled in rejected state)

COMMON REASONS FOR REJECTION
----------------------------
Promises are typically rejected when:
• A file doesn't exist (file reading fails)
• Network request fails (HTTP error)
• Invalid input provided
• Resource is unavailable
• Timeout occurs
• Permission denied
• Database connection fails

WHAT VALUES CAN BE REJECTED?
----------------------------
A Promise can reject with any value, but it's best practice to use Error objects:
• Error objects: reject(new Error('Message'))
• Strings: reject('Error message') (not recommended)
• Objects: reject({ code: 404, message: 'Not found' })
• Numbers: reject(500) (not recommended)

Best practice is to always reject with Error objects because:
• They have a stack trace for debugging
• They have a .message property
• They're the standard way to represent errors in JavaScript

[END SECTION 2.4]
================================================================================

SECTION 2.5: STATE TRANSITIONS
-------------------------------

UNDERSTANDING STATE FLOW
------------------------
A Promise follows a specific state transition pattern:

1. CREATION → PENDING
   When you create a Promise, it immediately enters the pending state.

2. PENDING → RESOLVED
   If the operation succeeds, the Promise transitions to resolved state.
   This happens when resolve() is called.

3. PENDING → REJECTED
   If the operation fails, the Promise transitions to rejected state.
   This happens when reject() is called.

4. SETTLED (RESOLVED OR REJECTED)
   Once a Promise is resolved or rejected, it is "settled" and cannot 
   change state again. It will remain in that state forever.

VISUAL REPRESENTATION
---------------------
  [Promise Created]
         |
         v
    [PENDING]
         |
    /         \
   /           \
  v             v
[RESOLVED]  [REJECTED]
   |             |
   \             /
    \           /
     v         v
  [SETTLED - Cannot Change]

IMPORTANT RULES
---------------
1. A Promise can only transition from pending to either resolved or rejected
2. Once settled, a Promise cannot change state
3. You cannot resolve a Promise that's already rejected
4. You cannot reject a Promise that's already resolved
5. You can attach handlers at any time (even after settlement)

EXAMPLE: STATE TRANSITION
------------------------
  const promise = new Promise((resolve, reject) => {
    console.log('1. Promise created, state: PENDING');
    
    setTimeout(() => {
      const success = true; // Simulate operation result
      
      if (success) {
        console.log('2. Operation succeeded, transitioning to RESOLVED');
        resolve('Success!');
      } else {
        console.log('2. Operation failed, transitioning to REJECTED');
        reject(new Error('Failed!'));
      }
    }, 1000);
  });
  
  promise.then(result => {
    console.log('3. Promise is RESOLVED, value:', result);
  });
  
  promise.catch(error => {
    console.log('3. Promise is REJECTED, error:', error.message);
  });

OUTPUT:
-------
1. Promise created, state: PENDING
2. Operation succeeded, transitioning to RESOLVED
3. Promise is RESOLVED, value: Success!

EXPLANATION:
------------
• Line 1: Promise is created and immediately enters pending state
• Line 2: After 1 second, operation completes successfully
• Line 3: resolve() is called, Promise transitions to resolved
• Line 4: .then() handler executes with the resolved value

[END SECTION 2.5]
[END PART 2]
================================================================================

PART 3: CREATING PROMISES
================================================================================

SECTION 3.1: HOW PROMISES ARE CREATED
-------------------------------------

AUTOMATIC CREATION
------------------
When you call a method that returns a promise, a promise object is created. 
Many built-in functions and libraries in Node.js and JavaScript return 
Promises automatically.

EXAMPLES OF FUNCTIONS THAT RETURN PROMISES:
-------------------------------------------
• fs.promises.readFile() - File reading in Node.js
• fetch() - HTTP requests in browsers
• axios.get() - HTTP requests (with axios library)
• Database query methods (with modern database libraries)
• Many npm packages designed for async operations

EXAMPLE: AUTOMATIC PROMISE CREATION
-----------------------------------
  const fs = require('fs').promises;
  
  // readFile returns a Promise automatically
  const filePromise = fs.readFile('data.txt', 'utf8');
  
  // filePromise is already a Promise object
  console.log(filePromise); // Promise { <pending> }

MANUAL CREATION
---------------
You can also create a promise object if you know that the operations you are 
going to perform could be blocking. This is useful when:
• You're wrapping callback-based code
• You're creating custom asynchronous operations
• You want to convert synchronous code to asynchronous
• You need to control when resolve/reject is called

[END SECTION 3.1]
================================================================================

SECTION 3.2: PROMISE CONSTRUCTOR SYNTAX
----------------------------------------

BASIC SYNTAX
-------------
  const promise = new Promise((resolve, reject) => {
    // Asynchronous operation here
    // Call resolve(value) on success
    // Call reject(error) on failure
  });

BREAKDOWN:
----------
• new Promise() - Creates a new Promise object
• (resolve, reject) => { } - Executor function that runs immediately
• resolve - Function to call when operation succeeds
• reject - Function to call when operation fails
• The executor function runs synchronously (immediately)
• But you call resolve/reject asynchronously (later)

DETAILED EXPLANATION OF EACH PART
----------------------------------

1. NEW PROMISE()
   This is the Promise constructor. It creates a new Promise instance.

2. EXECUTOR FUNCTION
   The function (resolve, reject) => { } is called the "executor". It:
   • Runs immediately when the Promise is created
   • Receives two functions as parameters: resolve and reject
   • Contains the code for your asynchronous operation
   • Must eventually call either resolve() or reject()

3. RESOLVE FUNCTION
   • Call this when your operation succeeds
   • Pass the result value as an argument: resolve(result)
   • Changes Promise state from pending to resolved
   • Any value passed becomes available to .then() handlers

4. REJECT FUNCTION
   • Call this when your operation fails
   • Pass an error as an argument: reject(error)
   • Changes Promise state from pending to rejected
   • The error becomes available to .catch() handlers

COMPLETE EXAMPLE
----------------
  const myPromise = new Promise((resolve, reject) => {
    console.log('Executor runs immediately');
    
    // Simulate async operation
    setTimeout(() => {
      const randomNumber = Math.random();
      
      if (randomNumber > 0.5) {
        resolve('Operation succeeded!');
      } else {
        reject(new Error('Operation failed!'));
      }
    }, 2000);
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: const myPromise = new Promise((resolve, reject) => {
        • const myPromise - Creates a constant to store the Promise
        • new Promise() - Creates a new Promise instance
        • (resolve, reject) => { } - Executor function
        • resolve - Function to call on success
        • reject - Function to call on failure
        • This line creates the Promise and it immediately enters pending state

Line 2: console.log('Executor runs immediately');
        • This runs immediately (synchronously)
        • The executor function executes right away, not later
        • This proves the executor runs when Promise is created

Line 3: (empty line for readability)

Line 4: // Simulate async operation
        • Comment explaining what comes next
        • We're simulating something that takes time

Line 5: setTimeout(() => {
        • setTimeout - Delays execution (simulates async operation)
        • The arrow function will run after 2000ms (2 seconds)
        • During these 2 seconds, the Promise remains in pending state

Line 6: const randomNumber = Math.random();
        • Math.random() - Generates random number between 0 and 1
        • Stores it in randomNumber variable
        • We'll use this to randomly succeed or fail

Line 7: (empty line)

Line 8: if (randomNumber > 0.5) {
        • Checks if random number is greater than 0.5
        • If true, we'll resolve (succeed)
        • If false, we'll reject (fail)
        • This simulates a 50/50 chance of success/failure

Line 9: resolve('Operation succeeded!');
        • Calls the resolve function
        • 'Operation succeeded!' - The value to resolve with
        • This changes Promise from pending to resolved
        • The string becomes available to .then() handlers

Line 10: } else {
         • If randomNumber <= 0.5, execute this block

Line 11: reject(new Error('Operation failed!'));
         • Calls the reject function
         • new Error() - Creates an Error object
         • 'Operation failed!' - The error message
         • This changes Promise from pending to rejected
         • The error becomes available to .catch() handlers

Line 12: }
         • Closes the if-else statement

Line 13: }, 2000);
         • Closes the setTimeout function
         • 2000 - Delay in milliseconds (2 seconds)

Line 14: });
         • Closes the Promise constructor
         • At this point, myPromise exists and is in pending state

WHAT HAPPENS WHEN THIS CODE RUNS:
----------------------------------
1. Promise is created → Enters pending state
2. "Executor runs immediately" is logged
3. setTimeout starts (2 second timer)
4. Code continues (doesn't wait for setTimeout)
5. After 2 seconds, setTimeout callback runs
6. Random number is generated
7. Either resolve() or reject() is called
8. Promise transitions to resolved or rejected
9. Appropriate handlers (.then() or .catch()) execute

[END SECTION 3.2]
================================================================================

SECTION 3.3: CREATING PROMISES FOR BLOCKING OPERATIONS
--------------------------------------------------------

WHEN TO CREATE YOUR OWN PROMISES
---------------------------------
A method can be defined to return a promise object, if you know it is going 
to take time for execution and thereby block resources. You can also create 
a promise object if you know that the operations you are going to perform 
could be blocking.

This means you should create Promises when:
• Your function performs time-consuming operations
• The operation might block the main thread
• You want to provide a clean async API
• You're wrapping callback-based code
• You need to control when operations complete

EXAMPLE: WRAPPING A BLOCKING OPERATION
---------------------------------------
  function processLargeData(data) {
    return new Promise((resolve, reject) => {
      // This operation takes time and could block
      try {
        // Simulate heavy processing
        let result = 0;
        for (let i = 0; i < 1000000; i++) {
          result += data[i] || 0;
        }
        
        // Operation completed successfully
        resolve(result);
      } catch (error) {
        // Operation failed
        reject(error);
      }
    });
  }

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: function processLargeData(data) {
        • Defines a function that processes large amounts of data
        • data - Parameter containing the data to process
        • This function will return a Promise

Line 2: return new Promise((resolve, reject) => {
        • return - Returns the Promise to the caller
        • new Promise() - Creates a new Promise
        • (resolve, reject) => { } - Executor function
        • The function returns immediately with a Promise (doesn't wait)

Line 3: // This operation takes time and could block
        • Comment explaining why we're using a Promise
        • The operation inside will take time

Line 4: try {
        • try block - Catches any errors that occur
        • If an error happens, we can catch it and reject the Promise

Line 5: // Simulate heavy processing
        • Comment explaining the next code

Line 6: let result = 0;
        • Initializes result variable to 0
        • This will store the sum of all data values

Line 7: for (let i = 0; i < 1000000; i++) {
        • for loop - Iterates 1,000,000 times
        • let i = 0 - Starts at index 0
        • i < 1000000 - Continues while i is less than 1 million
        • i++ - Increments i after each iteration
        • This loop will take time to execute

Line 8: result += data[i] || 0;
        • result += - Adds to result (same as result = result + ...)
        • data[i] - Gets value at index i from data array
        • || 0 - If data[i] is undefined/null, use 0 instead
        • This processes each element in the data

Line 9: }
        • Closes the for loop

Line 10: (empty line)
 
Line 11: // Operation completed successfully
         • Comment indicating success

Line 12: resolve(result);
         • Calls resolve with the calculated result
         • result contains the sum of all processed values
         • This changes Promise to resolved state
         • The result becomes available to .then() handlers

Line 13: } catch (error) {
         • catch block - Handles any errors
         • error - The error that occurred (if any)
         • This executes if something goes wrong in the try block

Line 14: // Operation failed
         • Comment indicating failure

Line 15: reject(error);
         • Calls reject with the error
         • error - The error object that was caught
         • This changes Promise to rejected state
         • The error becomes available to .catch() handlers

Line 16: }
         • Closes the catch block

Line 17: });
         • Closes the Promise constructor

Line 18: }
         • Closes the processLargeData function

USAGE EXAMPLE:
--------------
  const data = [1, 2, 3, 4, 5, /* ... many more values ... */];
  
  processLargeData(data)
    .then(result => {
      console.log('Processing complete! Result:', result);
    })
    .catch(error => {
      console.error('Processing failed:', error);
    });

BENEFITS OF THIS APPROACH:
--------------------------
1. Non-blocking: The function returns immediately with a Promise
2. Error handling: Errors are caught and passed to .catch()
3. Clean API: Callers use .then() and .catch() instead of callbacks
4. Chainable: Can be chained with other Promises
5. Consistent: Follows the same pattern as other async operations

[END SECTION 3.3]
[END PART 3]
================================================================================

This is Part 1 of the comprehensive guide. Part 2 will cover:
• Using promises with .then() and .catch() methods
• Complete file reading example with detailed code explanations
• Complete HTTP requests with axios example with detailed code explanations
• Summary, key definitions, quick reference guide, and best practices

================================================================================
END OF PART 1
================================================================================

