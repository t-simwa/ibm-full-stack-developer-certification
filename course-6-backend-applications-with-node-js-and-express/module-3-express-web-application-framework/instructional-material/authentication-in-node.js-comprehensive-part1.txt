================================================================================
AUTHENTICATION IN NODE.JS
Comprehensive Study Guide - Part 1
================================================================================

WELCOME
-------
Welcome to Authentication in Node.js. This comprehensive guide will teach you 
everything you need to know about implementing authentication and authorization 
in Node.js applications using token-based authentication, from the fundamental 
concepts to complete working implementations.

ESTIMATED TIME NEEDED
---------------------
5 minutes (for basic reading)
60-90 minutes (for comprehensive study with practice)

LEARNING OBJECTIVES
-------------------
After studying this guide, you will be able to:
• Define authentication and understand its purpose
• Explain the difference between authentication and authorization
• List and compare different authentication approaches
• Discuss advantages of token-based authentication in Node.js
• Understand how JSON Web Tokens (JWT) work
• Implement token-based authentication and authorization in Node.js
• Create secure API endpoints with Express.js
• Understand HTTP status codes related to authentication
• Implement JWT generation and verification
• Understand bearer tokens and authorization headers

OVERVIEW
--------
Authentication is the process of confirming a user's identity by obtaining 
credentials and using those credentials to validate their identity. 
Authentication is meant to identify users and provide access rights and contents 
depending on their ID.

In modern web applications, especially those built with Node.js and Express.js, 
token-based authentication has become the most popular approach. This guide will 
teach you how to implement a complete authentication system using JSON Web Tokens 
(JWT) in an Express.js application.

================================================================================
TABLE OF CONTENTS - PART 1
================================================================================

This part covers the fundamentals of authentication:

PART 1: INTRODUCTION TO AUTHENTICATION
  SECTION 1.1: WHAT IS AUTHENTICATION?
  SECTION 1.2: AUTHENTICATION VS AUTHORIZATION
  SECTION 1.3: WHY AUTHENTICATION IS IMPORTANT
  SECTION 1.4: AUTHENTICATION APPROACHES

PART 2: TOKEN-BASED AUTHENTICATION
  SECTION 2.1: WHAT IS TOKEN-BASED AUTHENTICATION?
  SECTION 2.2: ADVANTAGES OF TOKEN-BASED AUTHENTICATION
  SECTION 2.3: UNDERSTANDING JSON WEB TOKENS (JWT)
  SECTION 2.4: HOW JWT AUTHENTICATION WORKS

PART 3: SETTING UP THE BASIC EXPRESS SERVER
  SECTION 3.1: PROJECT SETUP AND DEPENDENCIES
  SECTION 3.2: CREATING THE BASIC SERVER
  SECTION 3.3: CREATING A PROTECTED ENDPOINT
  SECTION 3.4: TESTING THE PROTECTED ENDPOINT

NOTE: Part 2 of this guide covers:
  • Complete authentication implementation with detailed code explanations
  • JWT generation and verification
  • Login endpoint implementation
  • Protected resource endpoints
  • Complete working code examples with line-by-line explanations

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 1.3:") to quickly jump to any section.

================================================================================
PART 1: INTRODUCTION TO AUTHENTICATION
================================================================================

SECTION 1.1: WHAT IS AUTHENTICATION?
--------------------------------------

DEFINITION
----------
Authentication is the process of confirming a user's identity by obtaining 
credentials and using those credentials to validate their identity. 
Authentication is meant to identify users and provide access rights and contents 
depending on their ID.

DETAILED EXPLANATION
--------------------
Think of authentication like showing your ID at a bank. When you walk into a 
bank, you need to prove who you are before you can access your account. The 
bank teller asks for your ID (credentials), checks it (validates), and then 
allows you to access your account (provides access rights).

In web applications, authentication works similarly:
• A user provides credentials (username and password, email and password, etc.)
• The server validates these credentials
• If valid, the user is "authenticated" (confirmed to be who they claim to be)
• The user is then granted access to resources based on their identity

REAL-WORLD ANALOGY
------------------
Imagine you're trying to enter a secure building:
• Authentication = Showing your ID badge at the front desk
• The security guard checks your ID (validates credentials)
• If your ID is valid, you're authenticated (confirmed as an authorized person)
• You're then allowed to enter (granted access)

KEY CHARACTERISTICS OF AUTHENTICATION:
• Verifies WHO you are
• Happens before authorization
• Uses credentials (username/password, tokens, biometrics, etc.)
• Confirms identity
• Is a one-time or periodic process

COMMON AUTHENTICATION METHODS:
• Username and password
• Email and password
• Social login (Google, Facebook, etc.)
• Biometric authentication (fingerprint, face recognition)
• Two-factor authentication (2FA)
• Multi-factor authentication (MFA)

[END SECTION 1.1]
================================================================================
SECTION 1.2: AUTHENTICATION VS AUTHORIZATION
--------------------------------------------

UNDERSTANDING THE DIFFERENCE
-----------------------------
Many people confuse authentication and authorization. They are related but 
different concepts:

AUTHENTICATION (WHO ARE YOU?)
------------------------------
Authentication answers the question: "Who are you?"
• Verifies the user's identity
• Confirms that the user is who they claim to be
• Example: Logging in with username and password

AUTHORIZATION (WHAT CAN YOU DO?)
---------------------------------
Authorization answers the question: "What are you allowed to do?"
• Determines what resources a user can access
• Decides what actions a user can perform
• Happens AFTER authentication
• Example: An admin can delete users, but a regular user cannot

REAL-WORLD ANALOGY
------------------
Think of a hotel:
• AUTHENTICATION: You check in at the front desk with your ID (proving who you are)
• AUTHORIZATION: Your room key only opens YOUR room (determining what you can access)

Another example - a library:
• AUTHENTICATION: You show your library card (proving you're a member)
• AUTHORIZATION: You can only check out books, not access the staff-only area

THE RELATIONSHIP
----------------
Authentication must happen BEFORE authorization:
1. First, the system authenticates you (verifies your identity)
2. Then, the system authorizes you (determines what you can access based on your identity)

You cannot authorize someone without first authenticating them!

IN OUR CODE EXAMPLE
-------------------
In the code we'll build:
• AUTHENTICATION: The login endpoint verifies username and password (who you are)
• AUTHORIZATION: The employees endpoint checks if you have a valid token (what you can access)

[END SECTION 1.2]
================================================================================
SECTION 1.3: WHY AUTHENTICATION IS IMPORTANT
--------------------------------------------

SECURITY
--------
Authentication protects your application from unauthorized access. Without it, 
anyone could access sensitive data or perform actions they shouldn't be able to.

PROTECTING USER DATA
--------------------
Authentication ensures that:
• Users can only access their own data
• Personal information is kept private
• Sensitive operations require verification

PROTECTING APPLICATION RESOURCES
--------------------------------
Authentication helps protect:
• User accounts and profiles
• Financial transactions
• Administrative functions
• Private content and data
• API endpoints and services

COMPLIANCE AND LEGAL REQUIREMENTS
---------------------------------
Many applications require authentication for:
• Legal compliance (GDPR, HIPAA, etc.)
• Industry standards
• Business requirements
• User privacy protection

USER EXPERIENCE
---------------
Proper authentication also improves user experience by:
• Personalizing content for each user
• Remembering user preferences
• Providing secure access across devices
• Enabling features like saved shopping carts, favorites, etc.

[END SECTION 1.3]
================================================================================
SECTION 1.4: AUTHENTICATION APPROACHES
---------------------------------------

OVERVIEW
--------
As discussed in other materials, authentication can be achieved using the 
following approaches:
1. Session-based authentication
2. Token-based authentication
3. Password-less authentication

Each approach has its own advantages and use cases. Let's explore each one.

APPROACH 1: SESSION-BASED AUTHENTICATION
-----------------------------------------
HOW IT WORKS:
• User logs in with credentials
• Server creates a session and stores it (usually in memory or database)
• Server sends a session ID (usually in a cookie) to the client
• Client sends the session ID with each request
• Server validates the session ID to authenticate the user

ADVANTAGES:
• Server has full control over sessions
• Can easily invalidate sessions
• Works well for traditional web applications

DISADVANTAGES:
• Requires server-side storage (memory or database)
• Not ideal for distributed systems (multiple servers)
• Cookies can be vulnerable to CSRF attacks
• Less scalable for mobile applications

USE CASES:
• Traditional web applications
• Single-server applications
• Applications requiring server-side session management

APPROACH 2: TOKEN-BASED AUTHENTICATION
--------------------------------------
HOW IT WORKS:
• User logs in with credentials
• Server validates credentials and generates a token (usually JWT)
• Server sends the token to the client
• Client stores the token (localStorage, sessionStorage, or memory)
• Client sends the token with each request (usually in Authorization header)
• Server validates the token to authenticate the user

ADVANTAGES:
• Stateless (server doesn't need to store sessions)
• Scalable (works across multiple servers)
• Works well with mobile applications
• Flexible (can be used across different domains)
• Tokens can contain user information

DISADVANTAGES:
• Tokens can't be easily revoked (unless using a token blacklist)
• Tokens can be stolen if not properly secured
• Token size can be larger than session IDs

USE CASES:
• RESTful APIs
• Single Page Applications (SPAs)
• Mobile applications
• Microservices architectures
• Cross-domain applications

This is the approach we'll be implementing in this guide!

APPROACH 3: PASSWORD-LESS AUTHENTICATION
----------------------------------------
HOW IT WORKS:
• User provides an identifier (email or phone number)
• Server sends a one-time code or magic link
• User enters the code or clicks the link
• Server validates and authenticates the user

ADVANTAGES:
• No password to remember or forget
• More secure (no password to steal)
• Better user experience
• Reduces password-related support requests

DISADVANTAGES:
• Requires email or phone access
• Can be slower (waiting for code/link)
• May require additional infrastructure

USE CASES:
• Applications prioritizing user experience
• High-security applications
• Applications with password reset issues

WHY TOKEN-BASED AUTHENTICATION?
-------------------------------
Token-based authentication is the most popular approach to implementing 
authentication in Node.js because:
• It's well-suited for modern web applications
• It works great with RESTful APIs
• It's scalable and flexible
• It's what we'll learn in this guide!

[END SECTION 1.4]
[END PART 1]
================================================================================
PART 2: TOKEN-BASED AUTHENTICATION
================================================================================

SECTION 2.1: WHAT IS TOKEN-BASED AUTHENTICATION?
--------------------------------------------------

DEFINITION
----------
Token-based authentication is an authentication approach where the server 
generates a token (a string of characters) after validating user credentials. 
This token is then used by the client to access protected resources instead of 
sending credentials with every request.

DETAILED EXPLANATION
--------------------
Think of token-based authentication like a concert wristband:
• You buy a ticket (provide credentials - username/password)
• You get a wristband at the entrance (receive a token)
• You show the wristband to access different areas (use token for requests)
• The wristband proves you're authorized (token proves authentication)

HOW IT WORKS - STEP BY STEP
---------------------------
1. USER LOGS IN:
   • Client sends username and password to the server
   • Server validates the credentials

2. TOKEN GENERATION:
   • If credentials are valid, server generates a token
   • Token contains information about the user (encoded)
   • Server sends token to the client

3. TOKEN STORAGE:
   • Client stores the token (localStorage, sessionStorage, or memory)
   • Token is kept for future requests

4. MAKING AUTHENTICATED REQUESTS:
   • Client includes the token in requests (usually in Authorization header)
   • Server validates the token
   • If valid, server processes the request

5. TOKEN EXPIRATION:
   • Tokens usually have an expiration time
   • After expiration, user must log in again
   • Or use a refresh token to get a new token

KEY COMPONENTS
--------------
• TOKEN: A string that represents the user's authentication
• SECRET KEY: Used to sign and verify tokens (kept secret on server)
• EXPIRATION: Time after which token becomes invalid
• PAYLOAD: Data stored inside the token (user ID, permissions, etc.)

[END SECTION 2.1]
================================================================================
SECTION 2.2: ADVANTAGES OF TOKEN-BASED AUTHENTICATION
------------------------------------------------------

ADVANTAGE 1: SCALABILITY
--------------------------
Token-based authentication is more scalable as the token only needs to be stored 
on the client side.

WHAT THIS MEANS:
• The server doesn't need to store session information
• No need for a session database or in-memory storage
• Each server can validate tokens independently
• Easy to add more servers (horizontal scaling)

REAL-WORLD EXAMPLE:
Imagine a restaurant chain:
• Session-based: Each location needs to check with headquarters (centralized storage)
• Token-based: Each location can validate the token independently (no central check needed)

WHY IT'S SCALABLE:
• Stateless: Server doesn't maintain session state
• Distributed: Works across multiple servers without shared storage
• Independent: Each request contains all needed information (in the token)

ADVANTAGE 2: EASIER MULTI-USER HANDLING
---------------------------------------
Also, since the server only needs to verify the token along with the user 
information, it is easier to handle multiple users.

WHAT THIS MEANS:
• Server doesn't need to track active sessions
• No need to manage session timeouts
• Can handle thousands of concurrent users
• Simple validation process

HOW IT WORKS:
• Each user has their own token
• Server validates token on each request
• No need to maintain a list of active sessions
• Token contains user information, so no database lookup needed

PERFORMANCE BENEFITS:
• Faster request processing (no session lookup)
• Lower memory usage (no session storage)
• Better performance under load

ADVANTAGE 3: FLEXIBILITY
-------------------------
Token-based authentication offers flexibility as they can be used across multiple 
servers and they can offer authentication for diverse websites and applications 
at once.

WHAT THIS MEANS:
• Single token can work across different servers
• Can authenticate for multiple applications
• Works with microservices architecture
• Cross-domain authentication

REAL-WORLD EXAMPLE:
Imagine you have:
• A web application (example.com)
• A mobile app API (api.example.com)
• An admin panel (admin.example.com)

With token-based authentication:
• User logs in once
• Token works for all three applications
• No need to log in separately for each

MICROSERVICES BENEFITS:
• Each service can validate tokens independently
• No shared session storage needed
• Services can be on different servers
• Easy to add new services

CROSS-DOMAIN AUTHENTICATION:
• Token works across different domains
• Useful for Single Sign-On (SSO)
• Enables third-party integrations

ADVANTAGE 4: SECURITY
---------------------
And JWT used in token-based authentication can be signed and encrypted which 
means they cannot be tampered with and also cannot be read without the private 
encryption key.

WHAT THIS MEANS:
• Tokens are cryptographically signed
• Any tampering is immediately detectable
• Tokens can be encrypted for additional security
• Only the server with the secret key can create valid tokens

SIGNING EXPLAINED:
• Server signs token with a secret key
• Signature is part of the token
• If token is modified, signature won't match
• Server can detect tampering immediately

ENCRYPTION EXPLAINED:
• Token payload can be encrypted
• Without the decryption key, token is unreadable
• Protects sensitive information in the token
• Adds an extra layer of security

SECURITY BENEFITS:
• Prevents token tampering
• Protects user information
• Ensures token authenticity
• Makes tokens secure for transmission

SUMMARY OF ADVANTAGES
---------------------
1. ✅ SCALABILITY: No server-side session storage needed
2. ✅ MULTI-USER HANDLING: Easy to handle many concurrent users
3. ✅ FLEXIBILITY: Works across multiple servers and applications
4. ✅ SECURITY: Signed and encrypted tokens prevent tampering

[END SECTION 2.2]
================================================================================
SECTION 2.3: UNDERSTANDING JSON WEB TOKENS (JWT)
-------------------------------------------------

WHAT IS A JWT?
---------------
JWT stands for JSON Web Token. It's a compact, URL-safe way of representing 
claims (information) to be transferred between two parties. JWTs are commonly 
used in token-based authentication.

JWT STRUCTURE
-------------
A JWT consists of three parts separated by dots (.):

  header.payload.signature

EXAMPLE:
  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImpvaG4iLCJpYXQiOjE2MTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

PART 1: HEADER
--------------
The header typically consists of two parts:
• The type of token (JWT)
• The signing algorithm (e.g., HMAC SHA256 or RSA)

EXAMPLE (decoded):
  {
    "alg": "HS256",
    "typ": "JWT"
  }

EXPLANATION:
• "alg": The algorithm used to sign the token (HS256 = HMAC SHA256)
• "typ": The type of token (always "JWT" for JSON Web Tokens)

PART 2: PAYLOAD
---------------
The payload contains the claims (statements about the user and additional data).

EXAMPLE (decoded):
  {
    "username": "john",
    "iat": 1616239022,
    "exp": 1616242622
  }

COMMON CLAIMS:
• "username" or "userId": User identifier
• "iat": Issued at (timestamp when token was created)
• "exp": Expiration time (timestamp when token expires)
• "sub": Subject (usually user ID)
• "iss": Issuer (who created the token)

PART 3: SIGNATURE
-----------------
The signature is used to verify that the token hasn't been tampered with.

HOW IT'S CREATED:
  HMACSHA256(
    base64UrlEncode(header) + "." + base64UrlEncode(payload),
    secret
  )

EXPLANATION:
• Takes the encoded header and payload
• Signs them with the secret key
• Creates a signature that proves authenticity

HOW JWT VALIDATION WORKS
-------------------------
1. Server receives token
2. Server splits token into three parts (header.payload.signature)
3. Server recreates signature using header, payload, and secret key
4. Server compares recreated signature with received signature
5. If they match, token is valid (not tampered with)
6. If they don't match, token is invalid (rejected)

REAL-WORLD ANALOGY
------------------
Think of a JWT like a sealed envelope:
• HEADER: The envelope type and sealing method
• PAYLOAD: The letter inside (the message/information)
• SIGNATURE: The wax seal (proves it hasn't been opened/tampered with)

If someone opens the envelope and changes the letter, the wax seal breaks, 
and you know it's been tampered with!

[END SECTION 2.3]
================================================================================
SECTION 2.4: HOW JWT AUTHENTICATION WORKS
------------------------------------------

THE COMPLETE FLOW
-----------------
Let's understand the complete flow of JWT authentication from login to 
accessing protected resources.

STEP 1: USER LOGS IN
---------------------
1. User sends username and password to the server
2. Server validates credentials against database
3. If valid, proceed to Step 2
4. If invalid, return error (401 Unauthorized)

STEP 2: SERVER GENERATES JWT
------------------------------
1. Server creates JWT payload with user information:
   {
     "username": "john",
     "userId": "123",
     "iat": 1616239022,
     "exp": 1616242622
   }

2. Server signs JWT with secret key
3. Server sends JWT to client in response

STEP 3: CLIENT STORES TOKEN
-----------------------------
1. Client receives JWT from server
2. Client stores token (localStorage, sessionStorage, or memory)
3. Token is kept for future requests

STEP 4: CLIENT MAKES AUTHENTICATED REQUEST
-------------------------------------------
1. Client wants to access protected resource
2. Client includes JWT in Authorization header:
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
3. Client sends request to server

STEP 5: SERVER VALIDATES TOKEN
-------------------------------
1. Server extracts token from Authorization header
2. Server verifies token signature using secret key
3. Server checks if token is expired
4. If valid, proceed to Step 6
5. If invalid, return error (401 Unauthorized)

STEP 6: SERVER PROCESSES REQUEST
---------------------------------
1. Server extracts user information from token payload
2. Server processes the request
3. Server returns response to client

VISUAL FLOW DIAGRAM
-------------------
  [Client]                    [Server]
     |                            |
     |---1. POST /login----------->|
     |   (username, password)      |
     |                            |
     |                            |---2. Validate credentials
     |                            |---3. Generate JWT
     |                            |
     |<--4. Return JWT-------------|
     |   (token)                   |
     |                            |
     |---5. Store token-----------|
     |                            |
     |---6. GET /employees-------->|
     |   Authorization: Bearer token|
     |                            |
     |                            |---7. Verify token
     |                            |---8. Extract user info
     |                            |---9. Process request
     |                            |
     |<--10. Return data------------|
     |   (employee information)    |

BEARER TOKENS
-------------
The token is passed in the Authorization header with the format:
  Authorization: Bearer <token>

WHY "BEARER"?
The word "Bearer" means "the person who has this token." It's like saying 
"whoever has this token is authorized." The authorization header always starts 
with the string "bearer" at the start of the header, and therefore, this token 
is also known as bearer token.

EXAMPLE:
  Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImpvaG4iLCJpYXQiOjE2MTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

TOKEN EXPIRATION
----------------
Tokens typically have an expiration time (exp claim). After expiration:
• Token becomes invalid
• User must log in again to get a new token
• Or use a refresh token to get a new access token

[END SECTION 2.4]
[END PART 2]
================================================================================
PART 3: SETTING UP THE BASIC EXPRESS SERVER
================================================================================

SECTION 3.1: PROJECT SETUP AND DEPENDENCIES
---------------------------------------------

OVERVIEW
--------
Now let's set up an ExpressJS API server that provides access to employee 
information based on their usage rights. The application will have two APIs, 
each with its own endpoints.

REQUIRED DEPENDENCIES
---------------------
For this project, we'll need:
1. Express.js - Web framework for Node.js
2. jsonwebtoken - Library for creating and verifying JWTs

INSTALLING EXPRESS
------------------
If you haven't already, install Express:
  npm install express

WHAT IS EXPRESS?
Express is a fast, unopinionated, minimalist web framework for Node.js. It 
provides features for building web applications and APIs.

INSTALLING JSONWEBTOKEN
-----------------------
To generate the verified JWT, use the jsonwebtoken npm package. Install it 
using the command:
  npm install --save jsonwebtoken

WHAT IS JSONWEBTOKEN?
The jsonwebtoken package is a library that allows you to:
• Create (sign) JWTs
• Verify JWTs
• Decode JWTs
• Handle JWT expiration

PROJECT STRUCTURE
-----------------
Your project should have this structure:
  my-auth-project/
  ├── apiServer.js          (Main server file)
  ├── package.json          (Dependencies)
  └── node_modules/         (Installed packages)

CREATING PACKAGE.JSON
---------------------
If you don't have a package.json, create one:
  npm init -y

This creates a package.json file with default values.

[END SECTION 3.1]
================================================================================
SECTION 3.2: CREATING THE BASIC SERVER
---------------------------------------

OVERVIEW
--------
Let's start by creating a basic Express server. This code creates a web server 
module by calling the express function and assigning it to the constant myApp.

BASIC SERVER CODE
-----------------
  const express = require('express');
  const myApp = express();

  myApp.listen(5000, () => {
    console.log('API server is localhost:5000');
  });

LINE-BY-LINE EXPLANATION
------------------------
Line 1: const express = require('express');
        • Imports the Express module
        • require() is Node.js's way of importing modules
        • express is the Express framework
        • We store it in a constant called express

Line 2: const myApp = express();
        • Calls the express() function
        • This creates an Express application
        • The application is assigned to the constant myApp
        • myApp is now our web server application
        • This code creates a web server module by calling the express function 
          and assigning it to the constant myApp

Line 3: (empty line for readability)

Line 4: myApp.listen(5000, () => {
        • Starts the server listening on port 5000
        • listen() is a method that starts the server
        • 5000 is the port number (can be any available port)
        • The second argument is a callback function that runs when server starts

Line 5: console.log('API server is localhost:5000');
        • Logs a message to the console
        • This message appears when the server starts successfully
        • The server also listens on port 5000 for any HTTP calls to the server 
          and logs the message API server is localhost colon 5000 to the console

Line 6: });
        • Closes the callback function
        • Closes the listen() method call

WHAT THIS CODE DOES
-------------------
1. Imports Express framework
2. Creates an Express application
3. Starts a server on port 5000
4. Logs a message when server is ready
5. Server is now listening for HTTP requests

TESTING THE SERVER
------------------
To execute the API first, save the file and name it apiServer.js. Now run the 
command:
  node apiServer.js

You should see:
  API server is localhost:5000

The server is now running and ready to accept requests!

[END SECTION 3.2]
================================================================================
SECTION 3.3: CREATING A PROTECTED ENDPOINT
-------------------------------------------

OVERVIEW
--------
Now let's create a protected endpoint that requires authentication. The myapp.get 
function creates a GET API endpoint for the employee's API. And any call to this 
endpoint currently returns an HTTP status code of 401. And 401 means not 
authorized. With the message, please log in to access this resource.

PROTECTED ENDPOINT CODE
-----------------------
  const express = require('express');
  const myApp = express();

  myApp.get('/employees', (req, res) => {
    res.status(401).json({
      message: 'please log in to access this resource'
    });
  });

  myApp.listen(5000, () => {
    console.log('API server is localhost:5000');
  });

LINE-BY-LINE EXPLANATION
------------------------
Line 1: const express = require('express');
        • Imports the Express module (same as before)

Line 2: const myApp = express();
        • Creates the Express application (same as before)

Line 3: (empty line for readability)

Line 4: myApp.get('/employees', (req, res) => {
        • Creates a GET endpoint at the path '/employees'
        • myApp.get() is a method that creates a GET route
        • '/employees' is the URL path (e.g., http://localhost:5000/employees)
        • (req, res) => { } is an arrow function (callback)
        • req = request object (contains request data)
        • res = response object (used to send responses)
        • The myapp.get function creates a GET API endpoint for the employee's API

Line 5: res.status(401).json({
        • Sets HTTP status code to 401
        • 401 means "Unauthorized" (user is not authenticated)
        • And 401 means not authorized
        • .json() sends a JSON response
        • { } is the JSON object to send

Line 6: message: 'please log in to access this resource'
        • Creates a message property in the JSON object
        • The value is the error message
        • With the message, please log in to access this resource

Line 7: });
        • Closes the JSON object
        • Closes the .json() method

Line 8: });
        • Closes the route handler function
        • Closes the myApp.get() method

Line 9: (empty line)

Line 10: myApp.listen(5000, () => {
         • Starts server on port 5000 (same as before)

Line 11: console.log('API server is localhost:5000');
         • Logs startup message (same as before)

Line 12: });
         • Closes the listen() method

UNDERSTANDING HTTP STATUS CODES
-------------------------------
HTTP status codes tell the client what happened with the request:

• 200 OK - Request succeeded
• 201 Created - Resource created successfully
• 400 Bad Request - Invalid request
• 401 Unauthorized - Not authenticated (this is what we're using)
• 403 Forbidden - Authenticated but not authorized
• 404 Not Found - Resource doesn't exist
• 500 Internal Server Error - Server error

WHY 401 UNAUTHORIZED?
---------------------
We use 401 because:
• The user hasn't logged in yet
• They don't have a valid token
• They need to authenticate first
• This is the standard status code for "not authenticated"

WHAT THIS ENDPOINT DOES
-----------------------
1. Listens for GET requests to '/employees'
2. Immediately returns 401 Unauthorized
3. Sends a message telling user to log in
4. This is a protected endpoint (requires authentication)

[END SECTION 3.3]
================================================================================
SECTION 3.4: TESTING THE PROTECTED ENDPOINT
--------------------------------------------

RUNNING THE SERVER
------------------
To execute the API first, save the file and name it apiServer.js. Now run the 
command:
  node apiServer.js

You should see:
  API server is localhost:5000

The server is now running!

TESTING WITH CURL
-----------------
To verify that the secure endpoint cannot be accessed unless the user is 
authorized, run this curl command on the screen:
  curl http://localhost:5000/employees

WHAT IS CURL?
Curl is a command-line tool for making HTTP requests. It's useful for testing 
APIs without a browser.

EXPECTED OUTPUT
---------------
In the output, you should see the message, please log in to access this resource 
per your code.

The response should look like:
  {"message":"please log in to access this resource"}

And the HTTP status code should be 401.

TESTING WITH BROWSER
--------------------
You can also test in a browser:
1. Open browser
2. Go to: http://localhost:5000/employees
3. You might see the JSON response or an error page
4. Check browser developer tools (F12) to see the 401 status

TESTING WITH POSTMAN
--------------------
1. Open Postman
2. Create a new GET request
3. URL: http://localhost:5000/employees
4. Send the request
5. You should see:
   • Status: 401 Unauthorized
   • Body: {"message":"please log in to access this resource"}

WHAT WE'VE ACCOMPLISHED
-----------------------
✅ Created a basic Express server
✅ Created a protected endpoint
✅ Endpoint returns 401 for unauthorized access
✅ Tested the endpoint

NEXT STEPS
----------
In Part 2, we'll:
• Add login functionality
• Generate JWT tokens
• Verify tokens on protected endpoints
• Allow authenticated users to access resources

[END SECTION 3.4]
[END PART 3]
================================================================================
SUMMARY OF PART 1
================================================================================

WHAT WE LEARNED
---------------
In Part 1, we covered:

1. AUTHENTICATION BASICS:
   • Authentication confirms user identity
   • Different from authorization (who vs. what)
   • Essential for security and user experience

2. AUTHENTICATION APPROACHES:
   • Session-based authentication
   • Token-based authentication (most popular for Node.js)
   • Password-less authentication

3. TOKEN-BASED AUTHENTICATION:
   • Advantages: Scalability, flexibility, security
   • JWTs are signed and encrypted
   • Stateless and works across multiple servers

4. JWT STRUCTURE:
   • Header (algorithm and type)
   • Payload (user information)
   • Signature (verification)

5. BASIC SERVER SETUP:
   • Created Express server
   • Created protected endpoint
   • Tested with 401 Unauthorized response

KEY CONCEPTS TO REMEMBER
------------------------
• Authentication = Verifying WHO you are
• Authorization = Determining WHAT you can do
• Token-based auth = Most popular for Node.js
• JWT = JSON Web Token (signed and encrypted)
• 401 = Unauthorized (not authenticated)
• Bearer token = Token in Authorization header

NEXT: PART 2
------------
Part 2 will cover:
• Complete authentication implementation
• JWT generation and verification
• Login endpoint with detailed code explanations
• Protected resource endpoints
• Complete working code with line-by-line explanations

================================================================================
END OF PART 1
================================================================================

Continue to Part 2 for the complete implementation with detailed code examples 
and explanations!

