================================================================================
EXPRESS WEB APPLICATION FRAMEWORK
Comprehensive Study Guide - Part 1
================================================================================

WELCOME
-------
Welcome to Express Web Application Framework. This comprehensive guide will teach 
you everything you need to know about Express, from understanding what it is and 
why it exists, to installing it and creating your first Express application. 
Express is one of the most popular and widely-used web frameworks in the Node.js 
ecosystem, and mastering it is essential for any backend developer.

ESTIMATED TIME NEEDED
---------------------
5 minutes (for basic reading)
60-90 minutes (for comprehensive study with practice)

LEARNING OBJECTIVES
-------------------
After studying this guide, you will be able to:
• Describe the Express framework and its purpose
• Explain what Express abstracts and why that matters
• Understand the primary uses of Express (APIs and SSR)
• Explain how Express differs from Node.js core HTTP module
• Describe the five-step process for working with Express
• Understand package.json structure and properties
• Explain how npm install works and why it's important
• Set up Express in a Node.js project

OVERVIEW
--------
Express is a web application framework built on top of Node.js. While Node.js 
provides the runtime environment and basic HTTP capabilities, Express abstracts 
away the low-level details and provides a robust, feature-rich framework for 
building web applications and APIs. Express helps developers organize their 
applications better, develop faster, and integrate middleware packages seamlessly. 
It's so popular that many other frameworks are built on top of Express, making 
it a foundational technology in modern web development.

================================================================================
TABLE OF CONTENTS - PART 1
================================================================================

This part covers the fundamentals of Express:

PART 1: INTRODUCTION TO EXPRESS
  SECTION 1.1: WHAT IS EXPRESS?
  SECTION 1.2: WHAT DOES EXPRESS ABSTRACT?
  SECTION 1.3: WHY USE EXPRESS?
  SECTION 1.4: EXPRESS VS NODE.JS CORE HTTP MODULE

PART 2: PRIMARY USES OF EXPRESS
  SECTION 2.1: EXPRESS FOR BUILDING APIs
  SECTION 2.2: EXPRESS FOR SERVER-SIDE RENDERING (SSR)
  SECTION 2.3: COMPARING APIs AND SSR

PART 3: THE FIVE-STEP PROCESS FOR WORKING WITH EXPRESS
  SECTION 3.1: OVERVIEW OF THE FIVE STEPS
  SECTION 3.2: STEP 1 - DECLARE EXPRESS AS A DEPENDENCY
  SECTION 3.3: STEP 2 - RUN NPM INSTALL

NOTE: Part 2 of this guide covers:
  • Steps 3-5: Importing Express, creating routes, and starting the server
  • Complete Express application examples with detailed code explanations
  • Summary, key definitions, quick reference guide, and best practices

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 1.3:") to quickly jump to any section.

================================================================================
PART 1: INTRODUCTION TO EXPRESS
================================================================================

SECTION 1.1: WHAT IS EXPRESS?
------------------------------

DEFINITION
----------
Express is a web application framework based on the Node.js runtime environment. 
However, Express abstracts low-level details, helping you organize your 
application better and develop your application faster. It provides robust 
mechanisms for integrating middleware packages and handling different HTTP 
request methods.

DETAILED EXPLANATION
--------------------
Let's break down this definition piece by piece:

1. "WEB APPLICATION FRAMEWORK"
   A framework is a collection of tools, libraries, and conventions that provide 
   a structure for building applications. Think of it like a blueprint for a 
   house - it gives you the foundation and structure, but you still build the 
   specific rooms (features) yourself. Express provides the structure and tools 
   needed to build web applications.

2. "BASED ON THE NODE.JS RUNTIME ENVIRONMENT"
   Express doesn't replace Node.js - it builds on top of it. Node.js provides 
   the JavaScript runtime (the ability to run JavaScript outside of a browser) 
   and basic HTTP server capabilities. Express takes these capabilities and 
   makes them easier to use and more powerful.

3. "ABSTRACTS LOW-LEVEL DETAILS"
   This is crucial to understand. "Abstracting" means hiding complexity. 
   Express hides the complicated, low-level details of handling HTTP requests 
   and responses, so you can focus on building your application's features 
   instead of worrying about parsing request headers, managing connections, etc.

4. "ROBUST MECHANISMS FOR INTEGRATING MIDDLEWARE PACKAGES"
   Middleware are functions that have access to the request and response objects. 
   They can modify them, end the request-response cycle, or pass control to the 
   next middleware. Express makes it incredibly easy to add middleware packages 
   (like authentication, logging, body parsing, etc.) to your application.

5. "HANDLING DIFFERENT HTTP REQUEST METHODS"
   HTTP has different methods: GET (retrieve data), POST (create data), PUT 
   (update data), DELETE (remove data), etc. Express provides simple, intuitive 
   ways to handle each of these methods.

REAL-WORLD ANALOGY
------------------
Think of Express like a restaurant kitchen system:

• NODE.JS is like having raw ingredients (flour, vegetables, meat) and basic 
  cooking equipment (stove, oven). You CAN make food with just these, but it 
  requires a lot of work and knowledge.

• EXPRESS is like having a professional kitchen setup with organized stations, 
  pre-made sauces, standardized recipes, and efficient workflows. You still use 
  the same ingredients (Node.js), but everything is organized, simplified, and 
  optimized for speed and consistency.

Just like a professional kitchen setup helps chefs cook faster and more 
consistently, Express helps developers build web applications faster and more 
reliably.

KEY CHARACTERISTICS OF EXPRESS
-------------------------------
• Widely used in the field today - industry standard
• Forms the basis of other frameworks - many frameworks are built on Express
• Minimal and flexible - doesn't force you into a specific structure
• Unopinionated - gives you freedom to organize your code as you see fit
• Extensive middleware ecosystem - thousands of packages available
• Fast and lightweight - minimal overhead
• Well-documented and well-maintained - large community support

[END SECTION 1.1]
================================================================================

SECTION 1.2: WHAT DOES EXPRESS ABSTRACT?
-----------------------------------------

UNDERSTANDING ABSTRACTION
--------------------------
Abstraction is a fundamental concept in programming. It means hiding complex 
implementation details behind a simpler interface. Express abstracts many 
low-level details that you would otherwise have to handle manually when using 
Node.js's core HTTP module.

WHAT EXPRESS ABSTRACTS AWAY
----------------------------

1. REQUEST PARSING
   Without Express: You would need to manually parse the URL, query parameters, 
   request headers, and request body. This involves string manipulation, 
   regular expressions, and handling different content types.
   
   With Express: Express automatically parses URLs, provides easy access to 
   query parameters, route parameters, and request body through simple 
   properties like req.params, req.query, and req.body.

2. ROUTING
   Without Express: You would need to manually check the URL path and HTTP 
   method using if/else statements or switch cases. This becomes messy and 
   hard to maintain as your application grows.
   
   With Express: Express provides a clean routing system where you can define 
   routes like app.get('/users', handler) or app.post('/users', handler). 
   Express handles matching URLs and methods automatically.

3. MIDDLEWARE CHAINING
   Without Express: You would need to manually call multiple functions in 
   sequence, handle errors, and manage the flow of request processing.
   
   With Express: Express provides a middleware system where you can chain 
   multiple functions, and Express automatically calls them in order, passing 
   the request and response objects to each.

4. RESPONSE HANDLING
   Without Express: You would need to manually set headers, status codes, and 
   format responses. This involves writing repetitive code for common tasks.
   
   With Express: Express provides methods like res.json(), res.send(), 
   res.render() that handle headers, status codes, and formatting automatically.

5. ERROR HANDLING
   Without Express: You would need to manually catch errors and format error 
   responses consistently across your application.
   
   With Express: Express provides error-handling middleware and makes it easy 
   to create consistent error responses.

EXAMPLE COMPARISON
------------------
Let's see a concrete example of what Express abstracts:

WITHOUT EXPRESS (Using Node.js core HTTP module):
-------------------------------------------------
const http = require('http');
const url = require('url');

const server = http.createServer((req, res) => {
  // Manually parse the URL
  const parsedUrl = url.parse(req.url, true);
  const path = parsedUrl.pathname;
  const query = parsedUrl.query;
  
  // Manually check the HTTP method
  if (req.method === 'GET' && path === '/users') {
    // Manually set headers
    res.setHeader('Content-Type', 'application/json');
    res.statusCode = 200;
    // Manually format JSON response
    res.end(JSON.stringify({ users: ['Alice', 'Bob'] }));
  } else {
    res.statusCode = 404;
    res.end('Not Found');
  }
});

server.listen(3000);

WITH EXPRESS:
-------------
const express = require('express');
const app = express();

// Express handles URL parsing, method checking, and response formatting
app.get('/users', (req, res) => {
  res.json({ users: ['Alice', 'Bob'] });
});

app.listen(3000);

As you can see, Express reduces about 15 lines of code to just 3 lines, and 
the Express version is much more readable and maintainable!

[END SECTION 1.2]
================================================================================

SECTION 1.3: WHY USE EXPRESS?
------------------------------

BENEFIT 1: BETTER ORGANIZATION
-------------------------------
Express helps you organize your application better. It provides a clear structure 
for:
• Separating routes into different files
• Organizing middleware
• Structuring your application logic
• Managing different parts of your application (APIs, views, static files)

Without Express, you might end up with one large file containing all your 
application logic, which becomes hard to maintain as your application grows.

BENEFIT 2: FASTER DEVELOPMENT
-----------------------------
Express helps you develop your application faster because:
• Less code to write - Express handles common tasks automatically
• Reusable patterns - Express provides standard patterns you can follow
• Rich ecosystem - Thousands of middleware packages available
• Less debugging - Express handles edge cases and common errors
• Better tooling - Many tools and extensions built for Express

BENEFIT 3: ROBUST MIDDLEWARE INTEGRATION
----------------------------------------
Express provides robust mechanisms for integrating middleware packages. 
Middleware are like plugins that add functionality to your application:
• Authentication middleware (passport.js, JWT)
• Body parsing middleware (express.json, express.urlencoded)
• Logging middleware (morgan)
• Security middleware (helmet)
• CORS middleware (cors)
• And many more!

Express makes it trivial to add these middleware - often just one line of code!

BENEFIT 4: HANDLING HTTP METHODS
--------------------------------
Express provides intuitive methods for handling different HTTP request methods:
• app.get() - Handle GET requests
• app.post() - Handle POST requests
• app.put() - Handle PUT requests
• app.delete() - Handle DELETE requests
• app.patch() - Handle PATCH requests
• And more!

Each method is designed specifically for its HTTP verb, making your code 
self-documenting and easier to understand.

BENEFIT 5: INDUSTRY STANDARD
-----------------------------
Express is widely used in the field today and forms the basis of other frameworks. 
This means:
• Large community support
• Extensive documentation and tutorials
• Many job opportunities require Express knowledge
• Other developers will understand your code
• Many tools and libraries are built for Express

[END SECTION 1.3]
================================================================================

SECTION 1.4: EXPRESS VS NODE.JS CORE HTTP MODULE
-------------------------------------------------

UNDERSTANDING THE DIFFERENCE
----------------------------
It's important to understand how Express differs from Node.js's core HTTP module. 
Both can create web servers, but they work very differently.

NODE.JS CORE HTTP MODULE APPROACH
----------------------------------
When using the Node.js core application programming interface (API), the 
http.createServer function relies on your custom callback function to parse 
through the web resource path.

This means:
• You write a single callback function that handles ALL requests
• You must manually check the URL path and HTTP method
• You must manually parse query parameters, route parameters, and request body
• You must manually set response headers and status codes
• You must manually format responses (JSON, HTML, etc.)

EXAMPLE WITH NODE.JS CORE HTTP:
--------------------------------
const http = require('http');
const url = require('url');

const server = http.createServer((req, res) => {
  // You must manually parse everything
  const parsedUrl = url.parse(req.url, true);
  const path = parsedUrl.pathname;
  const method = req.method;
  
  // You must manually check paths and methods
  if (method === 'GET' && path === '/users') {
    res.setHeader('Content-Type', 'application/json');
    res.statusCode = 200;
    res.end(JSON.stringify({ message: 'Users endpoint' }));
  } else if (method === 'POST' && path === '/users') {
    // You must manually read and parse the request body
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });
    req.on('end', () => {
      const data = JSON.parse(body);
      res.setHeader('Content-Type', 'application/json');
      res.statusCode = 201;
      res.end(JSON.stringify({ message: 'User created', data }));
    });
  } else {
    res.statusCode = 404;
    res.end('Not Found');
  }
});

server.listen(3000);

EXPRESS APPROACH
----------------
Express implements an app class that you map to a web resource path. This means:
• You create an Express application instance
• You map routes (URL paths) directly to handler functions
• Express automatically handles parsing, method matching, and response formatting
• Each route is independent and easy to understand

EXAMPLE WITH EXPRESS:
---------------------
const express = require('express');
const app = express();

// Express automatically parses JSON bodies (with middleware)
app.use(express.json());

// Map routes directly - much cleaner!
app.get('/users', (req, res) => {
  res.json({ message: 'Users endpoint' });
});

app.post('/users', (req, res) => {
  // req.body is already parsed by Express!
  res.status(201).json({ 
    message: 'User created', 
    data: req.body 
  });
});

app.listen(3000);

KEY DIFFERENCES SUMMARY
-----------------------
1. CODE ORGANIZATION
   • Node.js HTTP: One large callback function handling everything
   • Express: Separate route handlers for each endpoint

2. URL PARSING
   • Node.js HTTP: Manual parsing with url.parse()
   • Express: Automatic parsing, accessible via req.params, req.query

3. REQUEST BODY PARSING
   • Node.js HTTP: Manual reading and parsing of request stream
   • Express: Automatic parsing with middleware (express.json())

4. ROUTE MATCHING
   • Node.js HTTP: Manual if/else or switch statements
   • Express: Direct route mapping (app.get('/path', handler))

5. RESPONSE FORMATTING
   • Node.js HTTP: Manual header setting and JSON.stringify()
   • Express: Helper methods (res.json(), res.send())

6. READABILITY
   • Node.js HTTP: More verbose, harder to read
   • Express: Cleaner, more declarative, easier to understand

WHEN TO USE EACH
----------------
• Use Node.js core HTTP when:
  - You need maximum performance and minimal overhead
  - You're building a very simple server with few routes
  - You want to understand exactly what's happening at a low level
  - You're learning how HTTP works

• Use Express when:
  - You're building a real-world application
  - You need to handle multiple routes and HTTP methods
  - You want to integrate middleware packages
  - You want faster development and better code organization
  - You're working in a team (others will understand Express code)

[END SECTION 1.4]
================================================================================

PART 2: PRIMARY USES OF EXPRESS
================================================================================

SECTION 2.1: EXPRESS FOR BUILDING APIs
---------------------------------------

DEFINITION
----------
Using Express to build APIs means setting up an HTTP interface to interact with 
the data layer. In the case of APIs, data is sent back to the client in JSON 
format using a response object, or res for short.

DETAILED EXPLANATION
--------------------
An API (Application Programming Interface) is a way for different applications 
to communicate with each other. When building APIs with Express, you're creating 
endpoints (URLs) that other applications (or frontend applications) can call to 
get data, create data, update data, or delete data.

KEY CONCEPTS:

1. HTTP INTERFACE
   Express creates an HTTP interface, which means it uses HTTP protocol to 
   communicate. HTTP is the same protocol web browsers use to load web pages, 
   but APIs use it to send and receive data instead of HTML pages.

2. INTERACT WITH THE DATA LAYER
   The data layer is where your application stores and retrieves data (like a 
   database). Express acts as a bridge between clients (who want data) and 
   your data layer (where data is stored).

3. JSON FORMAT
   JSON (JavaScript Object Notation) is a lightweight data format that's easy 
   for both humans and machines to read and write. It's the standard format 
   for APIs because it works with any programming language.

4. RESPONSE OBJECT (res)
   The response object is Express's way of sending data back to the client. 
   It has many methods, but for APIs, res.json() is the most important.

THE res.json() METHOD
---------------------
The res.json method is used to notify the client of the content type of the 
data being sent, such as if it's an image or text. It can also be used to 
Stringify data, in other words, converting JavaScript to JSON format.

Let's break this down:

1. "NOTIFY THE CLIENT OF THE CONTENT TYPE"
   When you send data over HTTP, you need to tell the client what type of data 
   it is. This is done through HTTP headers. res.json() automatically sets the 
   Content-Type header to "application/json", which tells the client "this 
   response contains JSON data."

2. "STRINGIFY DATA"
   JavaScript objects need to be converted to JSON strings before they can be 
   sent over HTTP. This conversion is called "stringifying." res.json() 
   automatically converts JavaScript objects to JSON strings using JSON.stringify().

EXAMPLE: BUILDING AN API WITH EXPRESS
--------------------------------------
const express = require('express');
const app = express();

// Middleware to parse JSON request bodies
app.use(express.json());

// In-memory data store (in real apps, this would be a database)
let users = [
  { id: 1, name: 'Alice', email: 'alice@example.com' },
  { id: 2, name: 'Bob', email: 'bob@example.com' }
];

// GET /users - Retrieve all users
app.get('/users', (req, res) => {
  // res.json() automatically:
  // 1. Sets Content-Type header to "application/json"
  // 2. Converts the JavaScript array to JSON string
  // 3. Sends the response
  res.json(users);
});

// GET /users/:id - Retrieve a specific user
app.get('/users/:id', (req, res) => {
  // req.params.id contains the id from the URL
  const userId = parseInt(req.params.id);
  const user = users.find(u => u.id === userId);
  
  if (user) {
    res.json(user);  // Send the user object as JSON
  } else {
    res.status(404).json({ error: 'User not found' });
  }
});

// POST /users - Create a new user
app.post('/users', (req, res) => {
  // req.body contains the parsed JSON data from the request
  const newUser = {
    id: users.length + 1,
    name: req.body.name,
    email: req.body.email
  };
  
  users.push(newUser);
  
  // Status 201 means "Created"
  res.status(201).json(newUser);
});

// PUT /users/:id - Update a user
app.put('/users/:id', (req, res) => {
  const userId = parseInt(req.params.id);
  const userIndex = users.findIndex(u => u.id === userId);
  
  if (userIndex !== -1) {
    users[userIndex] = { ...users[userIndex], ...req.body };
    res.json(users[userIndex]);
  } else {
    res.status(404).json({ error: 'User not found' });
  }
});

// DELETE /users/:id - Delete a user
app.delete('/users/:id', (req, res) => {
  const userId = parseInt(req.params.id);
  const userIndex = users.findIndex(u => u.id === userId);
  
  if (userIndex !== -1) {
    users.splice(userIndex, 1);
    res.status(204).send();  // 204 means "No Content" (successful deletion)
  } else {
    res.status(404).json({ error: 'User not found' });
  }
});

app.listen(3000, () => {
  console.log('API server running on http://localhost:3000');
});

LINE-BY-LINE EXPLANATION OF THE EXAMPLE:
-----------------------------------------
Line 1: const express = require('express');
        - Imports the Express module so we can use it

Line 2: const app = express();
        - Creates an Express application instance
        - This is the "app class" mentioned in the definition
        - We'll use this app object to define routes

Line 4: app.use(express.json());
        - Adds middleware to parse JSON request bodies
        - Without this, req.body would be undefined
        - This middleware automatically converts incoming JSON strings to JavaScript objects

Line 6-9: let users = [...];
         - Creates an in-memory array to store users
         - In a real application, this would be a database
         - This is our "data layer"

Line 11-15: GET /users endpoint
          - app.get() handles GET requests
          - '/users' is the route path
          - (req, res) => {...} is the handler function
          - req = request object (contains info about the incoming request)
          - res = response object (used to send data back)
          - res.json(users) sends the users array as JSON

Line 17-25: GET /users/:id endpoint
          - ':id' is a route parameter (dynamic part of URL)
          - req.params.id contains the value of :id from the URL
          - parseInt() converts the string ID to a number
          - users.find() searches for a user with matching ID
          - If found, send user; if not, send 404 error

Line 27-37: POST /users endpoint
          - app.post() handles POST requests (used for creating data)
          - req.body contains the parsed JSON data from the request body
          - Creates a new user object with an auto-incremented ID
          - Adds the user to the array
          - res.status(201) sets HTTP status code to 201 (Created)
          - Sends the new user back as JSON

Line 39-49: PUT /users/:id endpoint
          - app.put() handles PUT requests (used for updating data)
          - users.findIndex() finds the position of the user in the array
          - Spread operator (...) merges old user data with new data
          - Updates the user and sends it back

Line 51-60: DELETE /users/:id endpoint
          - app.delete() handles DELETE requests
          - users.splice() removes the user from the array
          - res.status(204).send() sends a 204 status (No Content)
          - 204 is standard for successful deletions

Line 62-64: app.listen(3000, ...)
          - Starts the server on port 3000
          - The callback runs when the server starts
          - Logs a message to confirm the server is running

HOW CLIENTS USE THIS API
------------------------
Once your API is running, clients can interact with it:

GET all users:
  fetch('http://localhost:3000/users')
    .then(res => res.json())
    .then(data => console.log(data));

GET a specific user:
  fetch('http://localhost:3000/users/1')
    .then(res => res.json())
    .then(data => console.log(data));

CREATE a new user:
  fetch('http://localhost:3000/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name: 'Charlie', email: 'charlie@example.com' })
  })
    .then(res => res.json())
    .then(data => console.log(data));

[END SECTION 2.1]
================================================================================

SECTION 2.2: EXPRESS FOR SERVER-SIDE RENDERING (SSR)
------------------------------------------------------

DEFINITION
----------
In Server-side rendering (SSR), Express is used to set up templates. Express is 
responsible for using the data sent from the client supplied by an HTTP request 
in conjunction with the template to dynamically write HTML, CSS, and/or JavaScript. 
The HTML, CSS, and/or JavaScript is sent back to the client as text so that the 
browser can render the page. This is accomplished using the Express res.render 
method.

DETAILED EXPLANATION
--------------------
Server-Side Rendering (SSR) is a different approach from APIs. Instead of 
sending JSON data, Express generates complete HTML pages on the server and sends 
them to the client. The browser receives ready-to-display HTML, CSS, and 
JavaScript.

KEY CONCEPTS:

1. TEMPLATES
   Templates are files that contain HTML with placeholders for dynamic data. 
   Think of them like form letters where you fill in the blanks. Express uses 
   template engines (like EJS, Pug, Handlebars) to process these templates.

2. DYNAMIC CONTENT
   The template contains placeholders (like {{name}} or <%= user.name %>) that 
   get replaced with actual data when the page is requested. This allows the 
   same template to display different data for different users or requests.

3. SERVER-SIDE PROCESSING
   All the work of combining the template with data happens on the server before 
   sending the response. The client (browser) receives a complete, ready-to-render 
   HTML page.

4. res.render() METHOD
   This method takes a template file and data, processes them together, and 
   sends the resulting HTML to the client.

THE res.render() METHOD
-----------------------
The res.render method is used to:
1. Load a template file (like user-profile.ejs)
2. Replace placeholders in the template with actual data
3. Generate the final HTML
4. Send the HTML to the client with proper headers

EXAMPLE: SERVER-SIDE RENDERING WITH EXPRESS
--------------------------------------------
First, let's set up Express with a template engine (we'll use EJS):

// Install EJS: npm install ejs

const express = require('express');
const app = express();

// Tell Express to use EJS as the template engine
app.set('view engine', 'ejs');

// Tell Express where to find template files
app.set('views', './views');

// Sample data (in real apps, this comes from a database)
const users = [
  { id: 1, name: 'Alice', email: 'alice@example.com', role: 'Admin' },
  { id: 2, name: 'Bob', email: 'bob@example.com', role: 'User' },
  { id: 3, name: 'Charlie', email: 'charlie@example.com', role: 'User' }
];

// Route to render the home page
app.get('/', (req, res) => {
  // res.render() processes the template and sends HTML
  // 'index' refers to views/index.ejs
  // { users: users } is the data to inject into the template
  res.render('index', { 
    title: 'User Management System',
    users: users 
  });
});

// Route to render a user profile page
app.get('/users/:id', (req, res) => {
  const userId = parseInt(req.params.id);
  const user = users.find(u => u.id === userId);
  
  if (user) {
    // Render the user-profile template with user data
    res.render('user-profile', { 
      title: `${user.name}'s Profile`,
      user: user 
    });
  } else {
    res.status(404).render('error', { 
      message: 'User not found' 
    });
  }
});

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});

TEMPLATE FILE EXAMPLE (views/index.ejs):
----------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        .user-card {
            border: 1px solid #ddd;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1><%= title %></h1>
    
    <h2>All Users</h2>
    
    <!-- Loop through users array -->
    <% users.forEach(user => { %>
        <div class="user-card">
            <h3><%= user.name %></h3>
            <p>Email: <%= user.email %></p>
            <p>Role: <%= user.role %></p>
            <a href="/users/<%= user.id %>">View Profile</a>
        </div>
    <% }); %>
</body>
</html>

TEMPLATE FILE EXAMPLE (views/user-profile.ejs):
-----------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
</head>
<body>
    <h1><%= user.name %>'s Profile</h1>
    <p><strong>Email:</strong> <%= user.email %></p>
    <p><strong>Role:</strong> <%= user.role %></p>
    <a href="/">Back to Home</a>
</body>
</html>

LINE-BY-LINE EXPLANATION OF THE SSR EXAMPLE:
---------------------------------------------
SERVER CODE:

Line 5: app.set('view engine', 'ejs');
        - Tells Express to use EJS as the template engine
        - EJS (Embedded JavaScript) allows you to write JavaScript in HTML

Line 8: app.set('views', './views');
        - Tells Express where to find template files
        - './views' means the views folder in the current directory

Line 18-22: GET / route
          - When someone visits the homepage (/)
          - res.render('index', { title: ..., users: ... })
          - 'index' refers to views/index.ejs file
          - The object { title: ..., users: ... } is the data passed to the template
          - Express processes the template, replaces placeholders with data, and sends HTML

Line 24-35: GET /users/:id route
          - When someone visits /users/1, /users/2, etc.
          - Finds the user with that ID
          - Renders the user-profile template with that user's data
          - If user not found, renders an error template

TEMPLATE SYNTAX (EJS):
----------------------
• <%= ... %> - Outputs the value (HTML escaped for safety)
• <%- ... %> - Outputs raw HTML (use carefully!)
• <% ... %> - Executes JavaScript code (like loops, conditionals)
• <%# ... %> - Comments (not included in output)

HOW IT WORKS:
-------------
1. User visits http://localhost:3000/users/1
2. Express receives the request
3. Express finds the route handler for GET /users/:id
4. Express extracts the ID (1) from req.params.id
5. Express finds the user with ID 1
6. Express calls res.render('user-profile', { user: ... })
7. Express loads views/user-profile.ejs
8. Express replaces <%= user.name %> with "Alice"
9. Express replaces <%= user.email %> with "alice@example.com"
10. Express generates the final HTML
11. Express sends the HTML to the browser
12. Browser receives complete HTML and displays it

[END SECTION 2.2]
================================================================================

SECTION 2.3: COMPARING APIs AND SSR
------------------------------------

UNDERSTANDING THE DIFFERENCE
-----------------------------
APIs and SSR are two different ways Express can be used. Understanding when to 
use each is crucial for building effective applications.

APIs (Application Programming Interfaces)
------------------------------------------
• Purpose: Provide data to other applications
• Response Format: JSON (JavaScript Object Notation)
• Method Used: res.json()
• Who Uses It: Frontend applications, mobile apps, other servers
• Data Format: Structured data (objects, arrays)
• Client Responsibility: Client must render/display the data

SSR (Server-Side Rendering)
---------------------------
• Purpose: Generate complete HTML pages
• Response Format: HTML (HyperText Markup Language)
• Method Used: res.render()
• Who Uses It: Web browsers (direct users)
• Data Format: Complete web pages with HTML, CSS, JavaScript
• Server Responsibility: Server generates and sends ready-to-display pages

SIDE-BY-SIDE COMPARISON
-----------------------
FEATURE                    | API                    | SSR
---------------------------|------------------------|------------------------
Response Format            | JSON                   | HTML
Method Used                | res.json()             | res.render()
Client Receives            | Data only              | Complete page
Client Must                | Render/display data    | Just display HTML
Best For                   | Mobile apps, SPAs      | Traditional websites
Data Structure             | Objects, arrays        | HTML markup
Template Engine Needed     | No                     | Yes
Frontend Framework         | React, Vue, Angular    | None needed
SEO Friendly               | Requires extra work    | Yes, naturally
Initial Load Speed         | Fast (small JSON)      | Slower (full HTML)
Subsequent Requests        | Fast (only data)       | Full page reload

WHEN TO USE APIs
----------------
Use Express APIs when:
• Building a Single Page Application (SPA) with React, Vue, or Angular
• Creating a mobile app backend
• Building a microservices architecture
• Need to serve data to multiple different clients
• Want separation between frontend and backend teams
• Building a RESTful service

WHEN TO USE SSR
---------------
Use Express SSR when:
• Building a traditional multi-page website
• Need good SEO (Search Engine Optimization)
• Want faster initial page loads
• Building content-heavy sites (blogs, news sites)
• Users don't have JavaScript enabled
• Want simpler architecture (no separate frontend framework)

CAN YOU USE BOTH?
-----------------
Yes! Many applications use both:
• SSR for public pages (homepage, blog posts) - better SEO
• API for interactive features (user dashboard, admin panel) - better UX

Example hybrid approach:
app.get('/', (req, res) => {
  // SSR for homepage
  res.render('index', { posts: getPosts() });
});

app.get('/api/users', (req, res) => {
  // API for user data
  res.json(getUsers());
});

[END SECTION 2.3]
================================================================================

PART 3: THE FIVE-STEP PROCESS FOR WORKING WITH EXPRESS
================================================================================

SECTION 3.1: OVERVIEW OF THE FIVE STEPS
----------------------------------------

THE FIVE STEPS
--------------
Here is an overview of how to work with Express. There are five steps:

STEP 1: Declare Express as a dependency in the package manifest of a Node.js project.
STEP 2: Run the npm command to download any missing modules.
STEP 3: Import the Express module and create an Express application.
STEP 4: Create a new route handler.
STEP 5: Start an HTTP server on a given port number.

UNDERSTANDING THE WORKFLOW
--------------------------
These five steps represent the complete process of setting up an Express 
application from scratch. Each step builds on the previous one:

1. DECLARE DEPENDENCY (Step 1)
   → Tell your project that it needs Express
   → This is done in package.json file

2. INSTALL DEPENDENCIES (Step 2)
   → Download Express and all its dependencies
   → This creates the node_modules folder

3. IMPORT AND CREATE APP (Step 3)
   → Bring Express into your code
   → Create an Express application instance

4. DEFINE ROUTES (Step 4)
   → Tell Express how to handle different URLs
   → This is where you write your application logic

5. START SERVER (Step 5)
   → Make your application listen for incoming requests
   → Your app is now live and accessible

VISUAL REPRESENTATION
---------------------
┌─────────────────────────────────────────────────────────┐
│ STEP 1: Declare Express in package.json                │
│   { "dependencies": { "express": "^4.x" } }            │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│ STEP 2: Run npm install                                 │
│   Downloads Express → node_modules/express/             │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│ STEP 3: Import and create app                          │
│   const express = require('express');                   │
│   const app = express();                                │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│ STEP 4: Create route handlers                          │
│   app.get('/', (req, res) => { ... });                 │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│ STEP 5: Start the server                               │
│   app.listen(3000, () => { ... });                     │
└─────────────────────────────────────────────────────────┘

WHAT WE'LL COVER IN THIS PART
------------------------------
In Part 1 of this comprehensive guide, we'll cover Steps 1 and 2 in detail:
• Step 1: How to create and configure package.json
• Step 1: Understanding all package.json properties
• Step 2: How npm install works
• Step 2: Understanding node_modules directory
• Step 2: Understanding dependency resolution

Steps 3, 4, and 5 will be covered in Part 2 of this guide with complete 
examples and line-by-line explanations.

[END SECTION 3.1]
================================================================================

SECTION 3.2: STEP 1 - DECLARE EXPRESS AS A DEPENDENCY
------------------------------------------------------

OVERVIEW
--------
Step one: declare Express as a dependency in the package manifest of a Node.js 
project. First, to declare Express as a dependency in the package.json file, 
create a package.json file in your project folder.

UNDERSTANDING PACKAGE.JSON
--------------------------
The package.json file stores information about the contents of a Node.js module 
including five items: name, version, description, main, and dependencies.

Think of package.json as a "recipe card" for your Node.js project. It tells 
everyone (and npm) what your project is, what version it is, what it does, 
where to start, and what other packages it needs to work.

THE FIVE PROPERTIES OF PACKAGE.JSON
------------------------------------

1. NAME
   Name is a name for the Node.js module.
   
   DETAILED EXPLANATION:
   • This is the name of your project/module
   • Should be lowercase
   • Can contain hyphens but not spaces
   • Examples: "my-app", "user-api", "temperature-converter"
   • If you publish to npm, this must be unique

2. VERSION
   Version is a string that defines the major and minor version number of the module.
   
   DETAILED EXPLANATION:
   • Follows semantic versioning (semver) format: MAJOR.MINOR.PATCH
   • MAJOR: Breaking changes (incompatible API changes)
   • MINOR: New features (backward compatible)
   • PATCH: Bug fixes (backward compatible)
   • Examples: "1.0.0", "2.5.3", "0.1.0"
   • Start with "1.0.0" for new projects

3. DESCRIPTION
   Description is a sentence that describes the purpose of the module.
   
   DETAILED EXPLANATION:
   • A brief explanation of what your project does
   • Usually one sentence
   • Helps others understand your project quickly
   • Examples: "A REST API for user management", "Weather data retrieval service"

4. MAIN
   Main identifies the Node.js script as the entry point into the module.
   
   DETAILED EXPLANATION:
   • The file that Node.js runs when someone requires your module
   • Usually "index.js" or "app.js" or "server.js"
   • This is the starting point of your application
   • When you run `node .` or `require('your-module')`, Node.js looks for this file

5. DEPENDENCIES
   Dependencies is a list of which Node.js modules that the current module requires.
   
   DETAILED EXPLANATION:
   • Lists all packages your project needs to run
   • Format: "package-name": "version-range"
   • npm will automatically install these when you run `npm install`
   • Examples: "express": "^4.18.2", "cors": "^2.8.5"

EXAMPLE PACKAGE.JSON FILE
--------------------------
Here, in this package.json dependency file, the name of the module is 
temperature. Its version is 1.0.0. Its description is "retrieve current weather 
conditions in the United States." The main script file, which is the entry point 
in the module, is set to app.js. It has a dependency on the Express framework, 
which is version 4.x.

Let's see the complete file:

{
  "name": "temperature",
  "version": "1.0.0",
  "description": "retrieve current weather conditions in the United States.",
  "main": "app.js",
  "dependencies": {
    "express": "^4.x"
  }
}

LINE-BY-LINE EXPLANATION:
--------------------------
Line 1: {
          - Opens the JSON object (package.json is a JSON file)

Line 2: "name": "temperature",
        - Property name: "name"
        - Value: "temperature" (the name of this Node.js module)
        - Comma indicates more properties follow

Line 3: "version": "1.0.0",
        - Property name: "version"
        - Value: "1.0.0" (major version 1, minor version 0, patch 0)
        - This is the first release of the project

Line 4: "description": "retrieve current weather conditions in the United States.",
        - Property name: "description"
        - Value: A sentence describing what this module does
        - Helps developers understand the project's purpose

Line 5: "main": "app.js",
        - Property name: "main"
        - Value: "app.js" (the entry point file)
        - When someone runs this module, Node.js will execute app.js

Line 6: "dependencies": {
        - Property name: "dependencies"
        - Value: An object containing all required packages
        - Opens the dependencies object

Line 7: "express": "^4.x"
        - Package name: "express"
        - Version: "^4.x"
        - The caret (^) means "compatible with version 4.x"
        - This allows npm to install 4.0.0, 4.1.0, 4.18.2, etc., but not 5.0.0
        - The "x" is a wildcard meaning "any minor/patch version"

Line 8: }
        - Closes the dependencies object

Line 9: }
        - Closes the main package.json object

UNDERSTANDING VERSION RANGES
-----------------------------
When declaring Express as a dependency, you specify a version number. Here are 
common version range formats:

• "4.18.2" - Exact version (only install this specific version)
• "^4.18.2" - Compatible version (4.18.2, 4.18.3, 4.19.0, but not 5.0.0)
• "~4.18.2" - Approximately equivalent (4.18.2, 4.18.3, but not 4.19.0)
• "4.x" or "4.*" - Any version in the 4.x series
• "*" - Latest version (not recommended for production)
• "latest" - Latest version (not recommended for production)

HOW TO CREATE PACKAGE.JSON
---------------------------
There are two main ways to create a package.json file:

METHOD 1: MANUAL CREATION
--------------------------
1. Create a new file named "package.json" in your project folder
2. Copy the example above
3. Modify the values to match your project
4. Save the file

METHOD 2: USING NPM INIT (RECOMMENDED)
---------------------------------------
Run this command in your project folder:
  npm init

npm will ask you questions and create package.json automatically:
  ? package name: (your-project-name)
  ? version: (1.0.0)
  ? description: (Your project description)
  ? entry point: (index.js) app.js
  ? test command: (press enter to skip)
  ? git repository: (press enter to skip)
  ? keywords: (press enter to skip)
  ? author: (press enter to skip)
  ? license: (ISC) (press enter to accept)

Then manually add Express to dependencies:
  npm install express --save

Or edit package.json and add:
  "dependencies": {
    "express": "^4.x"
  }

COMPLETE EXAMPLE: CREATING PACKAGE.JSON FOR A NEW PROJECT
-----------------------------------------------------------
Let's say you're creating a blog API. Here's what your package.json might look 
like:

{
  "name": "blog-api",
  "version": "1.0.0",
  "description": "REST API for managing blog posts and comments",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "keywords": ["blog", "api", "express", "rest"],
  "author": "Your Name",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3"
  }
}

ADDITIONAL PROPERTIES EXPLAINED:
--------------------------------
• "scripts": Commands you can run with `npm run <script-name>`
  - "start": Runs when you type `npm start`
  - "dev": Runs when you type `npm run dev` (uses nodemon for auto-restart)

• "keywords": Helps others find your package on npm
• "author": Your name or organization
• "license": Legal license (MIT, ISC, etc.)

[END SECTION 3.2]
================================================================================

SECTION 3.3: STEP 2 - RUN NPM INSTALL
--------------------------------------

OVERVIEW
--------
In step 2, you run the npm command to download any missing modules. When you 
run the npm install command inside the Node.js module directory, it resolves 
any missing dependent Node.js modules. The command downloads and saves any 
missing Node.js modules into its own node_module directory.

UNDERSTANDING NPM INSTALL
-------------------------
npm (Node Package Manager) is the package manager that comes with Node.js. 
It's used to install, manage, and share JavaScript packages. The `npm install` 
command reads your package.json file and downloads all the packages listed in 
the dependencies.

HOW NPM INSTALL WORKS
---------------------
When you run the command npm install with no parameters, the npm application 
scans your package.json file. It checks your node_module directory to see if 
any modules are missing. In this case, the Express web application framework 
is not in your current installation. The npm application downloads the Express 
framework and all of its dependent modules.

STEP-BY-STEP PROCESS:
---------------------
1. You run: npm install
2. npm reads package.json
3. npm checks the "dependencies" section
4. npm checks if node_modules folder exists
5. npm checks which packages are already installed
6. npm downloads missing packages from the npm registry
7. npm also downloads dependencies of those packages (transitive dependencies)
8. npm saves everything in node_modules folder
9. npm creates/updates package-lock.json file

THE NODE_MODULES DIRECTORY
---------------------------
This scheme allows you to use different versions of the same Node.js module in 
different packages. For example, a custom Node.js module installs a version 
4.0 release of the Express framework. Another Node.js module installs version 
5.0 in its own Node module repository.

UNDERSTANDING THIS CONCEPT:
----------------------------
Each Node.js project has its own node_modules folder. This means:
• Project A can use Express 4.x
• Project B can use Express 5.x
• They don't conflict with each other
• Each project is isolated

This is different from global installations (which we'll discuss later).

VISUAL REPRESENTATION:
---------------------
Project Structure After npm install:

my-project/
├── package.json          (declares dependencies)
├── package-lock.json     (locks exact versions)
└── node_modules/         (contains installed packages)
    ├── express/          (Express framework)
    │   ├── package.json
    │   ├── index.js
    │   └── node_modules/ (Express's dependencies)
    │       ├── accepts/
    │       ├── array-flatten/
    │       └── ... (many more)
    └── ... (other packages if you have more)

COMMAND VARIATIONS
------------------

1. npm install
   • Installs all packages listed in package.json
   • Reads dependencies and devDependencies
   • Creates node_modules if it doesn't exist
   • Updates package-lock.json

2. npm install express
   • Installs Express specifically
   • Adds it to package.json dependencies (with --save flag, which is default)
   • Also installs Express's dependencies

3. npm install express --save
   • Same as above (--save is default in npm 5+)
   • Explicitly adds to dependencies

4. npm install express --save-dev
   • Installs Express as a dev dependency
   • Only needed during development, not in production
   • Goes in "devDependencies" instead of "dependencies"

5. npm install -g express
   • Installs Express globally (not recommended for Express)
   • Installs to a shared location
   • Available to all projects on your system
   • Use sparingly (mostly for CLI tools)

UNDERSTANDING DEPENDENCY RESOLUTION
-----------------------------------
When npm installs Express, it doesn't just install Express. It also installs 
all of Express's dependencies, and their dependencies, and so on. This is called 
"dependency resolution" or "dependency tree."

EXAMPLE DEPENDENCY TREE:
------------------------
When you install Express, npm also installs:
• Express (what you asked for)
  └── accepts (Express needs this)
      └── mime-types (accepts needs this)
          └── mime-db (mime-types needs this)
  └── array-flatten (Express needs this)
  └── body-parser (Express needs this)
      └── bytes (body-parser needs this)
      └── content-type (body-parser needs this)
  └── ... (many more)

npm automatically figures out all these dependencies and installs them.

PACKAGE-LOCK.JSON
-----------------
When npm installs packages, it also creates or updates a file called 
package-lock.json. This file:
• Locks the exact versions of all installed packages
• Ensures everyone on your team gets the same versions
• Makes installations faster (npm knows exactly what to install)
• Should be committed to version control (Git)

EXAMPLE PACKAGE-LOCK.JSON STRUCTURE:
-------------------------------------
{
  "name": "temperature",
  "version": "1.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "name": "temperature",
      "version": "1.0.0",
      "dependencies": {
        "express": "^4.18.2"
      }
    },
    "node_modules/express": {
      "version": "4.18.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.18.2.tgz",
      "integrity": "sha512-5/PsL6iGPdfQ/lKM1UuielYgv3BUoJfz1aUwU9vHZ+J7gyvwdQXFEBIEIaxeGf0GIcreATNyBExtalisDbuMqQ==",
      "dependencies": {
        "accepts": "~1.3.8",
        "array-flatten": "1.1.1",
        ...
      }
    }
  }
}

COMPLETE EXAMPLE: INSTALLING EXPRESS
-------------------------------------
Let's walk through a complete example:

STEP 1: Create project folder
  mkdir my-express-app
  cd my-express-app

STEP 2: Create package.json
  {
    "name": "my-express-app",
    "version": "1.0.0",
    "description": "My first Express application",
    "main": "app.js",
    "dependencies": {
      "express": "^4.x"
    }
  }

STEP 3: Run npm install
  npm install

STEP 4: What happens:
  ✓ npm reads package.json
  ✓ npm checks for node_modules (doesn't exist, so creates it)
  ✓ npm downloads Express from npm registry
  ✓ npm downloads all Express dependencies
  ✓ npm saves everything to node_modules/
  ✓ npm creates package-lock.json

STEP 5: Verify installation
  ls node_modules/express
  (You should see Express files)

INSTALLATION OUTPUT EXAMPLE:
-----------------------------
When you run npm install, you'll see output like:

npm notice created a lockfile as package-lock.json. You should commit this file.
npm WARN my-express-app@1.0.0 No repository field.

added 57 packages, and audited 58 packages in 3s

6 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

This tells you:
• package-lock.json was created
• 57 packages were installed (Express + all dependencies)
• No security vulnerabilities found
• Installation completed successfully

TROUBLESHOOTING COMMON ISSUES
------------------------------

ISSUE 1: "npm: command not found"
  SOLUTION: Node.js/npm is not installed. Download from nodejs.org

ISSUE 2: "EACCES: permission denied"
  SOLUTION: Don't use sudo. If needed, fix npm permissions or use a node version manager

ISSUE 3: "npm ERR! network"
  SOLUTION: Check your internet connection or npm registry settings

ISSUE 4: "npm ERR! code ELIFECYCLE"
  SOLUTION: Delete node_modules and package-lock.json, then run npm install again

VERIFYING INSTALLATION
----------------------
After running npm install, verify Express is installed:

METHOD 1: Check node_modules folder
  ls node_modules/express
  (Should show Express files)

METHOD 2: Check package-lock.json
  cat package-lock.json | grep express
  (Should show Express entry)

METHOD 3: Try requiring it (we'll do this in Step 3)
  node -e "console.log(require('express'))"
  (Should output Express function, not an error)

[END SECTION 3.3]
================================================================================

SUMMARY OF PART 1
==================

KEY CONCEPTS COVERED:
---------------------
1. Express is a web application framework built on Node.js that abstracts 
   low-level details

2. Express has two primary uses:
   • Building APIs (using res.json())
   • Server-side rendering (using res.render())

3. Express differs from Node.js core HTTP by providing:
   • Automatic routing
   • Middleware system
   • Simplified request/response handling
   • Better code organization

4. The five-step process for working with Express:
   • Step 1: Declare Express in package.json
   • Step 2: Run npm install
   • Step 3: Import Express and create app (covered in Part 2)
   • Step 4: Create route handlers (covered in Part 2)
   • Step 5: Start the server (covered in Part 2)

5. package.json contains five key properties:
   • name: Project name
   • version: Version number
   • description: What the project does
   • main: Entry point file
   • dependencies: Required packages

6. npm install:
   • Reads package.json
   • Downloads missing packages
   • Creates node_modules folder
   • Each project has its own isolated dependencies

WHAT'S NEXT?
------------
In Part 2 of this comprehensive guide, we'll cover:
• Step 3: Importing Express and creating an application
• Step 4: Creating route handlers with detailed examples
• Step 5: Starting the HTTP server
• Complete working Express application examples
• Line-by-line code explanations
• Best practices and common patterns
• Summary and quick reference guide

[END OF PART 1]
================================================================================

