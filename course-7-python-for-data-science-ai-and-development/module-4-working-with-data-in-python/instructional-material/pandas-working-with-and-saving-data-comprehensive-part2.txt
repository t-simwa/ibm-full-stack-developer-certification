================================================================================
PANDAS: WORKING WITH AND SAVING DATA
Comprehensive Study Guide - Part 2
================================================================================

WELCOME TO PART 2
-----------------
This is Part 2 of the comprehensive study guide on Pandas: Working with and 
Saving Data. In Part 1, you learned about finding unique values in DataFrame 
columns using the unique() method. 

In Part 2, you will learn:
• How to filter DataFrames based on conditions
• Using Boolean indexing in pandas
• Working with comparison operators
• Creating new DataFrames from filtered data
• Saving DataFrames to CSV files
• Other file formats for saving DataFrames

================================================================================
TABLE OF CONTENTS - PART 2
================================================================================

PART 2: FILTERING DATA AND SAVING DATAFRAMES
  SECTION 2.1: INTRODUCTION TO FILTERING DATA
  SECTION 2.2: UNDERSTANDING BOOLEAN INDEXING
  SECTION 2.3: USING COMPARISON OPERATORS WITH DATAFRAMES
  SECTION 2.4: CREATING FILTERED DATAFRAMES - STEP BY STEP
  SECTION 2.5: COMPLETE EXAMPLE - FILTERING ALBUMS BY YEAR
  SECTION 2.6: SAVING DATAFRAMES TO CSV FILES
  SECTION 2.7: OTHER FILE FORMATS FOR SAVING DATAFRAMES
  SECTION 2.8: SUMMARY AND KEY TAKEAWAYS

NOTE: Part 1 of this guide covers:
  • Introduction to working with DataFrames
  • Understanding unique values in data
  • The unique() method and its usage
  • Practical examples with unique() method

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 2.3:") to quickly jump to any section.

================================================================================
PART 2: FILTERING DATA AND SAVING DATAFRAMES
================================================================================

SECTION 2.1: INTRODUCTION TO FILTERING DATA
--------------------------------------------

DEFINITION
----------
Filtering data means selecting specific rows from a DataFrame based on certain 
conditions. When you filter a DataFrame, you create a new DataFrame that 
contains only the rows that meet your specified criteria.

DETAILED EXPLANATION
--------------------
Let's say you would like to create a new database (DataFrame) consisting of 
songs from the 1980s and after. To do this, you need to:
1. Look at the column "Released" for songs made after 1979
2. Select the corresponding rows that meet this condition
3. Create a new DataFrame with only those rows

WHY FILTER DATA?
----------------
Filtering is one of the most common operations in data analysis because:
• You rarely need all the data at once
• You want to focus on specific subsets
• You need to clean data (remove unwanted rows)
• You want to analyze specific time periods, categories, or ranges
• You need to prepare data for specific analyses

REAL-WORLD ANALOGY
------------------
Think of filtering like using a search filter on an online store:
• You have thousands of products (rows in DataFrame)
• You want only products from a specific brand (condition)
• You apply a filter (Boolean indexing)
• You get a smaller list with only matching products (filtered DataFrame)

THE PROCESS OF FILTERING
-------------------------
Filtering in pandas typically involves three steps:
1. CREATE A CONDITION
   • Use comparison operators (>, <, ==, etc.)
   • Apply to a column
   • Results in a Series of True/False values

2. APPLY THE CONDITION
   • Use Boolean indexing
   • Pass the True/False Series to the DataFrame
   • Selects only rows where condition is True

3. CREATE NEW DATAFRAME
   • Assign the filtered result to a new variable
   • Original DataFrame remains unchanged

WHAT IS BOOLEAN INDEXING?
--------------------------
Boolean indexing is a powerful pandas feature that allows you to select rows 
based on True/False conditions. It's called "Boolean" because it uses Boolean 
values (True and False) to determine which rows to include.

[END SECTION 2.1]
================================================================================

SECTION 2.2: UNDERSTANDING BOOLEAN INDEXING
--------------------------------------------

DEFINITION
----------
Boolean indexing is a method of selecting rows from a DataFrame using a Series 
of Boolean (True/False) values. When you use Boolean indexing, pandas selects 
only the rows where the corresponding Boolean value is True.

DETAILED EXPLANATION
--------------------
Boolean indexing works like this:
1. You create a condition that evaluates to True or False for each row
2. This creates a Series of Boolean values (one for each row)
3. You use this Boolean Series to filter the DataFrame
4. Only rows with True values are included in the result

HOW BOOLEAN INDEXING WORKS
---------------------------
When you apply a condition to a DataFrame column, pandas evaluates that 
condition for every single row. The result is a Series where:
• Each position corresponds to a row in the DataFrame
• The value is True if the condition is met for that row
• The value is False if the condition is not met for that row

EXAMPLE OF BOOLEAN SERIES CREATION
-----------------------------------
Let's say we have a DataFrame with release years:

    import pandas as pd
    
    df = pd.DataFrame({
        'Album': ['Album1', 'Album2', 'Album3', 'Album4'],
        'Released': [1975, 1980, 1985, 1990]
    })
    
    # Create a Boolean condition
    condition = df['Released'] > 1979
    print(condition)

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: import pandas as pd
    • Imports pandas library

Line 2: (blank line)

Line 3: df = pd.DataFrame({
    • Creates a DataFrame

Line 4-5: Column definitions
    • 'Album' column with album names
    • 'Released' column with years: [1975, 1980, 1985, 1990]

Line 6: })
    • Closes DataFrame

Line 7: (blank line)

Line 8: # Create a Boolean condition
    • Comment

Line 9: condition = df['Released'] > 1979
    • df['Released'] = Selects the Released column
        - Values: [1975, 1980, 1985, 1990]
    • > 1979 = Comparison operator "greater than 1979"
    • For each value, checks if it's greater than 1979:
        - 1975 > 1979? → False
        - 1980 > 1979? → True
        - 1985 > 1979? → True
        - 1990 > 1979? → True
    • Result: Series([False, True, True, True])

Line 10: print(condition)
    • Displays the Boolean Series
    • Output shows True/False for each row

EXPECTED OUTPUT:
----------------
0    False
1     True
2     True
3     True
Name: Released, dtype: bool

UNDERSTANDING THE OUTPUT
-------------------------
The output shows:
• 0, 1, 2, 3 = Row indices (positions in DataFrame)
• False, True, True, True = Boolean values for each row
• Name: Released = The column name that was used
• dtype: bool = Data type is Boolean

WHAT THIS MEANS:
• Row 0 (1975): False → Does NOT meet condition (not > 1979)
• Row 1 (1980): True → Meets condition (> 1979)
• Row 2 (1985): True → Meets condition (> 1979)
• Row 3 (1990): True → Meets condition (> 1979)

USING BOOLEAN SERIES TO FILTER
-------------------------------
Once you have a Boolean Series, you can use it to filter the DataFrame:

    filtered_df = df[condition]

This expression:
• df = The original DataFrame
• [condition] = Square brackets with the Boolean Series
• Selects only rows where condition is True
• Creates a new DataFrame with filtered rows

REAL-WORLD ANALOGY
------------------
Think of Boolean indexing like a bouncer at a club:
• The bouncer has a list of people (DataFrame rows)
• Each person has a characteristic (column value)
• The bouncer checks: "Are you over 21?" (condition)
• Creates a mental list: True/False for each person (Boolean Series)
• Only lets in people marked True (filtered DataFrame)

[END SECTION 2.2]
================================================================================

SECTION 2.3: USING COMPARISON OPERATORS WITH DATAFRAMES
--------------------------------------------------------

DEFINITION
----------
We can use inequality operators (and other comparison operators) for the entire 
DataFrame in pandas. The result is a Series of Boolean values. The result is 
True when the condition is true and False otherwise.

DETAILED EXPLANATION
--------------------
Pandas supports all standard comparison operators:
• > (greater than)
• < (less than)
• >= (greater than or equal to)
• <= (less than or equal to)
• == (equal to)
• != (not equal to)

HOW COMPARISON OPERATORS WORK WITH DATAFRAMES
---------------------------------------------
When you use a comparison operator on a DataFrame column:
1. The operator is applied to every value in the column
2. Each value is compared to the specified value
3. The result is a Boolean Series (True/False for each row)
4. This Boolean Series can then be used for filtering

EXAMPLE: GREATER THAN OPERATOR (>)
-----------------------------------
For our case, we simply specify the column "Released" and the inequality for 
albums after 1979:

    import pandas as pd
    
    df = pd.DataFrame({
        'Album': ['Album1', 'Album2', 'Album3', 'Album4', 'Album5'],
        'Released': [1975, 1980, 1985, 1978, 1990]
    })
    
    # Create Boolean condition: albums released after 1979
    condition = df['Released'] > 1979
    print("Condition (Boolean Series):")
    print(condition)
    print("\nOriginal DataFrame:")
    print(df)

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: import pandas as pd
    • Imports pandas

Line 2: (blank line)

Line 3: df = pd.DataFrame({
    • Creates DataFrame

Line 4-5: Column definitions
    • Released column: [1975, 1980, 1985, 1978, 1990]

Line 6: })
    • Closes DataFrame

Line 7: (blank line)

Line 8: # Create Boolean condition: albums released after 1979
    • Comment explaining the condition

Line 9: condition = df['Released'] > 1979
    • df['Released'] = Selects Released column
        - Values: [1975, 1980, 1985, 1978, 1990]
    • > 1979 = Greater than operator with value 1979
    • Evaluates each value:
        - 1975 > 1979? → False
        - 1980 > 1979? → True
        - 1985 > 1979? → True
        - 1978 > 1979? → False
        - 1990 > 1979? → True
    • Result: Series([False, True, True, False, True])

Line 10-12: Print statements
    • Display the Boolean Series and original DataFrame

EXPECTED OUTPUT:
----------------
Condition (Boolean Series):
0    False
1     True
2     True
3    False
4     True
Name: Released, dtype: bool

Original DataFrame:
    Album  Released
0  Album1      1975
1  Album2      1980
2  Album3      1985
3  Album4      1978
4  Album5      1990

OTHER COMPARISON OPERATORS
---------------------------
Let's see examples of other comparison operators:

EXAMPLE 1: LESS THAN OPERATOR (<)
----------------------------------
    # Find albums released before 1980
    condition_before_1980 = df['Released'] < 1980
    print("Albums before 1980:")
    print(condition_before_1980)

Explanation:
• < 1980 = Less than operator
• Evaluates: [1975 < 1980? True, 1980 < 1980? False, ...]
• Result: Series([True, False, False, True, False])

EXAMPLE 2: GREATER THAN OR EQUAL TO (>=)
-----------------------------------------
    # Find albums released in 1980 or after
    condition_1980_or_after = df['Released'] >= 1980
    print("Albums from 1980 or after:")
    print(condition_1980_or_after)

Explanation:
• >= 1980 = Greater than or equal to operator
• Evaluates: [1975 >= 1980? False, 1980 >= 1980? True, ...]
• Result: Series([False, True, True, False, True])

EXAMPLE 3: EQUAL TO OPERATOR (==)
----------------------------------
    # Find albums released exactly in 1980
    condition_exactly_1980 = df['Released'] == 1980
    print("Albums from exactly 1980:")
    print(condition_exactly_1980)

Explanation:
• == 1980 = Equal to operator (note: double equals, not single)
• Evaluates: [1975 == 1980? False, 1980 == 1980? True, ...]
• Result: Series([False, True, False, False, False])

EXAMPLE 4: NOT EQUAL TO OPERATOR (!=)
--------------------------------------
    # Find albums NOT released in 1980
    condition_not_1980 = df['Released'] != 1980
    print("Albums NOT from 1980:")
    print(condition_not_1980)

Explanation:
• != 1980 = Not equal to operator
• Evaluates: [1975 != 1980? True, 1980 != 1980? False, ...]
• Result: Series([True, False, True, True, True])

COMBINING CONDITIONS
--------------------
You can combine multiple conditions using:
• & (AND operator) - both conditions must be True
• | (OR operator) - at least one condition must be True
• ~ (NOT operator) - reverses the condition

EXAMPLE: COMBINING CONDITIONS WITH AND (&)
-------------------------------------------
    # Albums released after 1979 AND before 1990
    condition = (df['Released'] > 1979) & (df['Released'] < 1990)
    print("Albums from 1980-1989:")
    print(condition)

Explanation:
• (df['Released'] > 1979) = First condition (after 1979)
• & = AND operator (both must be True)
• (df['Released'] < 1990) = Second condition (before 1990)
• Parentheses are required around each condition
• Result: True only where both conditions are True

IMPORTANT NOTES ABOUT COMPARISON OPERATORS
------------------------------------------
1. PARENTHESES ARE IMPORTANT
   • When combining conditions, use parentheses: (condition1) & (condition2)
   • Without parentheses, you may get unexpected results

2. DOUBLE EQUALS FOR EQUALITY
   • Use == for equality comparison (not =)
   • = is for assignment, == is for comparison

3. OPERATORS WORK ELEMENT-WISE
   • Each value in the column is compared individually
   • Result is a Boolean value for each row

4. PRESERVES INDEX
   • The Boolean Series keeps the same index as the original DataFrame
   • This allows proper alignment when filtering

[END SECTION 2.3]
================================================================================

SECTION 2.4: CREATING FILTERED DATAFRAMES - STEP BY STEP
---------------------------------------------------------

DEFINITION
----------
We can select the specified rows in one line. We simply use the DataFrame's 
name and square brackets, place the previously mentioned inequality (Boolean 
condition), and assign it to a variable. We now have a new DataFrame where 
each row meets the specified condition.

DETAILED EXPLANATION
--------------------
Creating a filtered DataFrame is a two-step process that can be done in one 
line:
1. Create a Boolean condition (inequality or comparison)
2. Use that condition to filter the DataFrame
3. Assign the result to a new variable

THE ONE-LINE APPROACH
---------------------
You can accomplish filtering within one line of code in pandas. However, 
let's break up the steps to understand what's happening.

STEP-BY-STEP BREAKDOWN
----------------------
Let's say we want to create a new DataFrame consisting of songs from the 1980s 
and after (released after 1979).

STEP 1: CREATE THE BOOLEAN CONDITION
------------------------------------
    condition = df['Released'] > 1979

This creates a Boolean Series where:
• True = Row meets condition (released after 1979)
• False = Row doesn't meet condition (released in 1979 or earlier)

STEP 2: USE THE CONDITION TO FILTER
------------------------------------
    df1 = df[condition]

This expression:
• df = The original DataFrame
• [condition] = Square brackets with the Boolean Series
• Selects only rows where condition is True
• Creates a new DataFrame with filtered rows
• df1 = Variable name for the new filtered DataFrame

STEP 3: COMBINE INTO ONE LINE (OPTIONAL)
-----------------------------------------
    df1 = df[df['Released'] > 1979]

This combines both steps:
• df['Released'] > 1979 = Creates Boolean condition
• df[...] = Uses condition to filter
• df1 = Stores the result

WHAT HAPPENS TO THE ORIGINAL DATAFRAME?
---------------------------------------
Important: The original DataFrame (df) remains unchanged! Filtering creates 
a new DataFrame, it doesn't modify the original.

COMPLETE EXAMPLE WITH EXPLANATION
----------------------------------
    import pandas as pd
    
    # Create original DataFrame
    df = pd.DataFrame({
        'Album': ['Thriller', 'Back in Black', 'The Dark Side of the Moon', 
                  'The Bodyguard', 'Bat Out of Hell'],
        'Released': [1982, 1980, 1973, 1992, 1977],
        'Artist': ['Michael Jackson', 'AC/DC', 'Pink Floyd', 
                   'Whitney Houston', 'Meat Loaf']
    })
    
    # Method 1: Two-step approach (easier to understand)
    condition = df['Released'] > 1979
    df1 = df[condition]
    
    # Method 2: One-line approach (more concise)
    df1 = df[df['Released'] > 1979]
    
    print("Original DataFrame:")
    print(df)
    print("\nFiltered DataFrame (albums after 1979):")
    print(df1)

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: import pandas as pd
    • Imports pandas library

Line 2: (blank line)

Line 3: # Create original DataFrame
    • Comment

Line 4: df = pd.DataFrame({
    • Creates DataFrame variable 'df'

Line 5-7: Column definitions
    • 'Album': Album names
    • 'Released': Release years [1982, 1980, 1973, 1992, 1977]
    • 'Artist': Artist names

Line 8: })
    • Closes DataFrame

Line 9: (blank line)

Line 10: # Method 1: Two-step approach (easier to understand)
    • Comment explaining Method 1

Line 11: condition = df['Released'] > 1979
    • Creates Boolean condition
    • Evaluates each year:
        - 1982 > 1979? → True
        - 1980 > 1979? → True
        - 1973 > 1979? → False
        - 1992 > 1979? → True
        - 1977 > 1979? → False
    • Result: Series([True, True, False, True, False])

Line 12: df1 = df[condition]
    • df = Original DataFrame
    • [condition] = Boolean Series for filtering
    • Selects rows where condition is True (rows 0, 1, 3)
    • Creates new DataFrame with 3 rows
    • Assigns to variable df1

Line 13: (blank line)

Line 14: # Method 2: One-line approach (more concise)
    • Comment explaining Method 2

Line 15: df1 = df[df['Released'] > 1979]
    • Combines condition creation and filtering
    • df['Released'] > 1979 = Creates Boolean condition inline
    • df[...] = Filters DataFrame
    • df1 = Stores filtered result

Line 16: (blank line)

Line 17-20: Print statements
    • Display original and filtered DataFrames

EXPECTED OUTPUT:
----------------
Original DataFrame:
                  Album  Released           Artist
0              Thriller      1982  Michael Jackson
1         Back in Black      1980            AC/DC
2  The Dark Side of the Moon      1973       Pink Floyd
3          The Bodyguard      1992   Whitney Houston
4        Bat Out of Hell      1977          Meat Loaf

Filtered DataFrame (albums after 1979):
         Album  Released           Artist
0      Thriller      1982  Michael Jackson
1  Back in Black      1980            AC/DC
3  The Bodyguard      1992   Whitney Houston

NOTICE:
• Original DataFrame has 5 rows
• Filtered DataFrame has 3 rows
• Rows with Released > 1979 are included (1982, 1980, 1992)
• Rows with Released <= 1979 are excluded (1973, 1977)
• Row indices are preserved (0, 1, 3 - note: 2 and 4 are missing)

UNDERSTANDING THE RESULT
------------------------
The filtered DataFrame (df1) contains:
• Only albums released after 1979
• All columns from the original DataFrame
• Preserved row indices (though some are missing)
• A new DataFrame that doesn't affect the original

[END SECTION 2.4]
================================================================================

SECTION 2.5: COMPLETE EXAMPLE - FILTERING ALBUMS BY YEAR
----------------------------------------------------------

Let's work through a complete, realistic example that demonstrates the entire 
process from start to finish:

    import pandas as pd
    
    # Step 1: Create a sample DataFrame with album data
    df = pd.DataFrame({
        'Album': ['Thriller', 'Back in Black', 'The Dark Side of the Moon', 
                  'The Bodyguard', 'Bat Out of Hell', 'Their Greatest Hits',
                  'Saturday Night Fever', 'Rumours', 'Grease'],
        'Released': [1982, 1980, 1973, 1992, 1977, 1976, 1977, 1977, 1978],
        'Artist': ['Michael Jackson', 'AC/DC', 'Pink Floyd', 
                   'Whitney Houston', 'Meat Loaf', 'Eagles',
                   'Bee Gees', 'Fleetwood Mac', 'Various Artists'],
        'Genre': ['Pop', 'Rock', 'Rock', 'Pop', 'Rock', 'Rock', 
                  'Disco', 'Rock', 'Soundtrack']
    })
    
    # Step 2: Display the original DataFrame
    print("=" * 60)
    print("ORIGINAL DATAFRAME")
    print("=" * 60)
    print(df)
    print(f"\nTotal albums: {len(df)}")
    
    # Step 3: Find unique release years
    unique_years = df['Released'].unique()
    print(f"\nUnique release years: {sorted(unique_years)}")
    
    # Step 4: Create Boolean condition for albums after 1979
    print("\n" + "=" * 60)
    print("CREATING BOOLEAN CONDITION")
    print("=" * 60)
    condition = df['Released'] > 1979
    print("Boolean condition (df['Released'] > 1979):")
    print(condition)
    print("\nExplanation:")
    print("- True means the album was released after 1979")
    print("- False means the album was released in 1979 or earlier")
    
    # Step 5: Create filtered DataFrame
    print("\n" + "=" * 60)
    print("CREATING FILTERED DATAFRAME")
    print("=" * 60)
    df1 = df[condition]
    print("Filtered DataFrame (albums released after 1979):")
    print(df1)
    print(f"\nFiltered albums count: {len(df1)}")
    print(f"Albums removed: {len(df) - len(df1)}")
    
    # Step 6: Show which albums were included/excluded
    print("\n" + "=" * 60)
    print("ANALYSIS")
    print("=" * 60)
    print("Albums INCLUDED (released after 1979):")
    included = df[df['Released'] > 1979]
    for idx, row in included.iterrows():
        print(f"  - {row['Album']} ({row['Released']}) by {row['Artist']}")
    
    print("\nAlbums EXCLUDED (released in 1979 or earlier):")
    excluded = df[df['Released'] <= 1979]
    for idx, row in excluded.iterrows():
        print(f"  - {row['Album']} ({row['Released']}) by {row['Artist']}")

LINE-BY-LINE EXPLANATION:
-------------------------
Lines 1-2: Import and blank line
    • Standard pandas import

Lines 3-4: Comment and DataFrame creation
    • Creates a larger sample dataset
    • 9 albums with various release years

Lines 5-10: Column definitions
    • 'Album': 9 album names
    • 'Released': Years [1982, 1980, 1973, 1992, 1977, 1976, 1977, 1977, 1978]
    • 'Artist': Artist names
    • 'Genre': Music genres

Lines 11: Closes DataFrame

Lines 13-16: Display original DataFrame
    • "=" * 60 creates a separator line
    • Shows all data
    • Displays total count

Lines 18-20: Find unique years
    • Uses unique() method from Part 1
    • sorted() arranges years in order
    • Shows what years are represented

Lines 22-28: Create and display Boolean condition
    • Creates condition for albums after 1979
    • Shows the Boolean Series
    • Explains what True/False mean

Lines 30-37: Create filtered DataFrame
    • Applies condition to filter
    • Shows filtered result
    • Displays statistics

Lines 39-52: Analysis section
    • Shows which albums were included
    • Shows which albums were excluded
    • Uses iterrows() to loop through rows
    • Provides clear summary

EXPECTED OUTPUT:
----------------
============================================================
ORIGINAL DATAFRAME
============================================================
                  Album  Released           Artist      Genre
0              Thriller      1982  Michael Jackson       Pop
1         Back in Black      1980            AC/DC      Rock
2  The Dark Side of the Moon      1973       Pink Floyd      Rock
3          The Bodyguard      1992   Whitney Houston       Pop
4        Bat Out of Hell      1977          Meat Loaf      Rock
5      Their Greatest Hits      1976            Eagles      Rock
6  Saturday Night Fever      1977          Bee Gees     Disco
7               Rumours      1977    Fleetwood Mac      Rock
8                Grease      1978  Various Artists Soundtrack

Total albums: 9

Unique release years: [1973, 1976, 1977, 1978, 1980, 1982, 1992]

============================================================
CREATING BOOLEAN CONDITION
============================================================
Boolean condition (df['Released'] > 1979):
0     True
1     True
2    False
3     True
4    False
5    False
6    False
7    False
8    False
Name: Released, dtype: bool

Explanation:
- True means the album was released after 1979
- False means the album was released in 1979 or earlier

============================================================
CREATING FILTERED DATAFRAME
============================================================
Filtered DataFrame (albums released after 1979):
         Album  Released           Artist Genre
0      Thriller      1982  Michael Jackson  Pop
1  Back in Black      1980            AC/DC Rock
3  The Bodyguard      1992   Whitney Houston  Pop

Filtered albums count: 3
Albums removed: 6

============================================================
ANALYSIS
============================================================
Albums INCLUDED (released after 1979):
  - Thriller (1982) by Michael Jackson
  - Back in Black (1980) by AC/DC
  - The Bodyguard (1992) by Whitney Houston

Albums EXCLUDED (released in 1979 or earlier):
  - The Dark Side of the Moon (1973) by Pink Floyd
  - Bat Out of Hell (1977) by Meat Loaf
  - Their Greatest Hits (1976) by Eagles
  - Saturday Night Fever (1977) by Bee Gees
  - Rumours (1977) by Fleetwood Mac
  - Grease (1978) by Various Artists

KEY OBSERVATIONS
-----------------
1. Original DataFrame: 9 albums
2. Filtered DataFrame: 3 albums (only those after 1979)
3. The condition correctly identified albums from 1980, 1982, and 1992
4. All albums from 1979 and earlier were excluded
5. The original DataFrame remains unchanged (we could still use 'df')

[END SECTION 2.5]
================================================================================

SECTION 2.6: SAVING DATAFRAMES TO CSV FILES
--------------------------------------------

DEFINITION
----------
We can save the new DataFrame using the method to_csv(). The argument is the 
name of the CSV file. Make sure you include a .csv extension.

DETAILED EXPLANATION
--------------------
After filtering and processing your data, you often want to save the results 
for future use. The to_csv() method allows you to save a DataFrame to a CSV 
(Comma-Separated Values) file, which is a simple text format that can be 
opened in Excel, text editors, or imported into other programs.

WHAT IS A CSV FILE?
-------------------
CSV stands for Comma-Separated Values:
• Simple text format
• Each row is a line in the file
• Values are separated by commas
• First row usually contains column names (headers)
• Can be opened in Excel, Google Sheets, text editors
• Universal format supported by many programs

BASIC SYNTAX
------------
The basic syntax for saving a DataFrame to CSV is:

    dataframe_name.to_csv('filename.csv')

Breaking down the syntax:
• dataframe_name = The name of your DataFrame variable
• .to_csv() = The method that saves to CSV format
• 'filename.csv' = The name of the file (in quotes, with .csv extension)
• The file will be saved in the current working directory

COMPLETE EXAMPLE: SAVING A FILTERED DATAFRAME
----------------------------------------------
    import pandas as pd
    
    # Create and filter DataFrame
    df = pd.DataFrame({
        'Album': ['Thriller', 'Back in Black', 'The Dark Side of the Moon', 
                  'The Bodyguard', 'Bat Out of Hell'],
        'Released': [1982, 1980, 1973, 1992, 1977],
        'Artist': ['Michael Jackson', 'AC/DC', 'Pink Floyd', 
                   'Whitney Houston', 'Meat Loaf']
    })
    
    # Filter: albums after 1979
    df1 = df[df['Released'] > 1979]
    
    # Save to CSV file
    df1.to_csv('albums_after_1979.csv')
    
    print("DataFrame saved to 'albums_after_1979.csv'")
    print("\nFiltered DataFrame that was saved:")
    print(df1)

LINE-BY-LINE EXPLANATION:
-------------------------
Lines 1-11: Create and filter DataFrame
    • Standard DataFrame creation
    • Filters for albums after 1979
    • Creates df1 with filtered data

Line 13: df1.to_csv('albums_after_1979.csv')
    • df1 = The filtered DataFrame to save
    • .to_csv() = Method to save as CSV
    • 'albums_after_1979.csv' = Filename
        - Must be in quotes (string)
        - Must include .csv extension
        - Will be saved in current directory

Lines 15-17: Print statements
    • Confirms the save operation
    • Shows what was saved

WHAT THE CSV FILE LOOKS LIKE
-----------------------------
When you open 'albums_after_1979.csv' in a text editor, it will look like:

    ,Album,Released,Artist
    0,Thriller,1982,Michael Jackson
    1,Back in Black,1980,AC/DC
    3,The Bodyguard,1992,Whitney Houston

Explanation of the CSV format:
• First line: Column headers (Album, Released, Artist)
• First column: Row indices (0, 1, 3)
• Commas separate values
• Each line is a row

IMPORTANT: THE .CSV EXTENSION
------------------------------
Make sure you include a .csv extension in the filename. This is important 
because:
• It tells the operating system what type of file it is
• Programs like Excel recognize .csv files automatically
• Without the extension, the file might not open correctly
• The extension helps you identify the file type

CORRECT: 'albums_after_1979.csv'  ✓
INCORRECT: 'albums_after_1979'    ✗

ADDITIONAL OPTIONS FOR to_csv()
-------------------------------
The to_csv() method has many optional parameters for customization:

EXAMPLE: SAVING WITHOUT ROW INDICES
------------------------------------
    df1.to_csv('albums_after_1979.csv', index=False)

Explanation:
• index=False = Don't include row indices in the CSV file
• Result: CSV file won't have the first column with 0, 1, 3

EXAMPLE: SPECIFYING A DIFFERENT DIRECTORY
------------------------------------------
    df1.to_csv('C:/Users/YourName/Documents/albums_after_1979.csv')

Explanation:
• Full path specifies where to save the file
• Use forward slashes (/) or double backslashes (\\) in Windows
• File will be saved in the specified location

EXAMPLE: SAVING WITH CUSTOM SEPARATOR
--------------------------------------
    df1.to_csv('albums_after_1979.csv', sep=';')

Explanation:
• sep=';' = Use semicolon instead of comma as separator
• Useful for European locales where comma is decimal separator

EXAMPLE: SAVING WITHOUT HEADERS
--------------------------------
    df1.to_csv('albums_after_1979.csv', header=False)

Explanation:
• header=False = Don't include column names in first row
• Useful when appending to existing files

COMPLETE EXAMPLE WITH OPTIONS
------------------------------
    import pandas as pd
    
    # Create and filter DataFrame
    df = pd.DataFrame({
        'Album': ['Thriller', 'Back in Black', 'The Bodyguard'],
        'Released': [1982, 1980, 1992],
        'Artist': ['Michael Jackson', 'AC/DC', 'Whitney Houston']
    })
    
    # Save with options
    df.to_csv('albums_clean.csv', 
              index=False,      # Don't save row indices
              encoding='utf-8') # Use UTF-8 encoding
    
    print("DataFrame saved successfully!")

LINE-BY-LINE EXPLANATION:
-------------------------
Line 12: df.to_csv('albums_clean.csv', 
    • Starts the to_csv() method call
    • Filename: 'albums_clean.csv'

Line 13: index=False,
    • index=False = Excludes row indices from CSV
    • Comma separates parameters

Line 14: encoding='utf-8')
    • encoding='utf-8' = Uses UTF-8 character encoding
    • Ensures special characters are saved correctly
    • Closes the method call with )

VERIFYING THE SAVED FILE
-------------------------
After saving, you can verify the file was created:

    import os
    
    # Check if file exists
    if os.path.exists('albums_after_1979.csv'):
        print("File saved successfully!")
        # Read it back to verify
        df_loaded = pd.read_csv('albums_after_1979.csv')
        print("\nLoaded DataFrame:")
        print(df_loaded)
    else:
        print("File not found!")

This code:
• os.path.exists() = Checks if file exists
• pd.read_csv() = Reads CSV file back into DataFrame
• Verifies the save operation worked correctly

[END SECTION 2.6]
================================================================================

SECTION 2.7: OTHER FILE FORMATS FOR SAVING DATAFRAMES
------------------------------------------------------

DEFINITION
----------
There are other functions to save the DataFrame in other formats. Pandas 
supports saving DataFrames to many different file formats beyond CSV.

DETAILED EXPLANATION
--------------------
While CSV is the most common format, pandas provides methods to save 
DataFrames in many other formats, each with its own advantages:

COMMON FILE FORMATS SUPPORTED BY PANDAS
---------------------------------------
1. CSV (Comma-Separated Values) - to_csv()
2. Excel files (.xlsx, .xls) - to_excel()
3. JSON (JavaScript Object Notation) - to_json()
4. HTML tables - to_html()
5. Parquet - to_parquet()
6. SQL databases - to_sql()
7. Pickle (Python binary format) - to_pickle()
8. HDF5 - to_hdf()

EXAMPLE 1: SAVING TO EXCEL FORMAT
----------------------------------
    import pandas as pd
    
    df = pd.DataFrame({
        'Album': ['Thriller', 'Back in Black', 'The Bodyguard'],
        'Released': [1982, 1980, 1992],
        'Artist': ['Michael Jackson', 'AC/DC', 'Whitney Houston']
    })
    
    # Save to Excel file
    df.to_excel('albums.xlsx', index=False)
    print("Saved to Excel format!")

LINE-BY-LINE EXPLANATION:
-------------------------
Line 9: df.to_excel('albums.xlsx', index=False)
    • .to_excel() = Method for Excel format
    • 'albums.xlsx' = Filename with .xlsx extension
    • index=False = Don't include row indices
    • Note: Requires openpyxl library (install with: pip install openpyxl)

ADVANTAGES OF EXCEL FORMAT:
• Preserves formatting better than CSV
• Can have multiple sheets
• Better for sharing with non-technical users
• Supports formulas and formatting

EXAMPLE 2: SAVING TO JSON FORMAT
---------------------------------
    # Save to JSON file
    df.to_json('albums.json', orient='records', indent=2)
    print("Saved to JSON format!")

LINE-BY-LINE EXPLANATION:
-------------------------
• .to_json() = Method for JSON format
• 'albums.json' = Filename with .json extension
• orient='records' = Format: list of records
• indent=2 = Pretty-print with 2-space indentation

ADVANTAGES OF JSON FORMAT:
• Human-readable
• Commonly used for web APIs
• Supports nested data structures
• Easy to parse in many programming languages

EXAMPLE 3: SAVING TO HTML FORMAT
---------------------------------
    # Save to HTML table
    df.to_html('albums.html', index=False)
    print("Saved to HTML format!")

LINE-BY-LINE EXPLANATION:
-------------------------
• .to_html() = Method for HTML format
• 'albums.html' = Filename with .html extension
• Creates an HTML table that can be viewed in a web browser

ADVANTAGES OF HTML FORMAT:
• Can be viewed in web browsers
• Good for reports and documentation
• Can be styled with CSS
• Easy to share via web

EXAMPLE 4: SAVING TO PARQUET FORMAT
------------------------------------
    # Save to Parquet (efficient binary format)
    df.to_parquet('albums.parquet', index=False)
    print("Saved to Parquet format!")

LINE-BY-LINE EXPLANATION:
-------------------------
• .to_parquet() = Method for Parquet format
• 'albums.parquet' = Filename with .parquet extension
• Note: Requires pyarrow or fastparquet library

ADVANTAGES OF PARQUET FORMAT:
• Very efficient (compressed, columnar storage)
• Fast to read and write
• Preserves data types
• Good for large datasets

COMPARISON TABLE OF FILE FORMATS
---------------------------------
Format      Extension  Method        Best For
-------     ---------  ------        --------
CSV         .csv       to_csv()      Simple data, Excel compatibility
Excel       .xlsx      to_excel()    Sharing with non-technical users
JSON        .json      to_json()     Web APIs, nested data
HTML        .html      to_html()     Web reports, documentation
Parquet     .parquet   to_parquet()  Large datasets, data analysis
SQL         (varies)   to_sql()      Databases, relational data
Pickle      .pkl       to_pickle()   Python-only, preserving types

CHOOSING THE RIGHT FORMAT
--------------------------
Choose based on your needs:
• CSV: Universal compatibility, simple data
• Excel: Non-technical users, formatting needs
• JSON: Web applications, APIs
• HTML: Reports, web display
• Parquet: Large datasets, performance
• SQL: Database integration
• Pickle: Python-only, complex objects

[END SECTION 2.7]
================================================================================

SECTION 2.8: SUMMARY AND KEY TAKEAWAYS
---------------------------------------

SUMMARY OF WHAT YOU LEARNED
----------------------------
In Part 2, you learned about:

1. FILTERING DATA
   • How to filter DataFrames based on conditions
   • Using Boolean indexing to select rows
   • Creating filtered DataFrames from original DataFrames

2. BOOLEAN INDEXING
   • How comparison operators create Boolean Series
   • Using True/False values to filter rows
   • Understanding how pandas evaluates conditions row by row

3. COMPARISON OPERATORS
   • > (greater than)
   • < (less than)
   • >= (greater than or equal to)
   • <= (less than or equal to)
   • == (equal to)
   • != (not equal to)

4. CREATING FILTERED DATAFRAMES
   • Two-step approach: condition first, then filter
   • One-line approach: combine condition and filter
   • Original DataFrame remains unchanged

5. SAVING DATAFRAMES
   • Using to_csv() to save to CSV files
   • Importance of .csv extension
   • Other file formats available (Excel, JSON, HTML, Parquet, etc.)

KEY DEFINITIONS
---------------
• FILTERING: Selecting specific rows from a DataFrame based on conditions
• BOOLEAN INDEXING: Using True/False values to select rows
• BOOLEAN SERIES: A Series containing True/False values
• COMPARISON OPERATOR: Operators like >, <, == that compare values
• CSV FILE: Comma-Separated Values file format
• to_csv(): Method to save DataFrame to CSV format

IMPORTANT CONCEPTS
------------------
1. ORIGINAL DATAFRAME IS PRESERVED
   • Filtering creates a new DataFrame
   • Original data remains unchanged
   • You can filter multiple times from the same original

2. BOOLEAN CONDITIONS CREATE SERIES
   • Comparison operators return Boolean Series
   • Each row gets a True/False value
   • Boolean Series is used to filter

3. ONE-LINE VS TWO-LINE APPROACH
   • Both approaches work the same way
   • Two-line is clearer for beginners
   • One-line is more concise

4. FILE EXTENSIONS MATTER
   • Always include proper extension (.csv, .xlsx, etc.)
   • Extensions help identify file types
   • Programs use extensions to determine how to open files

COMMON PATTERNS
---------------
PATTERN 1: Filter and Save
    df_filtered = df[df['column'] > value]
    df_filtered.to_csv('filtered_data.csv', index=False)

PATTERN 2: Multiple Conditions
    df_filtered = df[(df['col1'] > val1) & (df['col2'] < val2)]
    df_filtered.to_csv('filtered_data.csv', index=False)

PATTERN 3: Filter, Process, Save
    df_filtered = df[df['column'] > value]
    # Do additional processing
    df_filtered.to_csv('processed_data.csv', index=False)

BEST PRACTICES
--------------
1. ALWAYS INCLUDE FILE EXTENSIONS
   • Use .csv for CSV files
   • Use .xlsx for Excel files
   • Use .json for JSON files

2. USE index=False FOR CLEANER CSV FILES
   • Removes row indices from output
   • Makes files easier to read
   • Better for sharing with others

3. VERIFY YOUR FILTERED DATA
   • Check the number of rows before and after filtering
   • Print a sample to verify correctness
   • Make sure conditions are working as expected

4. SAVE ORIGINAL DATA SEPARATELY
   • Keep original DataFrame unchanged
   • Save filtered versions with descriptive names
   • Document what filters were applied

5. CHOOSE APPROPRIATE FILE FORMATS
   • CSV for simple, universal compatibility
   • Excel for non-technical users
   • JSON for web applications
   • Parquet for large datasets

COMMON MISTAKES TO AVOID
-------------------------
1. FORGETTING THE .CSV EXTENSION
   • Wrong: df.to_csv('myfile')
   • Right: df.to_csv('myfile.csv')

2. USING SINGLE = INSTEAD OF ==
   • Wrong: df[df['Released'] = 1980]
   • Right: df[df['Released'] == 1980]

3. FORGETTING PARENTHESES IN COMBINED CONDITIONS
   • Wrong: df[(df['A'] > 1) & df['B'] < 2]
   • Right: df[(df['A'] > 1) & (df['B'] < 2)]

4. MODIFYING ORIGINAL WHEN YOU WANT TO KEEP IT
   • Wrong: df = df[df['Released'] > 1979]  # Loses original
   • Right: df1 = df[df['Released'] > 1979]  # Keeps original

QUICK REFERENCE GUIDE
---------------------
FINDING UNIQUE VALUES:
    unique_values = df['column'].unique()

FILTERING DATA:
    filtered_df = df[df['column'] > value]

SAVING TO CSV:
    df.to_csv('filename.csv', index=False)

SAVING TO EXCEL:
    df.to_excel('filename.xlsx', index=False)

SAVING TO JSON:
    df.to_json('filename.json', orient='records')

COMBINING CONDITIONS:
    df[(df['col1'] > val1) & (df['col2'] < val2)]  # AND
    df[(df['col1'] > val1) | (df['col2'] < val2)]  # OR

NEXT STEPS
----------
Now that you understand:
• How to find unique values in columns
• How to filter DataFrames using Boolean indexing
• How to save DataFrames to various file formats

You can:
• Apply these techniques to your own datasets
• Combine filtering with other pandas operations
• Create data processing pipelines
• Prepare data for analysis or sharing

PRACTICE EXERCISES
------------------
1. Create a DataFrame with 20 rows of data
2. Find unique values in a categorical column
3. Filter rows based on a numerical condition
4. Save the filtered DataFrame to CSV
5. Try saving to different formats (Excel, JSON)
6. Combine multiple conditions to filter data

[END SECTION 2.8]
================================================================================

================================================================================
END OF PART 2 - COMPLETE STUDY GUIDE
================================================================================

Congratulations! You have completed the comprehensive study guide on Pandas: 
Working with and Saving Data.

COMPLETE SUMMARY OF BOTH PARTS:
--------------------------------
PART 1 COVERED:
• Introduction to working with DataFrames
• Understanding unique values in data
• The unique() method and how to use it
• Practical examples with detailed explanations

PART 2 COVERED:
• Introduction to filtering data
• Boolean indexing in pandas
• Using comparison operators with DataFrames
• Creating filtered DataFrames step by step
• Complete examples with filtering
• Saving DataFrames to CSV files
• Other file formats for saving DataFrames
• Summary, best practices, and quick reference

YOU NOW KNOW HOW TO:
• Find unique values in DataFrame columns
• Filter DataFrames based on conditions
• Use Boolean indexing effectively
• Save DataFrames to CSV and other formats
• Apply these techniques to real-world data

Keep practicing with your own datasets to master these essential pandas skills!

================================================================================
