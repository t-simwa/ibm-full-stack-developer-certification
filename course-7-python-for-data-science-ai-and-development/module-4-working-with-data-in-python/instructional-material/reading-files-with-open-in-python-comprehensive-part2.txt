================================================================================
READING FILES WITH OPEN() IN PYTHON
Comprehensive Study Guide - Part 2
================================================================================

WELCOME TO PART 2
-----------------
This part covers reading methods, the with statement, and practical examples. 
Make sure you've completed Part 1 before continuing, as this builds on those 
foundational concepts.

================================================================================
TABLE OF CONTENTS - PART 2
================================================================================

PART 2: READING FROM FILES
  SECTION 2.1: THE READ() METHOD - READING ENTIRE FILES
  SECTION 2.2: CLOSING FILES PROPERLY
  SECTION 2.3: THE WITH STATEMENT - AUTOMATIC FILE MANAGEMENT
  SECTION 2.4: THE READLINE() METHOD - READING ONE LINE AT A TIME
  SECTION 2.5: THE READLINES() METHOD - READING ALL LINES AS A LIST
  SECTION 2.6: READING SPECIFIC NUMBER OF CHARACTERS
  SECTION 2.7: ITERATING THROUGH FILES WITH LOOPS
  SECTION 2.8: UNDERSTANDING NEWLINE CHARACTERS

NOTE: Part 3 covers advanced topics, best practices, common patterns, error 
handling, and summary.

================================================================================
PART 2: READING FROM FILES
================================================================================

SECTION 2.1: THE READ() METHOD - READING ENTIRE FILES
-------------------------------------------------------

DEFINITION
----------
The read() method reads the entire contents of a file and returns it as a 
single string. It reads from the current position in the file to the end of 
the file.

SYNTAX
------
  file_content = file_object.read()
  # Reads entire file

  file_content = file_object.read(size)
  # Reads specified number of characters

DETAILED EXPLANATION
--------------------
Think of the read() method like reading an entire book from cover to cover in 
one sitting:
• You open the book (open the file)
• You read everything from start to finish (read() method)
• You get all the content at once (returns entire file as string)
• You close the book (close the file)

The read() method is the simplest way to get all file contents at once.

BASIC EXAMPLE
-------------
  file1 = open("Example1.txt", "r")
  file_stuff = file1.read()
  print(file_stuff)
  file1.close()

LINE-BY-LINE EXPLANATION
------------------------
Line 1: file1 = open("Example1.txt", "r")
        • Opens the file Example1.txt in read mode
        • Creates a file object stored in variable file1
        • Establishes connection to the file
        
Line 2: file_stuff = file1.read()
        • file1 = The file object we created
        • . = Dot notation (accesses the method)
        • read() = The read method (no arguments = read everything)
        • () = Parentheses indicate this is a method call
        • file_stuff = Variable that stores the result
        • = = Assignment operator (assigns the result to the variable
        
        WHAT HAPPENS:
        • Python reads all content from the file
        • Content is returned as a single string
        • String is stored in variable file_stuff
        • File pointer moves to the end of the file
        
Line 3: print(file_stuff)
        • Prints the contents stored in file_stuff
        • Displays the file content on screen
        
Line 4: file1.close()
        • Closes the file
        • Releases system resources
        • Important: Always close files when done!

WHAT DOES READ() RETURN?
------------------------
The read() method returns a string containing all the file contents. This 
includes:
• All text characters
• Spaces
• Newline characters (\n)
• Everything in the file as one continuous string

EXAMPLE FILE CONTENT (Example1.txt):
  Line 1
  Line 2
  Line 3

WHAT READ() RETURNS:
  "Line 1\nLine 2\nLine 3\n"

Notice:
• All content is in one string
• \n represents newline characters (line breaks)
• The string contains everything from the file

USING THE WITH STATEMENT (BETTER PRACTICE)
------------------------------------------
As mentioned in the original content, using a with statement is better 
practice. We'll cover this in detail in Section 2.3, but here's a preview:

  with open("Example1.txt", "r") as file1:
      file_stuff = file1.read()
      print(file_stuff)
  # File automatically closes here

This is the recommended way to work with files, as it automatically handles 
closing the file.

WHAT HAPPENS AFTER READING?
---------------------------
After you call read(), the file pointer (the position where Python is reading 
from) moves to the end of the file. If you try to read again:

  file1 = open("Example1.txt", "r")
  content1 = file1.read()
  print("First read:", content1)
  
  content2 = file1.read()
  print("Second read:", content2)

OUTPUT:
  First read: Line 1
  Line 2
  Line 3
  
  Second read: 

The second read() returns an empty string because the file pointer is already 
at the end of the file. There's nothing left to read!

To read again, you would need to:
• Close and reopen the file, OR
• Use seek() method to move pointer back (advanced topic)

PRACTICAL EXAMPLE
-----------------
Let's say you have a file called "data.txt" with the following content:
  Hello World
  Python is great
  File handling is important

Code to read it:
  file1 = open("data.txt", "r")
  content = file1.read()
  print(content)
  file1.close()

OUTPUT:
  Hello World
  Python is great
  File handling is important

The entire file content is printed exactly as it appears in the file.

[END SECTION 2.1]
================================================================================

SECTION 2.2: CLOSING FILES PROPERLY
------------------------------------

DEFINITION
----------
Closing a file releases the system resources associated with the file and 
ensures that any buffered data is written to disk. You should always close 
files when you're done with them.

SYNTAX
------
  file_object.close()

DETAILED EXPLANATION
--------------------
Think of closing a file like hanging up a phone call:
• You finish your conversation (finish reading/writing)
• You hang up (close the file)
• The phone line is freed for others to use (resources are released)

WHY IS CLOSING IMPORTANT?
------------------------
1. RESOURCE MANAGEMENT
   • Files consume system resources (memory, file handles)
   • Operating systems have limits on open files
   • Not closing files can lead to resource exhaustion
   
2. DATA INTEGRITY
   • For write operations, data might be buffered (held in memory)
   • Closing ensures all data is written to disk
   • Prevents data loss
   
3. FILE ACCESS
   • Some systems lock files when open
   • Other programs might not be able to access the file
   • Closing releases the lock

4. BEST PRACTICE
   • Always close what you open
   • Prevents bugs and resource leaks
   • Professional coding practice

HOW TO CLOSE A FILE
-------------------
  file1 = open("Example1.txt", "r")
  # ... do something with file1 ...
  file1.close()

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: file1 = open("Example1.txt", "r")
        • Opens the file
        
Line 2: # ... do something with file1 ...
        • This is where you would read from or write to the file
        
Line 3: file1.close()
        • file1 = The file object
        • . = Dot notation
        • close = The close method
        • () = Method call (no arguments needed)
        
        WHAT HAPPENS:
        • Closes the file connection
        • Releases system resources
        • File can no longer be used for reading/writing

CHECKING IF FILE IS CLOSED
--------------------------
You can check if a file is closed using the closed attribute:

  file1 = open("Example1.txt", "r")
  print(file1.closed)  # False (file is open)
  
  file1.close()
  print(file1.closed)  # True (file is closed)

WHAT HAPPENS IF YOU TRY TO USE A CLOSED FILE?
---------------------------------------------
If you try to read from or write to a closed file, Python will raise a 
ValueError:

  file1 = open("Example1.txt", "r")
  file1.close()
  content = file1.read()  # ValueError: I/O operation on closed file.

This is Python's way of preventing errors - once a file is closed, you can't 
use it anymore.

THE PROBLEM WITH MANUAL CLOSING
--------------------------------
Manually closing files can be tedious and error-prone:

  file1 = open("file1.txt", "r")
  # ... lots of code ...
  # ... what if an error occurs here? ...
  file1.close()  # Might not execute if error occurred above!

If an error occurs before close() is called, the file might not be closed, 
leading to resource leaks.

SOLUTION: THE WITH STATEMENT
-----------------------------
The with statement automatically closes files, even if an error occurs. This 
is why it's considered best practice. We'll cover this in detail in the next 
section.

[END SECTION 2.2]
================================================================================

SECTION 2.3: THE WITH STATEMENT - AUTOMATIC FILE MANAGEMENT
-------------------------------------------------------------

DEFINITION
----------
The with statement (also called a context manager) automatically manages file 
resources. It ensures the file is properly closed when you're done with it, 
even if an error occurs. Using a with statement to open files is better 
practice because it automatically closes the file.

SYNTAX
------
  with open(file_path, mode) as file_object:
      # Code that uses the file
      # File automatically closes when block exits
  # File is closed here

DETAILED EXPLANATION
--------------------
Think of the with statement like an automatic door closer:
• You open the door (open the file)
• You go through and do your work (use the file)
• The door automatically closes behind you (file automatically closes)
• Even if you trip and fall (error occurs), the door still closes!

The with statement is Python's way of ensuring proper resource management 
without you having to remember to close files manually.

BASIC EXAMPLE
-------------
  with open("Example1.txt", "r") as file1:
      file_stuff = file1.read()
      print(file_stuff)
  # File automatically closes here

LINE-BY-LINE EXPLANATION
------------------------
Line 1: with open("Example1.txt", "r") as file1:
        • with = Python keyword that starts a context manager
        • open("Example1.txt", "r") = Opens the file (same as before)
        • as = Keyword that assigns the result to a variable
        • file1 = Variable name for the file object
        • : = Colon indicates start of indented block
        
        WHAT HAPPENS:
        • File is opened
        • File object is created and stored in file1
        • Python sets up automatic cleanup
        
Line 2:     file_stuff = file1.read()
        • Indented code (part of the with block)
        • Reads entire file content
        • Stores in file_stuff variable
        
Line 3:     print(file_stuff)
        • Still indented (still in with block)
        • Prints the file content
        
Line 4: # File automatically closes here
        • No indentation (outside with block)
        • File is automatically closed here
        • This happens even if an error occurred above

WHY IS THIS BETTER?
-------------------
1. AUTOMATIC CLOSING
   • File always closes, even if errors occur
   • No need to remember to call close()
   • Prevents resource leaks
   
2. CLEANER CODE
   • Less code to write
   • Clearer intent (file is used in this block)
   • More Pythonic (follows Python best practices)
   
3. ERROR SAFETY
   • If an exception occurs, file still closes
   • Prevents file corruption
   • Better error handling

COMPARISON: MANUAL VS WITH STATEMENT
-------------------------------------
MANUAL CLOSING (Old way):
  file1 = open("Example1.txt", "r")
  file_stuff = file1.read()
  print(file_stuff)
  file1.close()  # Must remember to close!

WITH STATEMENT (Better way):
  with open("Example1.txt", "r") as file1:
      file_stuff = file1.read()
      print(file_stuff)
  # Automatically closed - no need to remember!

WHAT HAPPENS WITH ERRORS?
-------------------------
If an error occurs, the with statement still closes the file:

  try:
      with open("Example1.txt", "r") as file1:
          file_stuff = file1.read()
          # Simulate an error
          raise ValueError("Something went wrong!")
          print(file_stuff)  # This line never executes
  except ValueError:
      print("Error occurred!")
  # File is still closed here, even though error occurred!

This is much safer than manual closing, where an error might prevent close() 
from being called.

CAN YOU USE THE FILE OUTSIDE THE WITH BLOCK?
--------------------------------------------
You can use the file content outside the block, but not the file object itself:

  with open("Example1.txt", "r") as file1:
      file_stuff = file1.read()
  
  # Outside the with block
  print(file_stuff)  # ✅ This works! Content is stored in variable
  print(file1.closed)  # ✅ This works! Shows True (file is closed)
  
  # But you CANNOT read from file1 anymore:
  # content = file1.read()  # ❌ ValueError: I/O operation on closed file

The file content (stored in file_stuff) persists outside the block, but the 
file object itself is closed and can't be used for reading/writing.

CHECKING IF FILE IS CLOSED
--------------------------
You can verify the file is closed:

  with open("Example1.txt", "r") as file1:
      print("Inside block - File closed?", file1.closed)  # False
      file_stuff = file1.read()
  
  print("Outside block - File closed?", file1.closed)  # True

OUTPUT:
  Inside block - File closed? False
  Outside block - File closed? True

This confirms that the file is automatically closed when the with block exits.

MULTIPLE FILES WITH WITH STATEMENT
-----------------------------------
You can open multiple files in one with statement:

  with open("file1.txt", "r") as file1, open("file2.txt", "r") as file2:
      content1 = file1.read()
      content2 = file2.read()
      print(content1)
      print(content2)
  # Both files automatically close here

This is useful when you need to work with multiple files simultaneously.

[END SECTION 2.3]
================================================================================

SECTION 2.4: THE READLINE() METHOD - READING ONE LINE AT A TIME
-----------------------------------------------------------------

DEFINITION
----------
The readline() method reads a single line from the file, starting from the 
current file pointer position. Each time you call readline(), it reads the 
next line. It returns an empty string when it reaches the end of the file.

SYNTAX
------
  line = file_object.readline()
  # Reads one line

DETAILED EXPLANATION
--------------------
Think of readline() like reading a book one line at a time:
• First call: Reads the first line
• Second call: Reads the second line
• Third call: Reads the third line
• And so on...

Each call advances to the next line, like reading line by line in a book.

BASIC EXAMPLE
-------------
  with open("Example1.txt", "r") as file1:
      line1 = file1.readline()
      print(line1)
      
      line2 = file1.readline()
      print(line2)

LINE-BY-LINE EXPLANATION
------------------------
Line 1: with open("Example1.txt", "r") as file1:
        • Opens file using with statement
        • Creates file object in file1
        
Line 2:     line1 = file1.readline()
        • file1 = The file object
        • . = Dot notation
        • readline() = Method that reads one line
        • () = No arguments = read next line
        • line1 = Variable storing the first line
        
        WHAT HAPPENS:
        • Python reads from current position (start of file)
        • Reads until it encounters a newline character (\n)
        • Returns the line as a string (including the \n)
        • File pointer moves to the beginning of next line
        
Line 3:     print(line1)
        • Prints the first line
        
Line 4: (blank line for readability)
        
Line 5:     line2 = file1.readline()
        • Reads the second line
        • File pointer has moved, so this reads the next line
        • Stores in line2
        
Line 6:     print(line2)
        • Prints the second line

EXAMPLE FILE CONTENT (Example1.txt):
  First line
  Second line
  Third line

CODE:
  with open("Example1.txt", "r") as file1:
      line1 = file1.readline()
      print("Line 1:", repr(line1))  # repr() shows special characters
      
      line2 = file1.readline()
      print("Line 2:", repr(line2))
      
      line3 = file1.readline()
      print("Line 3:", repr(line3))

OUTPUT:
  Line 1: 'First line\n'
  Line 2: 'Second line\n'
  Line 3: 'Third line\n'

Notice:
• Each line includes the newline character (\n) at the end
• repr() shows the actual string representation (useful for debugging)

WHAT IF YOU CALL READLINE() MORE TIMES THAN THERE ARE LINES?
------------------------------------------------------------
If you call readline() after reaching the end of the file, it returns an empty 
string:

  with open("Example1.txt", "r") as file1:
      line1 = file1.readline()  # "First line\n"
      line2 = file1.readline()  # "Second line\n"
      line3 = file1.readline()  # "Third line\n"
      line4 = file1.readline()  # "" (empty string - end of file)

The empty string indicates you've reached the end of the file.

REMOVING THE NEWLINE CHARACTER
-------------------------------
Often, you don't want the newline character at the end. You can remove it:

  with open("Example1.txt", "r") as file1:
      line1 = file1.readline().strip()  # Removes \n and whitespace
      print(line1)

Or:
  with open("Example1.txt", "r") as file1:
      line1 = file1.readline().rstrip('\n')  # Removes only \n from right
      print(line1)

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: line1 = file1.readline().strip()
        • readline() = Reads the line (includes \n)
        • .strip() = Removes whitespace (including \n) from both ends
        • Result: Line without newline character

USING READLINE() IN A LOOP
--------------------------
You can use readline() in a loop to read all lines:

  with open("Example1.txt", "r") as file1:
      line = file1.readline()
      while line:
          print(line, end='')  # end='' prevents extra newline
          line = file1.readline()

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: with open("Example1.txt", "r") as file1:
        • Opens the file
        
Line 2:     line = file1.readline()
        • Reads the first line
        
Line 3:     while line:
        • while = Loop that continues while condition is True
        • line = The condition (empty string is False, non-empty is True)
        • Continues as long as line is not empty
        
Line 4:         print(line, end='')
        • Prints the line
        • end='' = Prevents print from adding extra newline
        • (since line already has \n)
        
Line 5:         line = file1.readline()
        • Reads the next line
        • If empty string, loop will exit

This pattern reads all lines one by one until the end of the file.

[END SECTION 2.4]
================================================================================

SECTION 2.5: THE READLINES() METHOD - READING ALL LINES AS A LIST
------------------------------------------------------------------

DEFINITION
----------
The readlines() method reads all lines from the file and returns them as a 
list of strings. Each line becomes an element in the list, with the first line 
corresponding to the first element, the second line to the second element, and 
so on.

SYNTAX
------
  lines = file_object.readlines()
  # Returns a list of strings, one per line

DETAILED EXPLANATION
--------------------
Think of readlines() like reading a book and writing down each line on a 
separate index card, then putting all the cards in a box (list):
• Line 1 → Index card 1 → Goes in box
• Line 2 → Index card 2 → Goes in box
• Line 3 → Index card 3 → Goes in box
• Result: A box (list) containing all the index cards (lines)

The readlines() method gives you all lines at once, organized as a list.

BASIC EXAMPLE
-------------
  with open("Example1.txt", "r") as file1:
      lines = file1.readlines()
      print(lines)

LINE-BY-LINE EXPLANATION
------------------------
Line 1: with open("Example1.txt", "r") as file1:
        • Opens the file using with statement
        
Line 2:     lines = file1.readlines()
        • file1 = The file object
        • . = Dot notation
        • readlines() = Method that reads all lines
        • () = No arguments = read all lines
        • lines = Variable storing the list of lines
        
        WHAT HAPPENS:
        • Python reads all lines from the file
        • Each line becomes an element in a list
        • List is returned and stored in lines
        • File pointer moves to end of file
        
Line 3:     print(lines)
        • Prints the entire list

EXAMPLE FILE CONTENT (Example1.txt):
  First line
  Second line
  Third line

CODE:
  with open("Example1.txt", "r") as file1:
      lines = file1.readlines()
      print(lines)

OUTPUT:
  ['First line\n', 'Second line\n', 'Third line\n']

Notice:
• Result is a list (indicated by square brackets [])
• Each line is a separate string element
• Each line includes the newline character (\n)
• First line = first element, second line = second element, etc.

WHAT TYPE IS THE RESULT?
------------------------
The result is a list:

  with open("Example1.txt", "r") as file1:
      lines = file1.readlines()
      print(type(lines))  # <class 'list'>

ACCESSING INDIVIDUAL LINES
---------------------------
Since readlines() returns a list, you can access individual lines by index:

  with open("Example1.txt", "r") as file1:
      lines = file1.readlines()
      
      print("First line:", lines[0])
      print("Second line:", lines[1])
      print("Third line:", lines[2])

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: with open("Example1.txt", "r") as file1:
        • Opens the file
        
Line 2:     lines = file1.readlines()
        • Reads all lines into a list
        
Line 4:     print("First line:", lines[0])
        • lines[0] = First element of the list (index 0)
        • This is the first line of the file
        
Line 5:     print("Second line:", lines[1])
        • lines[1] = Second element of the list (index 1)
        • This is the second line of the file
        
Line 6:     print("Third line:", lines[2])
        • lines[2] = Third element of the list (index 2)
        • This is the third line of the file

ITERATING THROUGH THE LIST
---------------------------
You can loop through the list:

  with open("Example1.txt", "r") as file1:
      lines = file1.readlines()
      
      for line in lines:
          print(line, end='')  # end='' prevents extra newline

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: with open("Example1.txt", "r") as file1:
        • Opens the file
        
Line 2:     lines = file1.readlines()
        • Reads all lines into a list
        
Line 4:     for line in lines:
        • for = Loop keyword
        • line = Variable name for current element
        • in = Keyword indicating iteration
        • lines = The list to iterate through
        • : = Colon starts the loop body
        
        WHAT HAPPENS:
        • Loop runs once for each element in lines
        • Each iteration, line contains one line from the file
        • First iteration: line = "First line\n"
        • Second iteration: line = "Second line\n"
        • Third iteration: line = "Third line\n"
        
Line 5:         print(line, end='')
        • Prints the current line
        • end='' = Prevents print from adding extra newline
        • (since each line already has \n)

GETTING THE NUMBER OF LINES
---------------------------
Since readlines() returns a list, you can use len() to get the number of lines:

  with open("Example1.txt", "r") as file1:
      lines = file1.readlines()
      num_lines = len(lines)
      print("Number of lines:", num_lines)

OUTPUT:
  Number of lines: 3

REMOVING NEWLINE CHARACTERS FROM ALL LINES
-------------------------------------------
You can remove newline characters from all lines:

  with open("Example1.txt", "r") as file1:
      lines = file1.readlines()
      # Remove \n from each line
      clean_lines = [line.strip() for line in lines]
      print(clean_lines)

OUTPUT:
  ['First line', 'Second line', 'Third line']

This uses a list comprehension to process each line. (List comprehensions are 
an advanced topic, but this shows how you can process the lines.)

READLINES() VS READLINE()
-------------------------
readline() (singular):
• Reads ONE line at a time
• Returns a string
• Must be called multiple times to get all lines
• Each call advances to next line

readlines() (plural):
• Reads ALL lines at once
• Returns a list of strings
• One call gets everything
• All lines available immediately

WHEN TO USE EACH:
• Use readline() when:
  - You only need one line
  - File is very large (saves memory)
  - You want to process line by line without storing all
  
• Use readlines() when:
  - You need all lines at once
  - File is small enough to fit in memory
  - You want to access lines by index
  - You need to process lines multiple times

[END SECTION 2.5]
================================================================================

SECTION 2.6: READING SPECIFIC NUMBER OF CHARACTERS
-----------------------------------------------------

DEFINITION
----------
The read() method can accept an optional argument specifying how many 
characters to read. When you specify a number, read() reads only that many 
characters from the current position, then advances the file pointer. Each 
subsequent call continues from where the previous call left off.

SYNTAX
------
  characters = file_object.read(size)
  # Reads specified number of characters

WHERE:
• size = Number of characters to read (integer)

DETAILED EXPLANATION
--------------------
Think of reading a specific number of characters like reading a specific number 
of words from a book:
• First call: Reads first N characters
• Second call: Reads next N characters (continues from where first left off)
• Each call progresses through the text

This is useful when you want to read files in chunks rather than all at once.

BASIC EXAMPLE
-------------
  with open("Example1.txt", "r") as file1:
      chunk1 = file1.read(4)
      print(chunk1)
      
      chunk2 = file1.read(5)
      print(chunk2)

LINE-BY-LINE EXPLANATION
------------------------
Line 1: with open("Example1.txt", "r") as file1:
        • Opens the file
        
Line 2:     chunk1 = file1.read(4)
        • file1 = The file object
        • . = Dot notation
        • read = The read method
        • (4) = Argument specifying 4 characters to read
        • chunk1 = Variable storing the result
        
        WHAT HAPPENS:
        • Python reads 4 characters from current position (start of file)
        • Returns those 4 characters as a string
        • File pointer moves forward by 4 characters
        • Stores result in chunk1
        
Line 3:     print(chunk1)
        • Prints the first 4 characters
        
Line 5:     chunk2 = file1.read(5)
        • Reads next 5 characters
        • File pointer has moved, so this reads characters 5-9
        • Stores in chunk2
        
Line 6:     print(chunk2)
        • Prints the next 5 characters

EXAMPLE FILE CONTENT (Example1.txt):
  Hello World
  Python

VISUAL REPRESENTATION (as mentioned in original content):
Let's represent every character in the string as a grid:

  Position: 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18
  Character: H  e  l  l  o     W  o  r  l  d  \n P  y  t  h  o  n  \n

CODE EXAMPLE 1: Reading 4 characters
-------------------------------------
  with open("Example1.txt", "r") as file1:
      chunk = file1.read(4)
      print(chunk)

OUTPUT:
  Hell

EXPLANATION:
• Reads characters at positions 0, 1, 2, 3
• Result: "Hell"
• File pointer now at position 4

CODE EXAMPLE 2: Reading multiple chunks
---------------------------------------
  with open("Example1.txt", "r") as file1:
      chunk1 = file1.read(4)   # Reads first 4 characters
      print("Chunk 1:", chunk1)
      
      chunk2 = file1.read(16)  # Reads next 16 characters
      print("Chunk 2:", chunk2)
      
      chunk3 = file1.read(9)   # Reads last 9 characters
      print("Chunk 3:", chunk3)

OUTPUT:
  Chunk 1: Hell
  Chunk 2: o World
  Python

  Chunk 3: 

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: with open("Example1.txt", "r") as file1:
        • Opens the file
        
Line 2:     chunk1 = file1.read(4)
        • Reads characters 0-3: "Hell"
        • File pointer moves to position 4
        
Line 3:     print("Chunk 1:", chunk1)
        • Prints: Chunk 1: Hell
        
Line 5:     chunk2 = file1.read(16)
        • Reads characters 4-19: "o World\nPython\n"
        • File pointer moves to position 20 (end of file)
        
Line 6:     print("Chunk 2:", chunk2)
        • Prints: Chunk 2: o World
  Python
        • (The \n creates line breaks in output)
        
Line 8:     chunk3 = file1.read(9)
        • Tries to read 9 more characters
        • But file pointer is at end of file
        • Returns empty string ""
        
Line 9:     print("Chunk 3:", chunk3)
        • Prints: Chunk 3: 
        • (Empty, because we're at end of file)

WHAT HAPPENS AT END OF FILE?
-----------------------------
When you try to read more characters than are available, read() returns 
whatever is left, then returns empty strings for subsequent calls:

  with open("Example1.txt", "r") as file1:
      chunk1 = file1.read(100)  # File only has ~19 characters
      print("Chunk 1:", repr(chunk1))
      
      chunk2 = file1.read(10)   # Nothing left
      print("Chunk 2:", repr(chunk2))

OUTPUT:
  Chunk 1: 'Hello World\nPython\n'
  Chunk 2: ''

The first read() gets all remaining characters (even if you ask for more than 
available). The second read() returns an empty string because we're at the end.

USING READ() WITH SIZE IN A LOOP
---------------------------------
You can read files in chunks using a loop:

  with open("Example1.txt", "r") as file1:
      chunk_size = 4
      chunk = file1.read(chunk_size)
      
      while chunk:
          print(chunk, end='')
          chunk = file1.read(chunk_size)

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: with open("Example1.txt", "r") as file1:
        • Opens the file
        
Line 2:     chunk_size = 4
        • Sets chunk size to 4 characters
        
Line 3:     chunk = file1.read(chunk_size)
        • Reads first 4 characters
        
Line 5:     while chunk:
        • Loop continues while chunk is not empty
        • Empty string is False, non-empty is True
        
Line 6:         print(chunk, end='')
        • Prints the chunk without extra newline
        
Line 7:         chunk = file1.read(chunk_size)
        • Reads next 4 characters
        • When empty string is returned, loop exits

This pattern is useful for reading large files in manageable chunks to save 
memory.

WHY READ SPECIFIC NUMBER OF CHARACTERS?
----------------------------------------
1. MEMORY EFFICIENCY
   • Large files might not fit in memory
   • Reading in chunks uses less memory
   • Process file piece by piece
   
2. STREAMING PROCESSING
   • Process data as you read it
   • Don't need entire file at once
   • More efficient for large files
   
3. NETWORK FILES
   • Reading from network locations
   • Process data as it arrives
   • Better for slow connections

[END SECTION 2.6]
================================================================================

SECTION 2.7: ITERATING THROUGH FILES WITH LOOPS
------------------------------------------------

DEFINITION
----------
You can iterate (loop) through a file object directly, which reads the file 
line by line. This is an efficient and Pythonic way to process files line by 
line without loading everything into memory.

SYNTAX
------
  for line in file_object:
      # Process each line

DETAILED EXPLANATION
--------------------
As mentioned in the original content, you can use a loop to print out each 
line individually. Python file objects are iterable, meaning you can loop 
through them directly. Each iteration gives you the next line.

BASIC EXAMPLE
-------------
  with open("Example1.txt", "r") as file1:
      for line in file1:
          print(line, end='')

LINE-BY-LINE EXPLANATION
------------------------
Line 1: with open("Example1.txt", "r") as file1:
        • Opens the file using with statement
        
Line 2:     for line in file1:
        • for = Loop keyword
        • line = Variable name for current line
        • in = Keyword indicating iteration
        • file1 = The file object (which is iterable)
        • : = Colon starts the loop body
        
        WHAT HAPPENS:
        • Python automatically reads the file line by line
        • Each iteration, line contains one line from the file
        • Loop continues until end of file
        • More efficient than readlines() for large files
        
Line 3:         print(line, end='')
        • Prints the current line
        • end='' = Prevents print from adding extra newline
        • (since each line already includes \n)

EXAMPLE FILE CONTENT (Example1.txt):
  First line
  Second line
  Third line

CODE:
  with open("Example1.txt", "r") as file1:
      for line in file1:
          print(line, end='')

OUTPUT:
  First line
  Second line
  Third line

WHY USE A LOOP INSTEAD OF READLINES()?
--------------------------------------
1. MEMORY EFFICIENCY
   • readlines() loads entire file into memory
   • Loop processes one line at a time
   • Better for large files
   
2. SIMPLICITY
   • Cleaner, more Pythonic code
   • Less code to write
   • Easier to understand
   
3. PERFORMANCE
   • Processes lines as they're read
   • No need to wait for entire file
   • Faster for large files

COMPARISON
----------
Using readlines():
  with open("large_file.txt", "r") as file1:
      lines = file1.readlines()  # Loads entire file into memory
      for line in lines:
          print(line, end='')

Using direct iteration (better):
  with open("large_file.txt", "r") as file1:
      for line in file1:  # Processes one line at a time
          print(line, end='')

The second approach is more memory-efficient for large files.

PROCESSING LINES IN THE LOOP
-----------------------------
You can do more than just print:

  with open("Example1.txt", "r") as file1:
      line_number = 1
      for line in file1:
          print(f"Line {line_number}: {line.strip()}")
          line_number += 1

OUTPUT:
  Line 1: First line
  Line 2: Second line
  Line 3: Third line

This adds line numbers and removes the newline character using strip().

FILTERING LINES
---------------
You can process only certain lines:

  with open("Example1.txt", "r") as file1:
      for line in file1:
          if "Python" in line:  # Only process lines containing "Python"
              print(line.strip())

This only prints lines that contain the word "Python".

[END SECTION 2.7]
================================================================================

SECTION 2.8: UNDERSTANDING NEWLINE CHARACTERS
-----------------------------------------------

DEFINITION
----------
A newline character (\n) is a special character that tells Python (and 
computers in general) to start a new line. When you examine the raw string 
representation of file content, you'll see \n characters where line breaks 
occur.

DETAILED EXPLANATION
--------------------
As mentioned in the original content, when we examine the raw string, we will 
see the slash n (\n). This is so Python knows to start a new line. The newline 
character is invisible when printed normally, but it's there in the string.

WHAT IS A NEWLINE CHARACTER?
-----------------------------
• Represented as: \n
• ASCII value: 10
• Purpose: Indicates end of a line and start of a new line
• Invisible: Doesn't show as a character when printed normally

VISUAL REPRESENTATION
---------------------
When you have a file with:
  Line 1
  Line 2

The actual string content is:
  "Line 1\nLine 2\n"

The \n characters are there, but they create line breaks instead of showing 
as visible characters.

EXAMPLE: SEEING NEWLINE CHARACTERS
-----------------------------------
  with open("Example1.txt", "r") as file1:
      content = file1.read()
      print("Normal print:")
      print(content)
      
      print("\nUsing repr() to see newlines:")
      print(repr(content))

OUTPUT:
  Normal print:
  Line 1
  Line 2
  
  Using repr() to see newlines:
  'Line 1\nLine 2\n'

The repr() function shows the actual string representation, including \n 
characters.

WHY DO FILES HAVE NEWLINE CHARACTERS?
--------------------------------------
Files store text as a continuous sequence of characters. Newline characters 
mark where lines end:
• Without \n: All text would be on one line
• With \n: Text is organized into separate lines

HOW READ METHODS HANDLE NEWLINES
---------------------------------
1. read() - Includes all \n characters in the returned string
2. readline() - Includes \n at the end of each line
3. readlines() - Each list element includes \n at the end

REMOVING NEWLINE CHARACTERS
---------------------------
You often want to remove \n when processing:

  with open("Example1.txt", "r") as file1:
      for line in file1:
          clean_line = line.strip()  # Removes \n and whitespace
          print(clean_line)

Or:
  with open("Example1.txt", "r") as file1:
      for line in file1:
          clean_line = line.rstrip('\n')  # Removes only \n from right
          print(clean_line)

PLATFORM DIFFERENCES
---------------------
Different operating systems use different newline characters:
• Unix/Linux/Mac: \n (line feed)
• Windows: \r\n (carriage return + line feed)
• Old Mac: \r (carriage return)

Python's open() function handles these automatically in text mode, so you usually 
don't need to worry about it. But it's good to know they exist!

[END SECTION 2.8]
================================================================================

END OF PART 2
=============

You've now learned:
✓ How to read entire files using read()
✓ The importance of closing files properly
✓ Using the with statement for automatic file management
✓ Reading one line at a time with readline()
✓ Reading all lines as a list with readlines()
✓ Reading specific numbers of characters
✓ Iterating through files with loops
✓ Understanding newline characters

In Part 3, you'll learn:
• Best practices for file handling
• Common patterns and use cases
• Error handling
• Working with different file types
• Summary and quick reference guide

Continue to Part 3 for advanced topics and best practices!

================================================================================
