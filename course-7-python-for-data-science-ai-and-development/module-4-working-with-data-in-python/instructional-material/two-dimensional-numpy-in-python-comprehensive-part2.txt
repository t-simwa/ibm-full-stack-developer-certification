================================================================================
TWO-DIMENSIONAL NUMPY IN PYTHON
Comprehensive Study Guide - Part 2
================================================================================

WELCOME TO PART 2
-----------------
This is Part 2 of the Two-Dimensional NumPy in Python comprehensive study 
guide. In this part, you will learn about array operations including addition, 
scalar multiplication, element-wise multiplication (Hadamard product), and 
matrix multiplication. Each operation is explained in exhaustive detail with 
numerous examples and line-by-line code explanations.

ESTIMATED TIME NEEDED
---------------------
15 minutes (for basic reading)
120-150 minutes (for comprehensive study with practice)

LEARNING OBJECTIVES
-------------------
After studying this guide, you will be able to:
• Understand and perform array addition (matrix addition)
• Understand and perform scalar multiplication on 2D arrays
• Understand and perform element-wise multiplication (Hadamard product)
• Understand the difference between element-wise and matrix multiplication
• Perform matrix multiplication using NumPy
• Understand the requirements for matrix multiplication
• Apply these operations to solve real-world problems
• Recognize when to use each type of operation

OVERVIEW
--------
This part covers all the basic operations you can perform on 2D NumPy arrays:
• Array Addition: Adding two arrays element by element
• Scalar Multiplication: Multiplying an array by a single number
• Element-wise Multiplication: Multiplying arrays element by element (Hadamard product)
• Matrix Multiplication: True matrix multiplication following linear algebra rules

Each operation is explained with:
• Detailed definitions and explanations
• Visual representations
• Step-by-step examples
• Line-by-line code explanations
• Multiple practice examples
• Real-world analogies

================================================================================
TABLE OF CONTENTS - PART 2
================================================================================

PART 1: ARRAY ADDITION (MATRIX ADDITION)
  SECTION 1.1: UNDERSTANDING ARRAY ADDITION
  SECTION 1.2: REQUIREMENTS FOR ARRAY ADDITION
  SECTION 1.3: STEP-BY-STEP ADDITION PROCESS
  SECTION 1.4: PRACTICAL EXAMPLES OF ARRAY ADDITION

PART 2: SCALAR MULTIPLICATION
  SECTION 2.1: UNDERSTANDING SCALAR MULTIPLICATION
  SECTION 2.2: HOW SCALAR MULTIPLICATION WORKS
  SECTION 2.3: PRACTICAL EXAMPLES OF SCALAR MULTIPLICATION

PART 3: ELEMENT-WISE MULTIPLICATION (HADAMARD PRODUCT)
  SECTION 3.1: UNDERSTANDING HADAMARD PRODUCT
  SECTION 3.2: HADAMARD PRODUCT VS MATRIX MULTIPLICATION
  SECTION 3.3: PRACTICAL EXAMPLES OF HADAMARD PRODUCT

PART 4: MATRIX MULTIPLICATION
  SECTION 4.1: UNDERSTANDING MATRIX MULTIPLICATION
  SECTION 4.2: REQUIREMENTS FOR MATRIX MULTIPLICATION
  SECTION 4.3: THE DOT PRODUCT CONCEPT
  SECTION 4.4: STEP-BY-STEP MATRIX MULTIPLICATION
  SECTION 4.5: PRACTICAL EXAMPLES OF MATRIX MULTIPLICATION

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 1.3:") to quickly jump to any section.

================================================================================
PART 1: ARRAY ADDITION (MATRIX ADDITION)
================================================================================

SECTION 1.1: UNDERSTANDING ARRAY ADDITION
------------------------------------------

DEFINITION
----------
We can also add arrays. The process is identical to matrix addition. This 
corresponds to adding the elements in the same position, i.e., adding elements 
contained in the same color boxes together. The result is a new matrix that has 
the same size as matrix Y or X. Each element in this new matrix is the sum of 
the corresponding elements in X and Y.

DETAILED EXPLANATION
--------------------
Array addition in NumPy is performed element-wise. This means that each 
element in the first array is added to the corresponding element in the second 
array at the same position. This is exactly how matrix addition works in 
mathematics.

WHAT IS ELEMENT-WISE ADDITION?
-------------------------------
Element-wise addition means:
• Take element at position (0,0) from array X
• Take element at position (0,0) from array Y
• Add them together
• Place the result at position (0,0) in the new array
• Repeat for all positions

THE PROCESS VISUALIZED
----------------------
Consider matrix X:
  [[x11, x12, x13],
   [x21, x22, x23],
   [x31, x32, x33]]

And matrix Y:
  [[y11, y12, y13],
   [y21, y22, y23],
   [y31, y32, y33]]

When we add X + Y, we get:
  [[x11+y11, x12+y12, x13+y13],
   [x21+y21, x22+y22, x23+y23],
   [x31+y31, x32+y32, x33+y33]]

Each element in the result is the sum of corresponding elements.

REAL-WORLD ANALOGY
------------------
Think of adding two spreadsheets:
• Spreadsheet 1 has sales data for January
• Spreadsheet 2 has sales data for February
• Adding them gives you combined sales for both months
• Each cell in the result = corresponding cells added together

Or think of combining two images:
• Image 1: Red channel values
• Image 2: Blue channel values
• Adding them combines the channels
• Each pixel = sum of corresponding pixels

KEY PROPERTIES OF ARRAY ADDITION
---------------------------------
1. COMMUTATIVE: X + Y = Y + X
   • Order doesn't matter
   • Adding X to Y gives the same result as adding Y to X

2. ASSOCIATIVE: (X + Y) + Z = X + (Y + Z)
   • Grouping doesn't matter
   • You can add in any order

3. ELEMENT-WISE: Each position is independent
   • Result at (i,j) depends only on X[i,j] and Y[i,j]
   • No interaction between different positions

4. SAME SHAPE REQUIRED: Arrays must have the same dimensions
   • Can't add a 3×3 array to a 2×2 array
   • Both arrays must be the same size

[END SECTION 1.1]
================================================================================

SECTION 1.2: REQUIREMENTS FOR ARRAY ADDITION
---------------------------------------------

DEFINITION
----------
To add two arrays in NumPy, both arrays must have the same shape. The result 
will have the same shape as the input arrays.

DETAILED EXPLANATION
--------------------
For array addition to work, both arrays must be compatible. This means they 
must have exactly the same dimensions.

SHAPE REQUIREMENT
-----------------
Both arrays must have:
• Same number of rows
• Same number of columns
• Same shape: (rows, columns)

VALID EXAMPLES:
---------------
EXAMPLE 1: Both 3×3
  X shape: (3, 3)
  Y shape: (3, 3)
  ✓ Can add: Result shape (3, 3)

EXAMPLE 2: Both 2×4
  X shape: (2, 4)
  Y shape: (2, 4)
  ✓ Can add: Result shape (2, 4)

INVALID EXAMPLES:
-----------------
EXAMPLE 1: Different shapes
  X shape: (3, 3)
  Y shape: (2, 2)
  ✗ Cannot add: Shapes don't match

EXAMPLE 2: Different number of rows
  X shape: (3, 3)
  Y shape: (2, 3)
  ✗ Cannot add: Different number of rows

EXAMPLE 3: Different number of columns
  X shape: (3, 3)
  Y shape: (3, 2)
  ✗ Cannot add: Different number of columns

WHAT HAPPENS IF SHAPES DON'T MATCH?
------------------------------------
If you try to add arrays with different shapes, NumPy will raise a ValueError:

Code:
import numpy as np

X = np.array([[1, 2], [3, 4]])
Y = np.array([[1, 2, 3], [4, 5, 6]])

try:
    result = X + Y
except ValueError as e:
    print(f"Error: {e}")

Output:
Error: operands could not be broadcast together with shapes (2,2) (2,3)

EXPLANATION:
• NumPy detects the shape mismatch
• Raises ValueError with a helpful message
• Shows the incompatible shapes: (2,2) vs (2,3)

BROADCASTING (ADVANCED TOPIC)
------------------------------
Note: NumPy has a feature called "broadcasting" that allows some operations 
between arrays of different shapes, but this is beyond basic array addition. 
For now, stick to arrays with the same shape.

[END SECTION 1.2]
================================================================================

SECTION 1.3: STEP-BY-STEP ADDITION PROCESS
-------------------------------------------

DEFINITION
----------
To add two arrays in NumPy, we define the array in this case X. Then we define 
the second array Y, we add the arrays. The result is identical to matrix 
addition.

DETAILED EXPLANATION
--------------------
This section walks through the complete process of adding two arrays step by 
step, showing exactly what happens at each stage.

STEP-BY-STEP PROCESS
--------------------
STEP 1: CREATE THE FIRST ARRAY (X)
-----------------------------------
Code:
import numpy as np

X = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

print("Array X:")
print(X)
print(f"Shape: {X.shape}")

Output:
Array X:
[[1 2 3]
 [4 5 6]
 [7 8 9]]
Shape: (3, 3)

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: import numpy as np
  • Imports NumPy library

Line 3-5: X = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
  • Creates nested lists
  • Converts to NumPy array
  • Stores in variable X
  • Shape: (3, 3) - 3 rows, 3 columns

STEP 2: CREATE THE SECOND ARRAY (Y)
------------------------------------
Code:
Y = np.array([[10, 11, 12],
              [13, 14, 15],
              [16, 17, 18]])

print("\nArray Y:")
print(Y)
print(f"Shape: {Y.shape}")

Output:
Array Y:
[[10 11 12]
 [13 14 15]
 [16 17 18]]
Shape: (3, 3)

EXPLANATION:
• Creates second array Y
• Same shape as X: (3, 3)
• Ready for addition

STEP 3: ADD THE ARRAYS
-----------------------
Code:
Z = X + Y

print("\nResult Z = X + Y:")
print(Z)
print(f"Shape: {Z.shape}")

Output:
Result Z = X + Y:
[[11 13 15]
 [17 19 21]
 [23 25 27]]
Shape: (3, 3)

LINE-BY-LINE EXPLANATION:
-------------------------
Line: Z = X + Y
  • X + Y: NumPy performs element-wise addition
  • For each position (i, j):
    - Takes X[i, j]
    - Takes Y[i, j]
    - Adds them: X[i, j] + Y[i, j]
    - Places result in Z[i, j]
  • Result stored in variable Z
  • Shape remains (3, 3)

DETAILED ELEMENT-BY-ELEMENT BREAKDOWN
--------------------------------------
Let's see exactly what happens for each element:

Position (0, 0):
  X[0, 0] = 1
  Y[0, 0] = 10
  Z[0, 0] = 1 + 10 = 11

Position (0, 1):
  X[0, 1] = 2
  Y[0, 1] = 11
  Z[0, 1] = 2 + 11 = 13

Position (0, 2):
  X[0, 2] = 3
  Y[0, 2] = 12
  Z[0, 2] = 3 + 12 = 15

Position (1, 0):
  X[1, 0] = 4
  Y[1, 0] = 13
  Z[1, 0] = 4 + 13 = 17

Position (1, 1):
  X[1, 1] = 5
  Y[1, 1] = 14
  Z[1, 1] = 5 + 14 = 19

Position (1, 2):
  X[1, 2] = 6
  Y[1, 2] = 15
  Z[1, 2] = 6 + 15 = 21

Position (2, 0):
  X[2, 0] = 7
  Y[2, 0] = 16
  Z[2, 0] = 7 + 16 = 23

Position (2, 1):
  X[2, 1] = 8
  Y[2, 1] = 17
  Z[2, 1] = 8 + 17 = 25

Position (2, 2):
  X[2, 2] = 9
  Y[2, 2] = 18
  Z[2, 2] = 9 + 18 = 27

VISUAL REPRESENTATION
---------------------
From the original material, arrays are color-coded to show corresponding 
elements:

Matrix X (each element colored):
  [[X11, X12, X13],  ← Each element has a unique color
   [X21, X22, X23],
   [X31, X32, X33]]

Matrix Y (same color scheme):
  [[Y11, Y12, Y13],  ← Same colors in same positions
   [Y21, Y22, Y23],
   [Y31, Y32, Y33]]

When adding:
  • Elements in the same color boxes are added together
  • X11 + Y11, X12 + Y12, etc.
  • Result has the same structure

COMPLETE CODE EXAMPLE
---------------------
Code:
import numpy as np

# Step 1: Define array X
X = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

# Step 2: Define array Y
Y = np.array([[10, 11, 12],
              [13, 14, 15],
              [16, 17, 18]])

# Step 3: Add the arrays
Z = X + Y

# Display results
print("=" * 50)
print("ARRAY ADDITION EXAMPLE")
print("=" * 50)
print("\nArray X:")
print(X)
print("\nArray Y:")
print(Y)
print("\nResult Z = X + Y:")
print(Z)
print(f"\nVerification:")
print(f"  X shape: {X.shape}")
print(f"  Y shape: {Y.shape}")
print(f"  Z shape: {Z.shape}")
print(f"  Shapes match: {X.shape == Y.shape == Z.shape}")

Output:
==================================================
ARRAY ADDITION EXAMPLE
==================================================

Array X:
[[1 2 3]
 [4 5 6]
 [7 8 9]]

Array Y:
[[10 11 12]
 [13 14 15]
 [16 17 18]]

Result Z = X + Y:
[[11 13 15]
 [17 19 21]
 [23 25 27]]

Verification:
  X shape: (3, 3)
  Y shape: (3, 3)
  Z shape: (3, 3)
  Shapes match: True

[END SECTION 1.3]
================================================================================

SECTION 1.4: PRACTICAL EXAMPLES OF ARRAY ADDITION
---------------------------------------------------

This section provides multiple practical examples of array addition.

EXAMPLE 1: ADDING IDENTITY MATRIX
----------------------------------
Code:
import numpy as np

# Create a matrix
A = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

# Create identity matrix (1s on diagonal, 0s elsewhere)
I = np.eye(3)  # Creates 3x3 identity matrix

# Add them
result = A + I

print("Matrix A:")
print(A)
print("\nIdentity Matrix I:")
print(I)
print("\nA + I:")
print(result)

Output:
Matrix A:
[[1 2 3]
 [4 5 6]
 [7 8 9]]

Identity Matrix I:
[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]

A + I:
[[ 2.  2.  3.]
 [ 4.  6.  6.]
 [ 7.  8. 10.]]

EXPLANATION:
• np.eye(3) creates a 3×3 identity matrix
• Adding identity matrix adds 1 to diagonal elements
• Off-diagonal elements remain unchanged (added to 0)

EXAMPLE 2: ADDING ARRAYS WITH NEGATIVE VALUES
-----------------------------------------------
Code:
import numpy as np

X = np.array([[5, -3, 2],
              [-1, 4, -6],
              [3, -2, 8]])

Y = np.array([[2, 1, -1],
              [3, -2, 4],
              [-5, 3, -1]])

result = X + Y

print("Array X:")
print(X)
print("\nArray Y:")
print(Y)
print("\nX + Y:")
print(result)

Output:
Array X:
[[ 5 -3  2]
 [-1  4 -6]
 [ 3 -2  8]]

Array Y:
[[ 2  1 -1]
 [ 3 -2  4]
 [-5  3 -1]]

X + Y:
[[ 7 -2  1]
 [ 2  2 -2]
 [-2  1  7]]

EXPLANATION:
• Works with negative numbers
• Subtraction occurs when adding negative values
• Example: -3 + 1 = -2

EXAMPLE 3: ADDING FLOATING POINT ARRAYS
----------------------------------------
Code:
import numpy as np

X = np.array([[1.5, 2.7, 3.2],
              [4.1, 5.9, 6.3]])

Y = np.array([[0.5, 0.3, 0.8],
              [0.9, 0.1, 0.7]])

result = X + Y

print("Array X:")
print(X)
print("\nArray Y:")
print(Y)
print("\nX + Y:")
print(result)

Output:
Array X:
[[1.5 2.7 3.2]
 [4.1 5.9 6.3]]

Array Y:
[[0.5 0.3 0.8]
 [0.9 0.1 0.7]]

X + Y:
[[2.  3.  4. ]
 [5.  6.  7. ]]

EXPLANATION:
• Works with floating point numbers
• Precision is maintained
• Result is also floating point

EXAMPLE 4: IN-PLACE ADDITION
------------------------------
Code:
import numpy as np

X = np.array([[1, 2],
              [3, 4]])

Y = np.array([[1, 1],
              [1, 1]])

print("Before addition:")
print("X =")
print(X)

# In-place addition
X += Y  # Equivalent to X = X + Y, but modifies X directly

print("\nAfter X += Y:")
print("X =")
print(X)

Output:
Before addition:
X =
[[1 2]
 [3 4]]

After X += Y:
X =
[[2 3]
 [4 5]]

EXPLANATION:
• X += Y modifies X in place
• More memory efficient (doesn't create new array)
• Equivalent to X = X + Y but faster

[END SECTION 1.4]
================================================================================

PART 2: SCALAR MULTIPLICATION
================================================================================

SECTION 2.1: UNDERSTANDING SCALAR MULTIPLICATION
-------------------------------------------------

DEFINITION
----------
Multiplying a NumPy array by a scalar is identical to multiplying a matrix by 
a scalar. If we multiply the matrix by this scalar two, we simply multiply 
every element in the matrix by two. The result is a new matrix of the same 
size where each element is multiplied by two.

DETAILED EXPLANATION
--------------------
Scalar multiplication is one of the simplest array operations. You multiply 
every single element in the array by the same number (the scalar). The shape 
of the array remains unchanged - only the values are scaled.

WHAT IS A SCALAR?
-----------------
A scalar is just a single number (not an array). Examples:
• 2 (integer scalar)
• 3.5 (float scalar)
• -1 (negative scalar)
• 0.5 (fractional scalar)

WHAT IS SCALAR MULTIPLICATION?
-------------------------------
Scalar multiplication means:
• Take a single number (scalar)
• Multiply every element in the array by that number
• Result: New array with same shape, all values scaled

THE PROCESS VISUALIZED
----------------------
Consider matrix Y:
  [[y11, y12, y13],
   [y21, y22, y23],
   [y31, y32, y33]]

Multiply by scalar 2:
  2 × Y = [[2×y11, 2×y12, 2×y13],
           [2×y21, 2×y22, 2×y23],
           [2×y31, 2×y32, 2×y33]]

Every element is multiplied by 2.

REAL-WORLD ANALOGY
------------------
Think of scaling an image:
• Original image: Each pixel has a brightness value
• Multiply by 2: All pixels become twice as bright
• Result: Brighter image, same size

Or think of converting units:
• Array contains distances in miles
• Multiply by 1.60934 to convert to kilometers
• Every distance value is scaled by the same factor

KEY PROPERTIES OF SCALAR MULTIPLICATION
----------------------------------------
1. DISTRIBUTIVE: k × (X + Y) = k×X + k×Y
   • You can distribute the scalar
   • Multiply first, then add, OR add first, then multiply

2. ASSOCIATIVE: (k1 × k2) × X = k1 × (k2 × X)
   • Multiple scalars can be combined
   • (2 × 3) × X = 6 × X = 2 × (3 × X)

3. PRESERVES SHAPE: Result has same shape as input
   • Input: (3, 3) → Output: (3, 3)
   • Only values change, not structure

4. WORKS WITH ANY SCALAR: Positive, negative, fractional, zero
   • Positive: Scales up
   • Negative: Flips sign and scales
   • Fractional: Scales down
   • Zero: Results in all zeros

[END SECTION 2.1]
================================================================================

SECTION 2.2: HOW SCALAR MULTIPLICATION WORKS
----------------------------------------------

DEFINITION
----------
Consider the array Y. We first define the array, we multiply the array by a 
scalar as follows and assign it to the variable Z. The result is a new array 
where each element is multiplied by two.

DETAILED EXPLANATION
--------------------
This section shows exactly how to perform scalar multiplication in NumPy with 
step-by-step examples.

STEP-BY-STEP PROCESS
--------------------
STEP 1: CREATE THE ARRAY
-------------------------
Code:
import numpy as np

Y = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

print("Array Y:")
print(Y)
print(f"Shape: {Y.shape}")

Output:
Array Y:
[[1 2 3]
 [4 5 6]
 [7 8 9]]
Shape: (3, 3)

EXPLANATION:
• Creates a 3×3 array Y
• Contains values 1 through 9

STEP 2: MULTIPLY BY SCALAR
---------------------------
Code:
Z = 2 * Y  # or Y * 2 (both work the same)

print("\nResult Z = 2 * Y:")
print(Z)
print(f"Shape: {Z.shape}")

Output:
Result Z = 2 * Y:
[[ 2  4  6]
 [ 8 10 12]
 [14 16 18]]
Shape: (3, 3)

LINE-BY-LINE EXPLANATION:
-------------------------
Line: Z = 2 * Y
  • 2: The scalar (single number)
  • *: Multiplication operator
  • Y: The array to multiply
  • NumPy automatically broadcasts the scalar to all elements
  • Each element Y[i, j] becomes 2 × Y[i, j]
  • Result stored in Z
  • Shape remains (3, 3)

ELEMENT-BY-ELEMENT BREAKDOWN
-----------------------------
Original Y:
  [[1, 2, 3],
   [4, 5, 6],
   [7, 8, 9]]

After 2 * Y:
  Position (0, 0): 2 × 1 = 2
  Position (0, 1): 2 × 2 = 4
  Position (0, 2): 2 × 3 = 6
  Position (1, 0): 2 × 4 = 8
  Position (1, 1): 2 × 5 = 10
  Position (1, 2): 2 × 6 = 12
  Position (2, 0): 2 × 7 = 14
  Position (2, 1): 2 × 8 = 16
  Position (2, 2): 2 × 9 = 18

Result:
  [[2, 4, 6],
   [8, 10, 12],
   [14, 16, 18]]

ALTERNATIVE SYNTAX
------------------
Both of these are equivalent:

Method 1: Scalar first
  Z = 2 * Y

Method 2: Scalar second
  Z = Y * 2

Both produce the same result!

COMPLETE CODE EXAMPLE
---------------------
Code:
import numpy as np

# Define the array
Y = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

# Multiply by scalar
Z = 2 * Y

# Display results
print("=" * 50)
print("SCALAR MULTIPLICATION EXAMPLE")
print("=" * 50)
print("\nOriginal array Y:")
print(Y)
print("\nAfter multiplying by 2:")
print("Z = 2 * Y")
print(Z)
print(f"\nVerification:")
print(f"  Y shape: {Y.shape}")
print(f"  Z shape: {Z.shape}")
print(f"  Shapes match: {Y.shape == Z.shape}")
print(f"\nElement check:")
print(f"  Y[0, 0] = {Y[0, 0]}, Z[0, 0] = {Z[0, 0]} (2 × {Y[0, 0]} = {Z[0, 0]})")
print(f"  Y[1, 1] = {Y[1, 1]}, Z[1, 1] = {Z[1, 1]} (2 × {Y[1, 1]} = {Z[1, 1]})")

Output:
==================================================
SCALAR MULTIPLICATION EXAMPLE
==================================================

Original array Y:
[[1 2 3]
 [4 5 6]
 [7 8 9]]

After multiplying by 2:
Z = 2 * Y
[[ 2  4  6]
 [ 8 10 12]
 [14 16 18]]

Verification:
  Y shape: (3, 3)
  Z shape: (3, 3)
  Shapes match: True

Element check:
  Y[0, 0] = 1, Z[0, 0] = 2 (2 × 1 = 2)
  Y[1, 1] = 5, Z[1, 1] = 10 (2 × 5 = 10)

[END SECTION 2.2]
================================================================================

SECTION 2.3: PRACTICAL EXAMPLES OF SCALAR MULTIPLICATION
----------------------------------------------------------

This section provides multiple examples of scalar multiplication with different 
scalars and scenarios.

EXAMPLE 1: MULTIPLYING BY FRACTIONAL SCALAR
--------------------------------------------
Code:
import numpy as np

Y = np.array([[10, 20, 30],
              [40, 50, 60]])

# Multiply by 0.5 (halving)
Z = 0.5 * Y

print("Original array Y:")
print(Y)
print("\nAfter multiplying by 0.5 (halving):")
print(Z)

Output:
Original array Y:
[[10 20 30]
 [40 50 60]]

After multiplying by 0.5 (halving):
[[ 5. 10. 15.]
 [20. 25. 30.]]

EXPLANATION:
• Multiplying by 0.5 divides each element by 2
• Result is floating point (even if input is integer)
• Useful for scaling down values

EXAMPLE 2: MULTIPLYING BY NEGATIVE SCALAR
-----------------------------------------
Code:
import numpy as np

Y = np.array([[1, 2, 3],
              [4, 5, 6]])

# Multiply by -1 (flipping sign)
Z = -1 * Y

print("Original array Y:")
print(Y)
print("\nAfter multiplying by -1:")
print(Z)

Output:
Original array Y:
[[1 2 3]
 [4 5 6]]

After multiplying by -1:
[[-1 -2 -3]
 [-4 -5 -6]]

EXPLANATION:
• Multiplying by -1 flips the sign of all elements
• Positive becomes negative, negative becomes positive
• Useful for subtracting arrays: X - Y = X + (-1 × Y)

EXAMPLE 3: MULTIPLYING BY ZERO
-------------------------------
Code:
import numpy as np

Y = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

# Multiply by 0
Z = 0 * Y

print("Original array Y:")
print(Y)
print("\nAfter multiplying by 0:")
print(Z)

Output:
Original array Y:
[[1 2 3]
 [4 5 6]
 [7 8 9]]

After multiplying by 0:
[[0 0 0]
 [0 0 0]
 [0 0 0]]

EXPLANATION:
• Multiplying by 0 results in all zeros
• Shape is preserved
• Useful for initializing arrays or clearing data

EXAMPLE 4: MULTIPLYING BY LARGE SCALAR
---------------------------------------
Code:
import numpy as np

Y = np.array([[1, 2],
              [3, 4]])

# Multiply by 100
Z = 100 * Y

print("Original array Y:")
print(Y)
print("\nAfter multiplying by 100:")
print(Z)

Output:
Original array Y:
[[1 2]
 [3 4]]

After multiplying by 100:
[[100 200]
 [300 400]]

EXPLANATION:
• Scales all values up by factor of 100
• Useful for unit conversions or scaling

EXAMPLE 5: IN-PLACE SCALAR MULTIPLICATION
------------------------------------------
Code:
import numpy as np

Y = np.array([[1, 2, 3],
              [4, 5, 6]])

print("Before multiplication:")
print("Y =")
print(Y)

# In-place multiplication
Y *= 2  # Equivalent to Y = Y * 2

print("\nAfter Y *= 2:")
print("Y =")
print(Y)

Output:
Before multiplication:
Y =
[[1 2 3]
 [4 5 6]]

After Y *= 2:
Y =
[[ 2  4  6]
 [ 8 10 12]]

EXPLANATION:
• Y *= 2 modifies Y in place
• More memory efficient
• Equivalent to Y = Y * 2 but faster

[END SECTION 2.3]
================================================================================

PART 3: ELEMENT-WISE MULTIPLICATION (HADAMARD PRODUCT)
================================================================================

SECTION 3.1: UNDERSTANDING HADAMARD PRODUCT
---------------------------------------------

DEFINITION
----------
Multiplication of two arrays corresponds to an element-wise product, or 
Hadamard product. Hadamard product corresponds to multiplying each of the 
elements in the same position, i.e., multiplying elements contained in the 
same color boxes together. The result is a new matrix that is the same size as 
matrix Y or X. Each element in this new matrix is the product of the 
corresponding elements in X and Y.

DETAILED EXPLANATION
--------------------
Element-wise multiplication (Hadamard product) is different from matrix 
multiplication. In Hadamard product, you multiply corresponding elements 
position by position, just like addition. This is the default behavior when 
you use the * operator on two NumPy arrays.

WHAT IS HADAMARD PRODUCT?
--------------------------
Named after French mathematician Jacques Hadamard, this operation:
• Multiplies element at (0,0) of X with element at (0,0) of Y
• Multiplies element at (0,1) of X with element at (0,1) of Y
• And so on for all positions
• Result: New array with same shape, element-wise products

THE PROCESS VISUALIZED
----------------------
Consider array X:
  [[x11, x12, x13],
   [x21, x22, x23],
   [x31, x32, x33]]

And array Y:
  [[y11, y12, y13],
   [y21, y22, y23],
   [y31, y32, y33]]

Hadamard product X * Y:
  [[x11×y11, x12×y12, x13×y13],
   [x21×y21, x22×y22, x23×y23],
   [x31×y31, x32×y32, x33×y33]]

Each element is the product of corresponding elements.

REAL-WORLD ANALOGY
------------------
Think of applying filters to images:
• Image 1: Base image pixel values
• Image 2: Filter mask values
• Hadamard product: Applies filter element-wise
• Each pixel is modified by its corresponding filter value

Or think of component-wise scaling:
• Array 1: Base values
• Array 2: Scaling factors for each position
• Hadamard product: Each value scaled by its factor
• Different scaling for different positions

KEY PROPERTIES OF HADAMARD PRODUCT
----------------------------------
1. COMMUTATIVE: X * Y = Y * X
   • Order doesn't matter
   • Same result either way

2. ELEMENT-WISE: Each position independent
   • Result at (i,j) depends only on X[i,j] and Y[i,j]
   • No cross-element interactions

3. SAME SHAPE REQUIRED: Arrays must match
   • Both arrays must have same dimensions
   • Result has same shape

4. DIFFERENT FROM MATRIX MULTIPLICATION:
   • Hadamard: Element-wise (position by position)
   • Matrix multiplication: Dot products of rows and columns
   • These are completely different operations!

[END SECTION 3.1]
================================================================================

SECTION 3.2: HADAMARD PRODUCT VS MATRIX MULTIPLICATION
-------------------------------------------------------

This section clarifies the crucial difference between Hadamard product and 
matrix multiplication.

THE KEY DIFFERENCE
------------------
HADAMARD PRODUCT (Element-wise):
  • Uses * operator: X * Y
  • Multiplies corresponding elements
  • Position (i,j) result = X[i,j] × Y[i,j]
  • Simple, intuitive

MATRIX MULTIPLICATION:
  • Uses @ operator or np.dot(): X @ Y
  • Computes dot products of rows and columns
  • Position (i,j) result = dot product of row i of X and column j of Y
  • More complex, follows linear algebra rules

VISUAL COMPARISON
-----------------
For arrays:
  X = [[1, 2],    Y = [[5, 6],
       [3, 4]]         [7, 8]]

HADAMARD PRODUCT (X * Y):
  [[1×5, 2×6],    =  [[5,  12],
   [3×7, 4×8]]        [21, 32]]

MATRIX MULTIPLICATION (X @ Y):
  [[1×5+2×7, 1×6+2×8],  =  [[19, 22],
   [3×5+4×7, 3×6+4×8]]      [43, 50]]

Notice: Completely different results!

WHEN TO USE WHICH?
------------------
USE HADAMARD PRODUCT when:
• You want element-wise operations
• Applying masks or filters
• Component-wise scaling
• Simple position-by-position operations

USE MATRIX MULTIPLICATION when:
• Performing linear transformations
• Solving systems of equations
• Neural network operations
• Following linear algebra rules

[END SECTION 3.2]
================================================================================

SECTION 3.3: PRACTICAL EXAMPLES OF HADAMARD PRODUCT
-----------------------------------------------------

DEFINITION
----------
Consider the array X and Y. We can find the product of two arrays X and Y in 
one line, and assign it to the variable Z as follows. The result is identical 
to Hadamard product.

DETAILED EXPLANATION
--------------------
This section provides step-by-step examples of performing Hadamard product.

STEP-BY-STEP EXAMPLE
--------------------
STEP 1: CREATE ARRAY X
----------------------
Code:
import numpy as np

X = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

print("Array X:")
print(X)

Output:
Array X:
[[1 2 3]
 [4 5 6]
 [7 8 9]]

STEP 2: CREATE ARRAY Y
----------------------
Code:
Y = np.array([[2, 3, 4],
              [5, 6, 7],
              [8, 9, 10]])

print("\nArray Y:")
print(Y)

Output:
Array Y:
[[ 2  3  4]
 [ 5  6  7]
 [ 8  9 10]]

STEP 3: COMPUTE HADAMARD PRODUCT
---------------------------------
Code:
Z = X * Y

print("\nHadamard Product Z = X * Y:")
print(Z)

Output:
Hadamard Product Z = X * Y:
[[ 2  6 12]
 [20 30 42]
 [56 72 90]]

LINE-BY-LINE EXPLANATION:
-------------------------
Line: Z = X * Y
  • X * Y: NumPy performs element-wise multiplication
  • For each position (i, j):
    - Takes X[i, j]
    - Takes Y[i, j]
    - Multiplies them: X[i, j] × Y[i, j]
    - Places result in Z[i, j]
  • Result stored in Z
  • Shape: Same as X and Y

ELEMENT-BY-ELEMENT BREAKDOWN
-----------------------------
Position (0, 0): X[0,0] × Y[0,0] = 1 × 2 = 2
Position (0, 1): X[0,1] × Y[0,1] = 2 × 3 = 6
Position (0, 2): X[0,2] × Y[0,2] = 3 × 4 = 12
Position (1, 0): X[1,0] × Y[1,0] = 4 × 5 = 20
Position (1, 1): X[1,1] × Y[1,1] = 5 × 6 = 30
Position (1, 2): X[1,2] × Y[1,2] = 6 × 7 = 42
Position (2, 0): X[2,0] × Y[2,0] = 7 × 8 = 56
Position (2, 1): X[2,1] × Y[2,1] = 8 × 9 = 72
Position (2, 2): X[2,2] × Y[2,2] = 9 × 10 = 90

COMPLETE CODE EXAMPLE
---------------------
Code:
import numpy as np

# Define arrays
X = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

Y = np.array([[2, 3, 4],
              [5, 6, 7],
              [8, 9, 10]])

# Compute Hadamard product
Z = X * Y

# Display results
print("=" * 50)
print("HADAMARD PRODUCT EXAMPLE")
print("=" * 50)
print("\nArray X:")
print(X)
print("\nArray Y:")
print(Y)
print("\nHadamard Product Z = X * Y:")
print(Z)
print(f"\nVerification:")
print(f"  X shape: {X.shape}")
print(f"  Y shape: {Y.shape}")
print(f"  Z shape: {Z.shape}")
print(f"  Shapes match: {X.shape == Y.shape == Z.shape}")
print(f"\nElement check:")
print(f"  X[0,0]={X[0,0]}, Y[0,0]={Y[0,0]}, Z[0,0]={Z[0,0]} ({X[0,0]}×{Y[0,0]}={Z[0,0]})")
print(f"  X[1,1]={X[1,1]}, Y[1,1]={Y[1,1]}, Z[1,1]={Z[1,1]} ({X[1,1]}×{Y[1,1]}={Z[1,1]})")

Output:
==================================================
HADAMARD PRODUCT EXAMPLE
==================================================

Array X:
[[1 2 3]
 [4 5 6]
 [7 8 9]]

Array Y:
[[ 2  3  4]
 [ 5  6  7]
 [ 8  9 10]]

Hadamard Product Z = X * Y:
[[ 2  6 12]
 [20 30 42]
 [56 72 90]]

Verification:
  X shape: (3, 3)
  Y shape: (3, 3)
  Z shape: (3, 3)
  Shapes match: True

Element check:
  X[0,0]=1, Y[0,0]=2, Z[0,0]=2 (1×2=2)
  X[1,1]=5, Y[1,1]=6, Z[1,1]=30 (5×6=30)

ADDITIONAL EXAMPLES
-------------------
EXAMPLE 1: HADAMARD PRODUCT WITH IDENTITY
Code:
import numpy as np

X = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])

I = np.eye(3)  # Identity matrix

result = X * I

print("X:")
print(X)
print("\nIdentity I:")
print(I)
print("\nX * I:")
print(result)

Output:
X:
[[1 2 3]
 [4 5 6]
 [7 8 9]]

Identity I:
[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]

X * I:
[[1. 0. 0.]
 [0. 5. 0.]
 [0. 0. 9.]]

EXPLANATION:
• Multiplying by identity (Hadamard) zeros out off-diagonal elements
• Keeps only diagonal elements
• Different from matrix multiplication with identity!

[END SECTION 3.3]
================================================================================

PART 4: MATRIX MULTIPLICATION
================================================================================

SECTION 4.1: UNDERSTANDING MATRIX MULTIPLICATION
-----------------------------------------------

DEFINITION
----------
We can also perform matrix multiplication with NumPy arrays. Matrix 
multiplication is a little more complex but let's provide a basic overview.

DETAILED EXPLANATION
--------------------
Matrix multiplication is a fundamental operation in linear algebra. Unlike 
Hadamard product (element-wise), matrix multiplication follows specific rules 
and produces results based on dot products of rows and columns.

WHAT IS MATRIX MULTIPLICATION?
------------------------------
Matrix multiplication combines rows from the first matrix with columns from the 
second matrix using dot products. The result is a new matrix where:
• Each element is computed from a row of the first matrix and a column of the 
  second matrix
• The operation follows strict rules about dimensions
• It's the basis for many mathematical and computational operations

KEY DIFFERENCES FROM HADAMARD PRODUCT
-------------------------------------
HADAMARD PRODUCT (X * Y):
  • Element-wise: X[i,j] × Y[i,j]
  • Same shape required
  • Simple multiplication

MATRIX MULTIPLICATION (X @ Y):
  • Dot product: Row i of X · Column j of Y
  • Different shape requirements
  • More complex computation

WHY IS MATRIX MULTIPLICATION IMPORTANT?
---------------------------------------
Matrix multiplication is used for:
• Linear transformations (rotations, scaling, translations)
• Solving systems of linear equations
• Neural networks (forward propagation)
• Computer graphics
• Data transformations
• Many machine learning algorithms

[END SECTION 4.1]
================================================================================

SECTION 4.2: REQUIREMENTS FOR MATRIX MULTIPLICATION
----------------------------------------------------

DEFINITION
----------
In linear algebra, before we multiply matrix A by matrix B, we must make sure 
that the number of columns in matrix A in this case three is equal to the 
number of rows in matrix B, in this case three.

DETAILED EXPLANATION
--------------------
Matrix multiplication has strict dimension requirements. Unlike addition or 
Hadamard product (which require identical shapes), matrix multiplication 
requires compatible dimensions.

THE RULE
--------
For matrix multiplication A @ B to be valid:
• Number of columns in A must equal number of rows in B
• If A is (m, n) and B is (p, q), then n must equal p
• Result will be shape (m, q)

VISUAL REPRESENTATION
---------------------
Matrix A: (m rows × n columns)
  [--- n columns ---]
  [                ]
m [      A          ]
  [                ]

Matrix B: (p rows × q columns)
  [--- q columns ---]
p [        B        ]

For A @ B to work: n must equal p

Result: (m rows × q columns)
  [--- q columns ---]
m [      Result      ]

EXAMPLES
--------
VALID:
  A: (3, 4) @ B: (4, 2) → Result: (3, 2)
  • A has 4 columns
  • B has 4 rows
  • Match! ✓

VALID:
  A: (2, 3) @ B: (3, 5) → Result: (2, 5)
  • A has 3 columns
  • B has 3 rows
  • Match! ✓

INVALID:
  A: (3, 4) @ B: (3, 2)
  • A has 4 columns
  • B has 3 rows
  • Mismatch! ✗

WHAT HAPPENS IF DIMENSIONS DON'T MATCH?
----------------------------------------
NumPy will raise a ValueError:

Code:
import numpy as np

A = np.array([[1, 2, 3], [4, 5, 6]])  # (2, 3)
B = np.array([[1, 2], [3, 4]])        # (2, 2)

try:
    result = A @ B
except ValueError as e:
    print(f"Error: {e}")

Output:
Error: matmul: Input operand 1 has a mismatch in its core dimension 0

EXPLANATION:
• A has 3 columns, B has 2 rows
• They don't match
• NumPy raises an error

[END SECTION 4.2]
================================================================================

SECTION 4.3: THE DOT PRODUCT CONCEPT
-------------------------------------

DEFINITION
----------
From matrix multiplication, to obtain the ith row and jth column of the new 
matrix, we take the dot product of the ith row of A with the jth column of B.

DETAILED EXPLANATION
--------------------
Understanding the dot product is crucial for understanding matrix 
multiplication. The dot product is how we combine a row from the first matrix 
with a column from the second matrix.

WHAT IS A DOT PRODUCT?
----------------------
The dot product of two vectors is:
• Multiply corresponding elements
• Sum all the products
• Result is a single number

EXAMPLE:
--------
Row vector:    [1, 2, 3]
Column vector: [4,
               5,
               6]

Dot product:
  1×4 + 2×5 + 3×6
  = 4 + 10 + 18
  = 32

STEP-BY-STEP PROCESS
--------------------
1. Take first element of row × first element of column
2. Take second element of row × second element of column
3. Take third element of row × third element of column
4. Sum all products

VISUAL REPRESENTATION
---------------------
For dot product of row [a, b, c] and column [d, e, f]:

  [a, b, c] · [d,   = a×d + b×e + c×f
               e,
               f]

Each pair multiplies, then sum.

PRACTICAL EXAMPLE
-----------------
Code:
import numpy as np

# Row vector
row = np.array([1, 2, 3])

# Column vector (as 1D array, we'll treat it as column)
col = np.array([4, 5, 6])

# Dot product
dot_product = np.dot(row, col)
# Or: dot_product = row @ col

print(f"Row: {row}")
print(f"Column: {col}")
print(f"Dot product: {dot_product}")
print(f"\nCalculation: 1×4 + 2×5 + 3×6 = {1*4} + {2*5} + {3*6} = {dot_product}")

Output:
Row: [1 2 3]
Column: [4 5 6]
Dot product: 32

Calculation: 1×4 + 2×5 + 3×6 = 4 + 10 + 18 = 32

[END SECTION 4.3]
================================================================================

SECTION 4.4: STEP-BY-STEP MATRIX MULTIPLICATION
-------------------------------------------------

DEFINITION
----------
For the first column, first row we take the dot product of the first row of A 
with the first column of B as follows. The result is zero. For the first row 
and the second column of the new matrix, we take the dot product of the first 
row of the matrix A, but this time we use the second column of matrix B, the 
result is two. For the second row and the first column of the new matrix, we 
take the dot product of the second row of the matrix A. With the first column 
of matrix B, the result is zero. Finally, for the second row and the second 
column of the new matrix, we take the dot product of the second row of the 
matrix A with the second column of matrix B, the result is two.

DETAILED EXPLANATION
--------------------
This section walks through matrix multiplication step by step, computing each 
element of the result matrix.

SETUP: DEFINE THE MATRICES
--------------------------
From the original material, we have matrices A and B. Let's use a concrete 
example:

Code:
import numpy as np

# Matrix A (each row is a different color in original)
A = np.array([[1, 0, -1],
              [0, 1, 0]])

# Matrix B (each column is a different color in original)
B = np.array([[0, 1],
              [1, 0],
              [0, 1]])

print("Matrix A:")
print(A)
print(f"Shape: {A.shape}")
print("\nMatrix B:")
print(B)
print(f"Shape: {B.shape}")

Output:
Matrix A:
[[ 1  0 -1]
 [ 0  1  0]]
Shape: (2, 3)

Matrix B:
[[0 1]
 [1 0]
 [0 1]]
Shape: (3, 2)

VERIFICATION:
• A has 3 columns
• B has 3 rows
• Match! ✓
• Result will be (2, 2)

STEP-BY-STEP COMPUTATION
-------------------------
We need to compute C = A @ B, which will be (2, 2).

COMPUTING ELEMENT C[0, 0] (FIRST ROW, FIRST COLUMN):
----------------------------------------------------
From original: "For the first column, first row we take the dot product of the 
first row of A with the first column of B as follows. The result is zero."

Process:
  Row 0 of A: [1, 0, -1]
  Column 0 of B: [0,
                  1,
                  0]

  Dot product:
    1×0 + 0×1 + (-1)×0
    = 0 + 0 + 0
    = 0

  C[0, 0] = 0

COMPUTING ELEMENT C[0, 1] (FIRST ROW, SECOND COLUMN):
------------------------------------------------------
From original: "For the first row and the second column of the new matrix, we 
take the dot product of the first row of the matrix A, but this time we use 
the second column of matrix B, the result is two."

Process:
  Row 0 of A: [1, 0, -1]
  Column 1 of B: [1,
                  0,
                  1]

  Dot product:
    1×1 + 0×0 + (-1)×1
    = 1 + 0 + (-1)
    = 0

Wait, the original says result is 2. Let me use the example from the original 
more carefully. Let me use a different example that matches the original 
description better.

Let me use this example instead:

Code:
import numpy as np

# Based on original material description
A = np.array([[1, 0, 1],
              [0, 1, 0]])

B = np.array([[0, 1],
              [1, 0],
              [1, 1]])

print("Matrix A:")
print(A)
print("\nMatrix B:")
print(B)

# Compute C = A @ B
C = A @ B

print("\nResult C = A @ B:")
print(C)

# Let's compute manually
print("\nManual computation:")
print("C[0,0] = dot product of row 0 of A and column 0 of B")
print(f"  = {A[0,0]}×{B[0,0]} + {A[0,1]}×{B[1,0]} + {A[0,2]}×{B[2,0]}")
print(f"  = {A[0,0]*B[0,0]} + {A[0,1]*B[1,0]} + {A[0,2]*B[2,0]}")
print(f"  = {C[0,0]}")

Actually, let me follow the original material more precisely. The original 
mentions specific results, so let me work backwards or use a clearer example.

Let me provide a comprehensive example that demonstrates the concept clearly:

COMPREHENSIVE EXAMPLE
---------------------
Code:
import numpy as np

# Define matrices
A = np.array([[1, 2],
              [3, 4]])

B = np.array([[5, 6],
              [7, 8]])

print("=" * 60)
print("MATRIX MULTIPLICATION STEP-BY-STEP")
print("=" * 60)
print("\nMatrix A (2×2):")
print(A)
print("\nMatrix B (2×2):")
print(B)

# Compute result
C = A @ B

print("\n" + "=" * 60)
print("COMPUTING EACH ELEMENT")
print("=" * 60)

# Element C[0, 0]
print("\nElement C[0, 0] (row 0, column 0):")
print(f"  Row 0 of A: {A[0, :]}")
print(f"  Column 0 of B: {B[:, 0]}")
dot_00 = A[0, 0]*B[0, 0] + A[0, 1]*B[1, 0]
print(f"  Dot product: {A[0,0]}×{B[0,0]} + {A[0,1]}×{B[1,0]} = {A[0,0]*B[0,0]} + {A[0,1]*B[1,0]} = {dot_00}")
print(f"  C[0, 0] = {dot_00}")

# Element C[0, 1]
print("\nElement C[0, 1] (row 0, column 1):")
print(f"  Row 0 of A: {A[0, :]}")
print(f"  Column 1 of B: {B[:, 1]}")
dot_01 = A[0, 0]*B[0, 1] + A[0, 1]*B[1, 1]
print(f"  Dot product: {A[0,0]}×{B[0,1]} + {A[0,1]}×{B[1,1]} = {A[0,0]*B[0,1]} + {A[0,1]*B[1,1]} = {dot_01}")
print(f"  C[0, 1] = {dot_01}")

# Element C[1, 0]
print("\nElement C[1, 0] (row 1, column 0):")
print(f"  Row 1 of A: {A[1, :]}")
print(f"  Column 0 of B: {B[:, 0]}")
dot_10 = A[1, 0]*B[0, 0] + A[1, 1]*B[1, 0]
print(f"  Dot product: {A[1,0]}×{B[0,0]} + {A[1,1]}×{B[1,0]} = {A[1,0]*B[0,0]} + {A[1,1]*B[1,0]} = {dot_10}")
print(f"  C[1, 0] = {dot_10}")

# Element C[1, 1]
print("\nElement C[1, 1] (row 1, column 1):")
print(f"  Row 1 of A: {A[1, :]}")
print(f"  Column 1 of B: {B[:, 1]}")
dot_11 = A[1, 0]*B[0, 1] + A[1, 1]*B[1, 1]
print(f"  Dot product: {A[1,0]}×{B[0,1]} + {A[1,1]}×{B[1,1]} = {A[1,0]*B[0,1]} + {A[1,1]*B[1,1]} = {dot_11}")
print(f"  C[1, 1] = {dot_11}")

print("\n" + "=" * 60)
print("FINAL RESULT")
print("=" * 60)
print("\nC = A @ B:")
print(C)
print(f"\nVerification:")
print(f"  Computed C[0,0] = {dot_00}, Actual C[0,0] = {C[0,0]}")
print(f"  Computed C[0,1] = {dot_01}, Actual C[0,1] = {C[0,1]}")
print(f"  Computed C[1,0] = {dot_10}, Actual C[1,0] = {C[1,0]}")
print(f"  Computed C[1,1] = {dot_11}, Actual C[1,1] = {C[1,1]}")

Output:
============================================================
MATRIX MULTIPLICATION STEP-BY-STEP
============================================================

Matrix A (2×2):
[[1 2]
 [3 4]]

Matrix B (2×2):
[[5 6]
 [7 8]]

============================================================
COMPUTING EACH ELEMENT
============================================================

Element C[0, 0] (row 0, column 0):
  Row 0 of A: [1 2]
  Column 0 of B: [5 7]
  Dot product: 1×5 + 2×7 = 5 + 14 = 19
  C[0, 0] = 19

Element C[0, 1] (row 0, column 1):
  Row 0 of A: [1 2]
  Column 1 of B: [6 8]
  Dot product: 1×6 + 2×8 = 6 + 16 = 22
  C[0, 1] = 22

Element C[1, 0] (row 1, column 0):
  Row 1 of A: [3 4]
  Column 0 of B: [5 7]
  Dot product: 3×5 + 4×7 = 15 + 28 = 43
  C[1, 0] = 43

Element C[1, 1] (row 1, column 1):
  Row 1 of A: [3 4]
  Column 1 of B: [6 8]
  Dot product: 3×6 + 4×8 = 18 + 32 = 50
  C[1, 1] = 50

============================================================
FINAL RESULT
============================================================

C = A @ B:
[[19 22]
 [43 50]]

Verification:
  Computed C[0,0] = 19, Actual C[0,0] = 19
  Computed C[0,1] = 22, Actual C[0,1] = 22
  Computed C[1,0] = 43, Actual C[1,0] = 43
  Computed C[1,1] = 50, Actual C[1,1] = 50

GENERAL FORMULA
---------------
For matrix multiplication C = A @ B:
  C[i, j] = sum over k of (A[i, k] × B[k, j])

In words:
  • Element at position (i, j) in result
  • = Dot product of row i of A and column j of B
  • = Sum of (element k of row i) × (element k of column j) for all k

[END SECTION 4.4]
================================================================================

SECTION 4.5: PRACTICAL EXAMPLES OF MATRIX MULTIPLICATION
----------------------------------------------------------

DEFINITION
----------
In NumPy, we can define the NumPy arrays A and B. We can perform matrix 
multiplication and assign it to array C. The result is the array C. It 
corresponds to the matrix multiplication of array A and B.

DETAILED EXPLANATION
--------------------
This section provides complete, practical examples of matrix multiplication 
using NumPy.

COMPLETE CODE EXAMPLE
---------------------
Code:
import numpy as np

# Define NumPy arrays A and B
A = np.array([[1, 2, 3],
              [4, 5, 6]])

B = np.array([[7, 8],
              [9, 10],
              [11, 12]])

# Perform matrix multiplication
C = A @ B

# Display results
print("=" * 60)
print("MATRIX MULTIPLICATION EXAMPLE")
print("=" * 60)
print("\nMatrix A:")
print(A)
print(f"Shape: {A.shape}")
print("\nMatrix B:")
print(B)
print(f"Shape: {B.shape}")
print("\nResult C = A @ B:")
print(C)
print(f"Shape: {C.shape}")

Output:
============================================================
MATRIX MULTIPLICATION EXAMPLE
============================================================

Matrix A:
[[1 2 3]
 [4 5 6]]
Shape: (2, 3)

Matrix B:
[[ 7  8]
 [ 9 10]
 [11 12]]
Shape: (3, 2)

Result C = A @ B:
[[ 58  64]
 [139 154]]
Shape: (2, 2)

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: import numpy as np
  • Imports NumPy library

Line 3-4: A = np.array([[1, 2, 3], [4, 5, 6]])
  • Creates matrix A with shape (2, 3)
  • 2 rows, 3 columns

Line 6-8: B = np.array([[7, 8], [9, 10], [11, 12]])
  • Creates matrix B with shape (3, 2)
  • 3 rows, 2 columns
  • Note: A has 3 columns, B has 3 rows → Compatible! ✓

Line 10: C = A @ B
  • @ operator performs matrix multiplication
  • Computes dot products of rows of A with columns of B
  • Result shape: (2, 2) - 2 rows from A, 2 columns from B

VERIFICATION OF RESULT
-----------------------
Let's verify C[0, 0]:
  Row 0 of A: [1, 2, 3]
  Column 0 of B: [7, 9, 11]
  Dot product: 1×7 + 2×9 + 3×11 = 7 + 18 + 33 = 58 ✓

Let's verify C[0, 1]:
  Row 0 of A: [1, 2, 3]
  Column 1 of B: [8, 10, 12]
  Dot product: 1×8 + 2×10 + 3×12 = 8 + 20 + 36 = 64 ✓

Let's verify C[1, 0]:
  Row 1 of A: [4, 5, 6]
  Column 0 of B: [7, 9, 11]
  Dot product: 4×7 + 5×9 + 6×11 = 28 + 45 + 66 = 139 ✓

Let's verify C[1, 1]:
  Row 1 of A: [4, 5, 6]
  Column 1 of B: [8, 10, 12]
  Dot product: 4×8 + 5×10 + 6×12 = 32 + 50 + 72 = 154 ✓

ALTERNATIVE METHODS
------------------
NumPy provides multiple ways to perform matrix multiplication:

METHOD 1: @ OPERATOR (PREFERRED)
  C = A @ B
  • Modern Python syntax (Python 3.5+)
  • Clean and readable
  • Recommended method

METHOD 2: np.dot() FUNCTION
  C = np.dot(A, B)
  • Traditional NumPy method
  • Works in all Python versions
  • More verbose

METHOD 3: np.matmul() FUNCTION
  C = np.matmul(A, B)
  • Explicit matrix multiplication function
  • Same as @ operator
  • More descriptive name

All three methods produce the same result!

ADDITIONAL EXAMPLES
-------------------
EXAMPLE 1: MULTIPLYING BY IDENTITY MATRIX
Code:
import numpy as np

A = np.array([[1, 2, 3],
              [4, 5, 6]])

I = np.eye(3)  # 3×3 identity matrix

result = A @ I

print("A:")
print(A)
print("\nIdentity I:")
print(I)
print("\nA @ I:")
print(result)
print("\nNote: A @ I = A (identity property)")

Output:
A:
[[1 2 3]
 [4 5 6]]

Identity I:
[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]

A @ I:
[[1. 2. 3.]
 [4. 5. 6.]]

EXPLANATION:
• Multiplying by identity matrix returns the original matrix
• This is a fundamental property of identity matrices
• A @ I = A (when dimensions are compatible)

EXAMPLE 2: NON-COMMUTATIVE PROPERTY
Code:
import numpy as np

A = np.array([[1, 2],
              [3, 4]])

B = np.array([[5, 6],
              [7, 8]])

AB = A @ B
BA = B @ A

print("A:")
print(A)
print("\nB:")
print(B)
print("\nA @ B:")
print(AB)
print("\nB @ A:")
print(BA)
print("\nNote: A @ B ≠ B @ A (matrix multiplication is not commutative)")

Output:
A:
[[1 2]
 [3 4]]

B:
[[5 6]
 [7 8]]

A @ B:
[[19 22]
 [43 50]]

B @ A:
[[23 34]
 [31 46]]

EXPLANATION:
• A @ B produces different result than B @ A
• Matrix multiplication is NOT commutative
• Order matters!

[END SECTION 4.5]
================================================================================

SUMMARY AND CONCLUSION
======================

Congratulations! You have completed Part 2 of the Two-Dimensional NumPy in 
Python comprehensive study guide. You have learned:

✓ Array addition (matrix addition) - element-wise addition
✓ Scalar multiplication - multiplying arrays by single numbers
✓ Element-wise multiplication (Hadamard product) - position-by-position 
  multiplication
✓ Matrix multiplication - dot product-based multiplication
✓ The differences between these operations
✓ When to use each operation
✓ How to perform each operation in NumPy

KEY TAKEAWAYS:
--------------
1. ARRAY ADDITION: X + Y (element-wise, same shape required)
2. SCALAR MULTIPLICATION: k * X (multiply all elements by k)
3. HADAMARD PRODUCT: X * Y (element-wise multiplication)
4. MATRIX MULTIPLICATION: X @ Y (dot products, compatible dimensions required)

REMEMBER:
• Addition and Hadamard product require same shapes
• Matrix multiplication requires compatible dimensions (cols of first = rows of 
  second)
• Use @ for matrix multiplication, * for Hadamard product
• Matrix multiplication is NOT commutative (A @ B ≠ B @ A)

NEXT STEPS:
-----------
• Practice with different array sizes
• Try combining operations (e.g., 2*X + Y)
• Experiment with real-world data
• Explore NumPy documentation at numpy.org for more advanced features

There is a lot more you can do with NumPy. Check out numpy.org for the full 
documentation and additional features.

================================================================================
END OF PART 2
================================================================================
