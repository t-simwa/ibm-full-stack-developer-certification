Dependencies or libraries are pre-written code to help solve problems. In this video, we will introduce Pandas, a popular library for data analysis. You can import the library or dependency, like Pandas, using the following command. Start with the import command followed by the name of the library. You now have access to a large number of pre-built classes and functions. This assumes the library is installed. In our lab environment, all the necessary libraries are installed. Let us say we would like to load a csv file using pandas build-in function, readcsv. A csv is a typical file type used to store data. Simply type the word Pandas, then a dot, and the name of the function with all the inputs. Writing pandas all the time may get difficult, so you can use the 'as' statement to shorten the name of the library. In this case, use the standard abbreviation pd. Now type pd. Next type a dot followed by the name of the function you would like to use. In this case, readcsv. You are not limited to the abbreviation pd. In this case, we use the term banana. However, we will stick with pd for the rest of this video. Let us examine this code in more detail. One way pandas allows you to work with data is in a DataFrame. Let us review the process of going from a csv file to a DataFrame. This variable stores the path of the csv. It is used as an argument to the readCSV function. The result is stored to the variable df. This is short for DataFrame. Now that you have the data in a DataFrame, you can work with it. You can use the method head to examine the first five rows of a DataFrame. The process for loading an Excel file is similar. Use the path of the Excel file, the function readexcel. The result is a DataFrame. A DataFrame is comprised of rows and columns. You can create a DataFrame out of a dictionary. The keys correspond to the column labels. The values are lists corresponding to the rows. You can then cast the dictionary to a DataFrame using the function DataFrame. Notice the direct correspondence between the table. The keys correspond to the table headers. The values are lists corresponding to the rows. Create a new DataFrame consisting of one column and close the DataFrame name, in this case df, and the name of the column header in double brackets. The result is a new DataFrame comprised of the original column. You can do the same thing for multiple columns. Enclose the DataFrame name, in this case df, and the name of multiple column headers in double brackets. The result is a new DataFrame comprised of the specified columns. One way to access unique elements is with the iloc method. The first input is an integer representing the row index, and the second is the integer representing the column index. You can access the first row and first column as follows. You can access the second row and first column as follows. You can access the first row, third column as follows, and you can access the second row, third column as follows. You can use the name of the row index and the column as well. You can access the first row of the column named Artist as follows. Similarly, you can access the second row of the column named Artist. You can do the same for the column Released. loc can also be used if the index is not an integer. We create a new DataFrame called df_new. We replace the index 1, 2, 3, and so on with ABC. You can access the index A, that is, the first row of the column named Artist as follows. Similarly, you can access the index B, or the second row of the column named Artist. You can do the same for the column Released. You can also slice DataFrames and assign the values to a new DataFrame. Assign the first two rows and the first three columns to the variable Z. The result is a DataFrame comprised of the selected rows and columns. You can also slice DataFrames and assign the values to a new DataFrame using loc. The code assigns the first two rows and all columns in between the columns named Artist and Released. The result is a new DataFrame Z with the corresponding values. Check out the labs for more examples.