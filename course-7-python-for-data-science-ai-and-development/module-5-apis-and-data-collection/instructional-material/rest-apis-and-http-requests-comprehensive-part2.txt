================================================================================
REST APIs AND HTTP REQUESTS
Comprehensive Study Guide - Part 2
================================================================================

WELCOME TO PART 2
-----------------
This is Part 2 of the REST APIs and HTTP Requests comprehensive study guide. 
In Part 1, you learned about the HTTP protocol, URLs, and the fundamentals of 
web communication. In this part, you will dive deep into HTTP requests, HTTP 
responses, status codes, and HTTP methods.

ESTIMATED TIME NEEDED
---------------------
5 minutes (for basic reading)
90-120 minutes (for comprehensive study with practice)

LEARNING OBJECTIVES
-------------------
After studying this part, you will be able to:
• Understand the complete structure of HTTP requests
• Explain each component of an HTTP request (start line, headers, body)
• Understand the complete structure of HTTP responses
• Explain each component of an HTTP response (status line, headers, body)
• Recognize and understand HTTP status codes (100s, 200s, 300s, 400s, 500s)
• Explain what each status code means and when it's used
• Understand different HTTP methods (GET, POST, PUT, DELETE, etc.)
• Know when to use each HTTP method
• Understand request headers and their purposes
• Understand response headers and their purposes

OVERVIEW
--------
In this part, we will explore:
• The detailed structure of HTTP requests
• The request start line (method, path, version)
• Request headers and what they do
• Request bodies and when they're used
• The detailed structure of HTTP responses
• The response status line (version, status code, status text)
• Response headers and what they do
• Response bodies and their content
• HTTP status codes in detail (all categories)
• HTTP methods and their purposes
• Practical examples with line-by-line explanations

================================================================================
TABLE OF CONTENTS - PART 2
================================================================================

PART 3: HTTP REQUESTS IN DETAIL
  SECTION 3.1: UNDERSTANDING HTTP REQUESTS
  SECTION 3.2: THE REQUEST START LINE
  SECTION 3.3: REQUEST HEADERS
  SECTION 3.4: REQUEST BODY

PART 4: HTTP RESPONSES IN DETAIL
  SECTION 4.1: UNDERSTANDING HTTP RESPONSES
  SECTION 4.2: THE RESPONSE STATUS LINE
  SECTION 4.3: RESPONSE HEADERS
  SECTION 4.4: RESPONSE BODY

PART 5: HTTP STATUS CODES
  SECTION 5.1: UNDERSTANDING STATUS CODES
  SECTION 5.2: 100s - INFORMATIONAL RESPONSES
  SECTION 5.3: 200s - SUCCESSFUL RESPONSES
  SECTION 5.4: 400s - CLIENT ERRORS
  SECTION 5.5: 500s - SERVER ERRORS

PART 6: HTTP METHODS
  SECTION 6.1: UNDERSTANDING HTTP METHODS
  SECTION 6.2: GET METHOD
  SECTION 6.3: POST METHOD
  SECTION 6.4: OTHER HTTP METHODS

NOTE: Part 3 (if needed) will cover practical examples, code implementations, 
and advanced topics.

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 3.3:") to quickly jump to any section.

================================================================================
PART 3: HTTP REQUESTS IN DETAIL
================================================================================

SECTION 3.1: UNDERSTANDING HTTP REQUESTS
-----------------------------------------

DEFINITION
----------
An HTTP request is a message sent from a client (like your browser) to a server 
to request a resource or perform an action. The following is an example of the 
request message for the GET request method. There are other HTTP methods we 
can use.

DETAILED EXPLANATION
--------------------
An HTTP request is how clients communicate with servers. It's the "question" 
or "command" that the client sends to the server. Every time you visit a 
website, click a link, submit a form, or use an API, your browser or 
application sends an HTTP request.

WHAT IS AN HTTP REQUEST?
------------------------
An HTTP request is:
• A formatted message from client to server
• Contains what the client wants
• Includes how to get it (method)
• Includes where to get it (URL/path)
• May include additional data (headers, body)

REAL-WORLD ANALOGY
------------------
Think of an HTTP request like ordering at a restaurant:

• HTTP Request = Your order
• Method (GET) = "I want to see..." or "Give me..."
• Path (/menu) = What you want (the menu)
• Headers = Special instructions (dietary restrictions, etc.)
• Body = Additional details (if ordering food, what you want)

The waiter (server) takes your order (request) and brings back what you asked 
for (response).

THE PURPOSE OF HTTP REQUESTS
----------------------------
HTTP requests serve several purposes:

1. RETRIEVE RESOURCES
   • Get web pages, images, files
   • Fetch data from APIs
   • Download content

2. SUBMIT DATA
   • Send form data
   • Create new resources
   • Upload files

3. UPDATE RESOURCES
   • Modify existing data
   • Update records
   • Change settings

4. DELETE RESOURCES
   • Remove data
   • Delete files
   • Remove records

5. PERFORM ACTIONS
   • Execute operations
   • Trigger processes
   • Run commands

THE STRUCTURE OF AN HTTP REQUEST
---------------------------------
An HTTP request has three main parts:

1. REQUEST LINE (Start Line)
   • First line of the request
   • Contains: Method, Path, HTTP Version
   • Example: GET /index.html HTTP/1.1

2. REQUEST HEADERS
   • Additional information
   • Key-value pairs
   • Multiple headers allowed
   • Example: Host: www.example.com

3. REQUEST BODY (optional)
   • Data being sent
   • Only in some requests (POST, PUT, etc.)
   • Example: JSON data, form data

VISUAL STRUCTURE
----------------
HTTP REQUEST STRUCTURE:

┌─────────────────────────────────────┐
│ REQUEST LINE                        │
│ GET /index.html HTTP/1.1            │
├─────────────────────────────────────┤
│ HEADERS                             │
│ Host: www.example.com               │
│ User-Agent: Mozilla/5.0             │
│ Accept: text/html                   │
├─────────────────────────────────────┤
│ (blank line)                        │
├─────────────────────────────────────┤
│ BODY (optional)                      │
│ { "name": "John" }                 │
└─────────────────────────────────────┘

EXAMPLE: COMPLETE HTTP REQUEST
-------------------------------
Here's a complete HTTP request example:

GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml
Accept-Language: en-US,en;q=0.9
Connection: keep-alive

BREAKDOWN:
----------
• Line 1: Request line (method, path, version)
• Lines 2-6: Headers (additional information)
• Line 7: Blank line (separates headers from body)
• No body (GET requests typically don't have bodies)

WHAT HAPPENS WHEN A REQUEST IS SENT?
------------------------------------
1. CLIENT CREATES REQUEST
   • Browser/application formats the request
   • Includes method, path, headers
   • Adds body if needed

2. REQUEST IS SENT
   • Over the internet
   • Through network infrastructure
   • To the server

3. SERVER RECEIVES REQUEST
   • Server reads the request
   • Parses the method, path, headers
   • Processes the request

4. SERVER PROCESSES REQUEST
   • Finds the resource
   • Performs the action
   • Prepares response

5. SERVER SENDS RESPONSE
   • Creates HTTP response
   • Sends back to client

[END SECTION 3.1]
================================================================================

SECTION 3.2: THE REQUEST START LINE
------------------------------------

DEFINITION
----------
In the start line we have the GET method. This is an HTTP method. In this 
case, it's requesting the file index.html. The request start line contains 
the HTTP method, the resource path, and the HTTP version.

DETAILED EXPLANATION
--------------------
The request start line (also called the request line) is the first line of 
every HTTP request. It's the most important line because it tells the server 
exactly what the client wants to do and what resource it wants to access.

WHAT IS THE REQUEST START LINE?
--------------------------------
The request start line is:
• The first line of an HTTP request
• Contains three essential pieces of information
• Format: METHOD PATH HTTP/VERSION
• Example: GET /index.html HTTP/1.1

THE THREE COMPONENTS OF THE START LINE
---------------------------------------
1. HTTP METHOD
   • What action to perform
   • Examples: GET, POST, PUT, DELETE
   • Tells server what to do

2. RESOURCE PATH
   • What resource to access
   • Examples: /index.html, /api/users, /images/logo.png
   • Tells server what you want

3. HTTP VERSION
   • Which HTTP version to use
   • Examples: HTTP/1.0, HTTP/1.1, HTTP/2.0
   • Tells server which protocol version

FORMAT
------
The format is:

METHOD SPACE PATH SPACE HTTP/VERSION

Where:
• METHOD = HTTP method (GET, POST, etc.)
• SPACE = A single space character
• PATH = Resource path (/index.html, etc.)
• HTTP/VERSION = Protocol version (HTTP/1.1, etc.)

EXAMPLES OF REQUEST START LINES
--------------------------------
1. GET /index.html HTTP/1.1
   • Method: GET (retrieve)
   • Path: /index.html (home page)
   • Version: HTTP/1.1

2. POST /api/users HTTP/1.1
   • Method: POST (create)
   • Path: /api/users (users endpoint)
   • Version: HTTP/1.1

3. PUT /api/users/123 HTTP/1.1
   • Method: PUT (update)
   • Path: /api/users/123 (user ID 123)
   • Version: HTTP/1.1

4. DELETE /api/users/123 HTTP/1.1
   • Method: DELETE (remove)
   • Path: /api/users/123 (user ID 123)
   • Version: HTTP/1.1

COMPONENT 1: HTTP METHOD
-------------------------
The HTTP method tells the server what action to perform:

• GET = Retrieve/read data
• POST = Create new data
• PUT = Update/replace data
• DELETE = Remove data
• PATCH = Partially update data
• HEAD = Get headers only (no body)
• OPTIONS = Get allowed methods

EXAMPLE BREAKDOWN: GET /index.html HTTP/1.1
--------------------------------------------
GET
• This is the HTTP method
• GET means "retrieve" or "fetch"
• Used to get a resource from the server
• Does not modify data
• Idempotent (same request = same result)

/index.html
• This is the resource path
• Tells server which file/resource you want
• / means root directory
• index.html is the file name
• Server will look for this file

HTTP/1.1
• This is the HTTP version
• 1.1 is a common version
• Tells server which protocol features to use
• Different versions have different capabilities

WHY IS THE START LINE IMPORTANT?
---------------------------------
The start line is crucial because:

1. FIRST THING SERVER READS
   • Server reads this first
   • Determines how to handle the request
   • Most important information

2. DETERMINES ROUTING
   • Method determines what code runs
   • Path determines which resource
   • Server uses this to route the request

3. AFFECTS PROCESSING
   • Different methods = different processing
   • Server behaves differently based on method
   • Security checks depend on method

4. REQUIRED INFORMATION
   • Every request MUST have a start line
   • Without it, server can't process request
   • Must be properly formatted

WHAT IF THE START LINE IS WRONG?
---------------------------------
If the start line is malformed:
• Server returns 400 Bad Request
• Request is rejected
• Client gets an error
• Nothing is processed

Examples of bad start lines:
• GET/index.html HTTP/1.1 (missing space)
• GET /index.htmlHTTP/1.1 (missing space)
• /index.html HTTP/1.1 (missing method)
• GET /index.html (missing version)

All must be properly formatted with spaces.

[END SECTION 3.2]
================================================================================

SECTION 3.3: REQUEST HEADERS
------------------------------

DEFINITION
----------
The Request header passes additional information with an HTTP request. In the 
GET method the Request header is empty. Some Requests have a body; we will 
have an example of a request body later.

DETAILED EXPLANATION
--------------------
Request headers provide additional information about the request. They give 
the server context about the client, what the client can accept, and how the 
request should be processed. While the start line tells the server WHAT to do, 
headers tell the server HOW to do it and provide additional context.

WHAT ARE REQUEST HEADERS?
-------------------------
Request headers are:
• Additional information sent with the request
• Key-value pairs (Header-Name: value)
• Provide context and instructions
• Help server process the request correctly

REAL-WORLD ANALOGY
------------------
Think of request headers like special instructions on an order:

• Request Line = Your main order ("I want a pizza")
• Headers = Special instructions ("Extra cheese", "No onions", "Delivery to 
  address 123 Main St")

The headers provide additional details that help fulfill the request correctly.

THE FORMAT OF HEADERS
---------------------
Headers follow this format:

Header-Name: value

Examples:
• Host: www.example.com
• User-Agent: Mozilla/5.0
• Accept: text/html

Important rules:
• Header name and value separated by colon and space
• One header per line
• Multiple headers allowed
• Case-insensitive (but conventionally capitalized)

COMMON REQUEST HEADERS
----------------------
Here are common request headers and what they do:

1. HOST
   • Required in HTTP/1.1
   • Specifies the server domain
   • Example: Host: www.example.com
   • Tells server which website you want

2. USER-AGENT
   • Identifies the client software
   • Browser or application information
   • Example: User-Agent: Mozilla/5.0
   • Helps server provide appropriate content

3. ACCEPT
   • What content types client accepts
   • Example: Accept: text/html,application/json
   • Tells server what formats are acceptable

4. ACCEPT-LANGUAGE
   • Preferred languages
   • Example: Accept-Language: en-US,en;q=0.9
   • Helps server provide localized content

5. ACCEPT-ENCODING
   • What compression client supports
   • Example: Accept-Encoding: gzip, deflate
   • Allows server to compress responses

6. AUTHORIZATION
   • Authentication credentials
   • Example: Authorization: Bearer token123
   • Proves client has permission

7. CONTENT-TYPE
   • Type of data in request body
   • Example: Content-Type: application/json
   • Tells server how to parse the body

8. CONTENT-LENGTH
   • Size of request body in bytes
   • Example: Content-Length: 1234
   • Helps server know when body is complete

9. COOKIE
   • Stored cookies to send
   • Example: Cookie: session=abc123; theme=dark
   • Maintains state between requests

10. REFERER
    • Where the request came from
    • Example: Referer: https://www.google.com
    • Helps with analytics and security

EXAMPLE: REQUEST WITH HEADERS
------------------------------
Here's a complete request with headers:

GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language: en-US,en;q=0.9
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Upgrade-Insecure-Requests: 1

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: GET /index.html HTTP/1.1
        • Request line (method, path, version)

Line 2: Host: www.example.com
        • Required header
        • Specifies the server domain
        • Tells server which website

Line 3: User-Agent: Mozilla/5.0...
        • Browser identification
        • Tells server what browser is being used
        • Helps server provide compatible content

Line 4: Accept: text/html,application/xhtml+xml...
        • Content types client accepts
        • text/html preferred
        • application/xhtml+xml as alternative
        • q=0.9 is quality factor (preference)

Line 5: Accept-Language: en-US,en;q=0.9
        • Preferred language is US English
        • English as fallback
        • q=0.9 means 90% preference

Line 6: Accept-Encoding: gzip, deflate, br
        • Compression methods client supports
        • gzip, deflate, brotli (br)
        • Server can compress response

Line 7: Connection: keep-alive
        • Keep connection open for reuse
        • More efficient than closing after each request

Line 8: Upgrade-Insecure-Requests: 1
        • Prefer secure connections
        • Browser preference for HTTPS

WHAT DOES "IN THE GET METHOD THE REQUEST HEADER IS EMPTY" MEAN?
----------------------------------------------------------------
This statement means that for GET requests:
• Headers are not empty (they still exist)
• But GET requests typically don't have a request BODY
• The statement might be confusing - it likely means the body is empty

GET requests:
• Usually have headers (Host, User-Agent, etc.)
• Usually don't have a body (no data being sent)
• Headers provide context, but no body data

HOW SERVERS USE HEADERS
-----------------------
Servers use headers to:

1. ROUTE REQUESTS
   • Host header determines which website
   • Virtual hosting uses Host header

2. FORMAT RESPONSES
   • Accept header determines response format
   • Accept-Language determines language

3. AUTHENTICATE
   • Authorization header checks permissions
   • Cookie header maintains sessions

4. OPTIMIZE
   • Accept-Encoding allows compression
   • Connection header manages connections

5. SECURITY
   • Referer header checks request source
   • User-Agent helps detect bots

OPTIONAL VS REQUIRED HEADERS
----------------------------
Some headers are required, others are optional:

REQUIRED (HTTP/1.1):
• Host - Must be present

OPTIONAL (but commonly used):
• User-Agent - Usually sent by browsers
• Accept - Helps server format response
• Accept-Language - For localization
• Authorization - For authenticated requests
• Content-Type - When body is present
• Content-Length - When body is present

[END SECTION 3.3]
================================================================================

SECTION 3.4: REQUEST BODY
--------------------------

DEFINITION
----------
Some Requests have a body; we will have an example of a request body later. 
The request body contains data being sent to the server, typically used with 
POST, PUT, and PATCH methods.

DETAILED EXPLANATION
--------------------
The request body is the part of an HTTP request that contains the actual data 
being sent to the server. Not all requests have a body - GET and DELETE 
requests typically don't have bodies, while POST, PUT, and PATCH requests 
usually do.

WHAT IS A REQUEST BODY?
------------------------
A request body is:
• Data sent to the server
• Optional (not all requests have one)
• Comes after headers (separated by blank line)
• Contains the actual content/data

WHEN IS A REQUEST BODY USED?
----------------------------
Request bodies are used when:

1. CREATING DATA (POST)
   • Sending new data to create a resource
   • Example: Creating a new user account

2. UPDATING DATA (PUT/PATCH)
   • Sending data to update a resource
   • Example: Updating user information

3. SENDING FORM DATA
   • Submitting form information
   • Example: Contact form submission

4. UPLOADING FILES
   • Sending file data
   • Example: Uploading an image

WHEN IS A REQUEST BODY NOT USED?
---------------------------------
Request bodies are typically NOT used with:

1. GET REQUESTS
   • Just retrieving data
   • No data to send
   • Body is empty or absent

2. DELETE REQUESTS
   • Just removing data
   • Usually no body needed
   • Resource identified by URL

3. HEAD REQUESTS
   • Just getting headers
   • No body needed
   • Body is never returned

THE FORMAT OF REQUEST BODIES
-----------------------------
Request bodies can be in various formats:

1. JSON (most common for APIs)
   Content-Type: application/json
   {
     "name": "John Doe",
     "email": "john@example.com"
   }

2. FORM DATA
   Content-Type: application/x-www-form-urlencoded
   name=John+Doe&email=john%40example.com

3. MULTIPART FORM DATA
   Content-Type: multipart/form-data
   (used for file uploads)

4. XML
   Content-Type: application/xml
   <user><name>John</name></user>

5. PLAIN TEXT
   Content-Type: text/plain
   This is plain text data

EXAMPLE: POST REQUEST WITH BODY
--------------------------------
Here's a complete POST request with a JSON body:

POST /api/users HTTP/1.1
Host: api.example.com
Content-Type: application/json
Content-Length: 45
Authorization: Bearer abc123xyz

{
  "name": "John Doe",
  "email": "john@example.com"
}

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: POST /api/users HTTP/1.1
        • POST method (creating new resource)
        • /api/users endpoint
        • HTTP/1.1 version

Line 2: Host: api.example.com
        • Server domain

Line 3: Content-Type: application/json
        • Body is JSON format
        • Tells server how to parse body

Line 4: Content-Length: 45
        • Body is 45 bytes
        • Helps server know when body ends

Line 5: Authorization: Bearer abc123xyz
        • Authentication token
        • Proves client has permission

Line 6: (blank line)
        • Separates headers from body
        • Required!

Lines 7-10: JSON body
        • Actual data being sent
        • Name and email for new user
        • Server will use this to create user

EXAMPLE: PUT REQUEST WITH BODY
-------------------------------
Here's a PUT request updating a user:

PUT /api/users/123 HTTP/1.1
Host: api.example.com
Content-Type: application/json
Content-Length: 38

{
  "name": "Jane Doe",
  "email": "jane@example.com"
}

This updates user 123 with new name and email.

EXAMPLE: FORM DATA IN BODY
--------------------------
Here's a POST request with form data:

POST /contact HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 28

name=John+Doe&email=john%40example.com

• Form data format
• URL-encoded (spaces become +, @ becomes %40)
• Common for HTML forms

THE BLANK LINE SEPARATOR
------------------------
The blank line between headers and body is CRITICAL:

• Must be present (even if no body)
• Separates headers from body
• Without it, body might be interpreted as headers
• Standard HTTP requirement

CORRECT:
--------
POST /api/users HTTP/1.1
Host: api.example.com
Content-Type: application/json

{ "name": "John" }

INCORRECT:
----------
POST /api/users HTTP/1.1
Host: api.example.com
Content-Type: application/json
{ "name": "John" }
(Missing blank line - will cause errors!)

HOW SERVERS PROCESS REQUEST BODIES
-----------------------------------
1. Server reads Content-Type header
2. Server knows what format to expect
3. Server reads Content-Length (if present)
4. Server reads that many bytes
5. Server parses body according to Content-Type
6. Server uses parsed data

Example flow:
• Content-Type: application/json
• Server knows to parse as JSON
• Reads JSON body
• Parses into data structure
• Uses data to create/update resource

[END SECTION 3.4]
================================================================================

PART 4: HTTP RESPONSES IN DETAIL
================================================================================

SECTION 4.1: UNDERSTANDING HTTP RESPONSES
------------------------------------------

DEFINITION
----------
The following table represents the response. The response start line contains 
the version number followed by a descriptive phrase. In this case, HTTP/1.0 a 
status code (200) meaning success, and the descriptive phrase, OK. The response 
header contains information. Finally, we have the response body containing 
the requested file, in this case an HTML document.

DETAILED EXPLANATION
--------------------
An HTTP response is the message that a server sends back to a client after 
processing an HTTP request. It contains the result of the request - whether 
it was successful, what data was returned, and additional information about 
the response.

WHAT IS AN HTTP RESPONSE?
-------------------------
An HTTP response is:
• A message from server to client
• Sent after processing a request
• Contains the result and data
• Follows a specific structure

REAL-WORLD ANALOGY
------------------
Think of an HTTP response like a package delivery:

• HTTP Request = Your order
• HTTP Response = The package with your order
• Status Code = Delivery confirmation (delivered, delayed, etc.)
• Headers = Package label (sender, weight, contents)
• Body = The actual items you ordered

THE PURPOSE OF HTTP RESPONSES
-----------------------------
HTTP responses serve to:

1. CONFIRM REQUEST PROCESSING
   • Tell client if request succeeded
   • Provide status information
   • Indicate any errors

2. RETURN REQUESTED DATA
   • Send the resource requested
   • Provide API data
   • Return files or content

3. PROVIDE METADATA
   • Headers give additional info
   • Content type, size, date
   • Caching instructions

4. HANDLE ERRORS
   • Inform client of problems
   • Provide error details
   • Suggest solutions

THE STRUCTURE OF AN HTTP RESPONSE
----------------------------------
An HTTP response has three main parts:

1. STATUS LINE (Response Start Line)
   • First line of the response
   • Contains: HTTP Version, Status Code, Status Text
   • Example: HTTP/1.1 200 OK

2. RESPONSE HEADERS
   • Additional information
   • Key-value pairs
   • Multiple headers allowed
   • Example: Content-Type: text/html

3. RESPONSE BODY
   • The actual content/data
   • What was requested
   • Example: HTML, JSON, image data

VISUAL STRUCTURE
----------------
HTTP RESPONSE STRUCTURE:

┌─────────────────────────────────────┐
│ STATUS LINE                         │
│ HTTP/1.1 200 OK                    │
├─────────────────────────────────────┤
│ HEADERS                             │
│ Content-Type: text/html             │
│ Content-Length: 1234                │
│ Date: Mon, 15 Jan 2024 10:00:00 GMT│
├─────────────────────────────────────┤
│ (blank line)                        │
├─────────────────────────────────────┤
│ BODY                                │
│ <html>...</html>                    │
└─────────────────────────────────────┘

EXAMPLE: COMPLETE HTTP RESPONSE
--------------------------------
Here's a complete HTTP response:

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234
Date: Mon, 15 Jan 2024 10:00:00 GMT
Server: Apache/2.4.41

<!DOCTYPE html>
<html>
<head>
  <title>Example Page</title>
</head>
<body>
  <h1>Welcome</h1>
  <p>This is an example page.</p>
</body>
</html>

BREAKDOWN:
----------
• Line 1: Status line (version, code, text)
• Lines 2-5: Headers (metadata)
• Line 6: Blank line (separator)
• Lines 7-15: Body (HTML content)

WHAT HAPPENS WHEN A RESPONSE IS SENT?
--------------------------------------
1. SERVER PROCESSES REQUEST
   • Server receives and processes request
   • Finds or generates resource
   • Determines success/failure

2. SERVER CREATES RESPONSE
   • Builds status line
   • Adds headers
   • Includes body content

3. RESPONSE IS SENT
   • Over the internet
   • Back to the client
   • Through network infrastructure

4. CLIENT RECEIVES RESPONSE
   • Client reads status code
   • Client reads headers
   • Client reads body
   • Client processes/displays content

[END SECTION 4.1]
================================================================================

SECTION 4.2: THE RESPONSE STATUS LINE
--------------------------------------

DEFINITION
----------
The response start line contains the version number followed by a descriptive 
phrase. In this case, HTTP/1.0 a status code (200) meaning success, and the 
descriptive phrase, OK.

DETAILED EXPLANATION
--------------------
The response status line (also called the status line) is the first line of 
every HTTP response. It's the most important line because it tells the client 
whether the request was successful and provides a status code that indicates 
the result.

WHAT IS THE RESPONSE STATUS LINE?
----------------------------------
The response status line is:
• The first line of an HTTP response
• Contains three essential pieces of information
• Format: HTTP/VERSION STATUS_CODE STATUS_TEXT
• Example: HTTP/1.1 200 OK

THE THREE COMPONENTS OF THE STATUS LINE
----------------------------------------
1. HTTP VERSION
   • Which HTTP version was used
   • Examples: HTTP/1.0, HTTP/1.1, HTTP/2.0
   • Usually matches request version

2. STATUS CODE
   • Numeric code indicating result
   • Examples: 200, 404, 500
   • Three-digit number

3. STATUS TEXT
   • Human-readable description
   • Examples: OK, Not Found, Internal Server Error
   • Descriptive phrase

FORMAT
------
The format is:

HTTP/VERSION SPACE STATUS_CODE SPACE STATUS_TEXT

Where:
• HTTP/VERSION = Protocol version (HTTP/1.1, etc.)
• SPACE = A single space character
• STATUS_CODE = Three-digit number (200, 404, etc.)
• STATUS_TEXT = Descriptive phrase (OK, Not Found, etc.)

EXAMPLES OF STATUS LINES
------------------------
1. HTTP/1.1 200 OK
   • Version: HTTP/1.1
   • Code: 200 (success)
   • Text: OK

2. HTTP/1.1 404 Not Found
   • Version: HTTP/1.1
   • Code: 404 (not found)
   • Text: Not Found

3. HTTP/1.1 500 Internal Server Error
   • Version: HTTP/1.1
   • Code: 500 (server error)
   • Text: Internal Server Error

4. HTTP/1.0 201 Created
   • Version: HTTP/1.0
   • Code: 201 (created)
   • Text: Created

COMPONENT 1: HTTP VERSION
--------------------------
The HTTP version indicates:
• Which protocol version was used
• Usually matches the request version
• Affects which features are available

Common versions:
• HTTP/1.0 - Older version, simpler
• HTTP/1.1 - Common, widely used
• HTTP/2.0 - Newer, more efficient

COMPONENT 2: STATUS CODE
--------------------------
The status code is a three-digit number:
• First digit indicates the category
• 1xx = Informational
• 2xx = Success
• 3xx = Redirection
• 4xx = Client Error
• 5xx = Server Error

We'll cover status codes in detail in Part 5.

COMPONENT 3: STATUS TEXT
-------------------------
The status text is:
• Human-readable description
• Helps developers understand the code
• Not used by programs (code is what matters)
• Examples: OK, Not Found, Created

EXAMPLE BREAKDOWN: HTTP/1.1 200 OK
------------------------------------
HTTP/1.1
• Protocol version
• Version 1.1 was used
• Common version

200
• Status code
• 2xx means success
• 200 specifically means "OK" (request succeeded)

OK
• Status text
• Human-readable description
• Confirms success

WHY IS THE STATUS LINE IMPORTANT?
---------------------------------
The status line is crucial because:

1. FIRST THING CLIENT READS
   • Client reads this first
   • Determines how to handle response
   • Most important information

2. DETERMINES SUCCESS/FAILURE
   • Status code tells if request succeeded
   • Client can react accordingly
   • Different codes = different handling

3. AFFECTS PROCESSING
   • Success (2xx) = Process body
   • Error (4xx/5xx) = Show error
   • Redirect (3xx) = Follow redirect

4. REQUIRED INFORMATION
   • Every response MUST have a status line
   • Without it, client can't process response
   • Must be properly formatted

WHAT IF THE STATUS LINE IS WRONG?
----------------------------------
If the status line is malformed:
• Client may not understand response
• Response might be rejected
• Error handling might fail
• User experience suffers

Examples of bad status lines:
• HTTP/1.1200 OK (missing space)
• HTTP/1.1 200OK (missing space)
• 200 OK (missing version)
• HTTP/1.1 200 (missing status text)

All must be properly formatted with spaces.

[END SECTION 4.2]
================================================================================

SECTION 4.3: RESPONSE HEADERS
------------------------------

DEFINITION
----------
The response header contains information. Response headers provide metadata 
about the response, including content type, size, date, and other important 
information.

DETAILED EXPLANATION
--------------------
Response headers provide additional information about the response. They tell 
the client about the content, how to handle it, caching instructions, and 
other metadata that helps the client process and display the response 
correctly.

WHAT ARE RESPONSE HEADERS?
---------------------------
Response headers are:
• Additional information about the response
• Key-value pairs (Header-Name: value)
• Provide metadata and instructions
• Help client process response correctly

REAL-WORLD ANALOGY
------------------
Think of response headers like a package label:

• Response Body = The package contents
• Response Headers = The shipping label
• Label tells you: sender, weight, contents, handling instructions

The headers provide context about what's in the response.

COMMON RESPONSE HEADERS
-----------------------
Here are common response headers and what they do:

1. CONTENT-TYPE
   • Type of content in body
   • Example: Content-Type: text/html
   • Tells client how to interpret body

2. CONTENT-LENGTH
   • Size of body in bytes
   • Example: Content-Length: 1234
   • Helps client know when body is complete

3. DATE
   • When response was sent
   • Example: Date: Mon, 15 Jan 2024 10:00:00 GMT
   • Useful for caching and logging

4. SERVER
   • Server software information
   • Example: Server: Apache/2.4.41
   • Identifies server software

5. CACHE-CONTROL
   • Caching instructions
   • Example: Cache-Control: no-cache
   • Tells client how to cache response

6. SET-COOKIE
   • Cookies to set
   • Example: Set-Cookie: session=abc123; Path=/
   • Maintains state

7. LOCATION
   • Redirect location
   • Example: Location: https://www.example.com/new-page
   • Used with 3xx redirect codes

8. ETAG
   • Resource version identifier
   • Example: ETag: "abc123"
   • Used for caching validation

9. LAST-MODIFIED
   • When resource was last changed
   • Example: Last-Modified: Mon, 15 Jan 2024 09:00:00 GMT
   • Used for caching

10. ACCESS-CONTROL-ALLOW-ORIGIN
    • CORS header
    • Example: Access-Control-Allow-Origin: *
    • Allows cross-origin requests

EXAMPLE: RESPONSE WITH HEADERS
-------------------------------
Here's a complete response with headers:

HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 1234
Date: Mon, 15 Jan 2024 10:00:00 GMT
Server: Apache/2.4.41
Cache-Control: max-age=3600
ETag: "abc123def456"

<!DOCTYPE html>
<html>
  <body>
    <h1>Welcome</h1>
  </body>
</html>

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: HTTP/1.1 200 OK
        • Status line (version, code, text)

Line 2: Content-Type: text/html; charset=UTF-8
        • Body is HTML
        • Character encoding is UTF-8
        • Tells browser how to display

Line 3: Content-Length: 1234
        • Body is 1234 bytes
        • Helps browser know when done reading

Line 4: Date: Mon, 15 Jan 2024 10:00:00 GMT
        • When response was sent
        • GMT timezone
        • Useful for caching

Line 5: Server: Apache/2.4.41
        • Server software
        • Apache web server, version 2.4.41

Line 6: Cache-Control: max-age=3600
        • Can cache for 3600 seconds (1 hour)
        • Tells browser caching rules

Line 7: ETag: "abc123def456"
        • Resource version identifier
        • Used for cache validation

Line 8: (blank line)
        • Separates headers from body

Lines 9-15: HTML body
        • Actual content
        • What browser displays

HOW CLIENTS USE RESPONSE HEADERS
---------------------------------
Clients use headers to:

1. INTERPRET CONTENT
   • Content-Type tells how to parse body
   • Browser uses this to display correctly

2. MANAGE CACHING
   • Cache-Control, ETag, Last-Modified
   • Browser caches based on these

3. HANDLE REDIRECTS
   • Location header for redirects
   • Browser follows redirect

4. SET COOKIES
   • Set-Cookie header
   • Browser stores cookies

5. SECURITY
   • CORS headers
   • Security policies

CONTENT-TYPE HEADER IN DETAIL
------------------------------
The Content-Type header is crucial:

Format: Content-Type: type/subtype; parameters

Examples:
• Content-Type: text/html
  - HTML content

• Content-Type: application/json
  - JSON data

• Content-Type: image/png
  - PNG image

• Content-Type: text/html; charset=UTF-8
  - HTML with UTF-8 encoding

• Content-Type: application/json; charset=utf-8
  - JSON with UTF-8 encoding

The client uses this to:
• Parse the body correctly
• Display content appropriately
• Handle different data types

[END SECTION 4.3]
================================================================================

SECTION 4.4: RESPONSE BODY
---------------------------

DEFINITION
----------
Finally, we have the response body containing the requested file, in this case 
an HTML document. The response body contains the actual content or data that 
was requested.

DETAILED EXPLANATION
--------------------
The response body is the part of an HTTP response that contains the actual 
content or data being returned to the client. This is what the client 
requested - whether it's a web page, API data, an image, or any other 
resource.

WHAT IS A RESPONSE BODY?
------------------------
A response body is:
• The actual content/data in the response
• What was requested
• Can be HTML, JSON, images, files, etc.
• Separated from headers by a blank line

REAL-WORLD ANALOGY
------------------
Think of the response body like the contents of a package:

• HTTP Request = Your order
• HTTP Response = The package
• Response Headers = The shipping label
• Response Body = The actual items inside

The body is what you actually wanted - the headers just tell you about it.

TYPES OF RESPONSE BODIES
-------------------------
Response bodies can contain various types of content:

1. HTML (Web Pages)
   Content-Type: text/html
   <!DOCTYPE html>
   <html>
     <body>
       <h1>Welcome</h1>
     </body>
   </html>

2. JSON (API Data)
   Content-Type: application/json
   {
     "id": 123,
     "name": "John Doe",
     "email": "john@example.com"
   }

3. XML (Structured Data)
   Content-Type: application/xml
   <user>
     <id>123</id>
     <name>John Doe</name>
   </user>

4. Plain Text
   Content-Type: text/plain
   This is plain text content.

5. Images (Binary Data)
   Content-Type: image/png
   (binary image data)

6. Files (Binary Data)
   Content-Type: application/pdf
   (binary PDF data)

EXAMPLE: HTML RESPONSE BODY
----------------------------
Here's a complete response with HTML body:

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 234

<!DOCTYPE html>
<html>
<head>
  <title>Example Page</title>
</head>
<body>
  <h1>Welcome to Example</h1>
  <p>This is an example HTML page.</p>
</body>
</html>

The body contains the HTML that the browser will display.

EXAMPLE: JSON RESPONSE BODY
---------------------------
Here's a response with JSON body:

HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 89

{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com",
  "created": "2024-01-15"
}

The body contains JSON data that an API client would parse and use.

EXAMPLE: IMAGE RESPONSE BODY
----------------------------
Here's a response with image body:

HTTP/1.1 200 OK
Content-Type: image/png
Content-Length: 45678

(binary image data - not human-readable)

The body contains binary image data that the browser displays.

WHAT HAPPENS WHEN BODY IS EMPTY?
---------------------------------
Some responses have no body:

HTTP/1.1 204 No Content
Content-Type: text/html
Content-Length: 0

(no body)

• Status 204 = No Content
• Body is empty
• Used when action succeeded but no data to return
• Common with DELETE requests

HOW CLIENTS PROCESS RESPONSE BODIES
------------------------------------
1. Client reads Content-Type header
2. Client knows what format to expect
3. Client reads Content-Length (if present)
4. Client reads that many bytes
5. Client parses body according to Content-Type
6. Client displays/uses the content

Example flow for HTML:
• Content-Type: text/html
• Browser knows it's HTML
• Reads HTML body
• Parses HTML
• Renders and displays page

Example flow for JSON:
• Content-Type: application/json
• API client knows it's JSON
• Reads JSON body
• Parses JSON
• Uses data in application

THE BLANK LINE SEPARATOR
------------------------
The blank line between headers and body is CRITICAL:

• Must be present
• Separates headers from body
• Without it, body might be interpreted as headers
• Standard HTTP requirement

CORRECT:
--------
HTTP/1.1 200 OK
Content-Type: text/html

<html>...</html>

INCORRECT:
----------
HTTP/1.1 200 OK
Content-Type: text/html
<html>...</html>
(Missing blank line - will cause errors!)

[END SECTION 4.4]
================================================================================

PART 5: HTTP STATUS CODES
================================================================================

SECTION 5.1: UNDERSTANDING STATUS CODES
---------------------------------------

DEFINITION
----------
Let's look at other status codes. Some status code examples are shown in the 
table below. The prefix indicates the class; for example, the 100s are 
informational responses; 100 indicates that everything is OK so far. The 
200s are Successful responses: For example, 200 The request has succeeded. 
Anything in the 400s is bad news. 401 means the request is unauthorized. 
500's stands for server errors, like 501 for not Implemented.

DETAILED EXPLANATION
--------------------
HTTP status codes are three-digit numbers that indicate the result of an HTTP 
request. They tell the client whether the request was successful, what went 
wrong, or what action to take next. Understanding status codes is essential 
for working with web technologies and APIs.

WHAT ARE STATUS CODES?
-----------------------
Status codes are:
• Three-digit numbers in HTTP responses
• Indicate the result of a request
• First digit indicates the category
• Provide quick way to understand response

REAL-WORLD ANALOGY
------------------
Think of status codes like delivery confirmation:

• 200 = Package delivered successfully
• 404 = Address not found
• 401 = Need ID to receive package
• 500 = Delivery truck broke down

The code quickly tells you what happened.

THE FIVE CATEGORIES OF STATUS CODES
------------------------------------
Status codes are organized into five categories:

1. 100s - INFORMATIONAL
   • Request received, processing continues
   • Provisional response
   • Example: 100 Continue

2. 200s - SUCCESS
   • Request succeeded
   • Different codes for different success types
   • Example: 200 OK, 201 Created

3. 300s - REDIRECTION
   • Further action needed
   • Resource moved
   • Example: 301 Moved Permanently, 302 Found

4. 400s - CLIENT ERROR
   • Request had problems
   • Client made a mistake
   • Example: 400 Bad Request, 404 Not Found

5. 500s - SERVER ERROR
   • Server had problems
   • Server-side error
   • Example: 500 Internal Server Error, 501 Not Implemented

HOW TO READ STATUS CODES
------------------------
The first digit tells you the category:

• 1xx = Informational (rarely seen)
• 2xx = Success (good news!)
• 3xx = Redirection (follow the redirect)
• 4xx = Client Error (check your request)
• 5xx = Server Error (server problem)

The last two digits provide specific information within the category.

WHY ARE STATUS CODES IMPORTANT?
-------------------------------
Status codes are crucial because:

1. QUICK UNDERSTANDING
   • Immediately know if request succeeded
   • No need to parse body first
   • Programs can react quickly

2. ERROR HANDLING
   • Different codes = different handling
   • Client can react appropriately
   • Better user experience

3. DEBUGGING
   • Helps identify problems
   • 404 = resource not found
   • 500 = server error

4. STANDARDIZATION
   • Same codes mean same thing everywhere
   • Consistent across all servers
   • Well-documented standard

[END SECTION 5.1]
================================================================================

SECTION 5.2: 100s - INFORMATIONAL RESPONSES
---------------------------------------------

DEFINITION
----------
The 100s are informational responses; 100 indicates that everything is OK 
so far.

DETAILED EXPLANATION
--------------------
100-level status codes are informational responses. They indicate that the 
server has received the request and is continuing to process it. These codes 
are provisional - they tell the client that everything is proceeding, but 
the final response hasn't been sent yet.

WHAT ARE INFORMATIONAL RESPONSES?
----------------------------------
Informational responses:
• Indicate provisional status
• Tell client processing continues
• Usually followed by final response
• Rarely seen in practice

COMMON 100-LEVEL CODES
----------------------
1. 100 CONTINUE
   • Server received request headers
   • Client should continue sending body
   • Used with large requests
   • Allows client to check before sending full body

2. 101 SWITCHING PROTOCOLS
   • Server agrees to switch protocols
   • Used for WebSocket upgrades
   • Changes from HTTP to another protocol

WHEN ARE 100s USED?
-------------------
100-level codes are used when:
• Server needs to confirm before processing
• Large file uploads (check permissions first)
• Protocol upgrades (HTTP to WebSocket)
• Special server configurations

EXAMPLE: 100 CONTINUE
---------------------
Client sends request headers first:

POST /upload HTTP/1.1
Host: www.example.com
Content-Length: 1000000
Expect: 100-continue

Server responds:

HTTP/1.1 100 Continue

Client then sends the body.

This allows server to check permissions before receiving large file.

[END SECTION 5.2]
================================================================================

SECTION 5.3: 200s - SUCCESSFUL RESPONSES
-----------------------------------------

DEFINITION
----------
The 200s are Successful responses: For example, 200 The request has 
succeeded.

DETAILED EXPLANATION
--------------------
200-level status codes indicate that the request was successfully received, 
understood, and processed. These are the "good news" codes - everything worked 
as expected. Different 200-level codes indicate different types of success.

WHAT ARE SUCCESS RESPONSES?
----------------------------
Success responses mean:
• Request was successful
• Server processed it correctly
• Client got what it wanted
• Everything worked as expected

COMMON 200-LEVEL CODES
----------------------
1. 200 OK
   • Standard success response
   • Request succeeded
   • Most common success code
   • Used for GET, POST, PUT requests

2. 201 CREATED
   • Resource was created
   • Used with POST requests
   • New resource was successfully created
   • Response usually includes location of new resource

3. 202 ACCEPTED
   • Request accepted for processing
   • Processing not complete yet
   • Used for asynchronous operations
   • Will be processed later

4. 204 NO CONTENT
   • Request succeeded
   • No content to return
   • Used with DELETE requests
   • Body is empty

5. 206 PARTIAL CONTENT
   • Partial content returned
   • Used for range requests
   • Client requested specific byte range
   • Server returned that range

EXAMPLES OF 200-LEVEL RESPONSES
--------------------------------
EXAMPLE 1: 200 OK (GET Request)
-------------------------------
Request:
GET /api/users/123 HTTP/1.1
Host: api.example.com

Response:
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 123,
  "name": "John Doe"
}

• Request succeeded
• User data returned
• Standard success

EXAMPLE 2: 201 CREATED (POST Request)
--------------------------------------
Request:
POST /api/users HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "name": "Jane Doe",
  "email": "jane@example.com"
}

Response:
HTTP/1.1 201 Created
Content-Type: application/json
Location: /api/users/456

{
  "id": 456,
  "name": "Jane Doe",
  "email": "jane@example.com"
}

• New user created
• ID 456 assigned
• Location header shows where to find it

EXAMPLE 3: 204 NO CONTENT (DELETE Request)
------------------------------------------
Request:
DELETE /api/users/123 HTTP/1.1
Host: api.example.com

Response:
HTTP/1.1 204 No Content

• User deleted successfully
• No body (nothing to return)
• Action completed

WHEN TO USE EACH 200-LEVEL CODE
--------------------------------
• 200 OK - General success, most common
• 201 Created - Resource created (POST)
• 202 Accepted - Accepted for async processing
• 204 No Content - Success but no data (DELETE)
• 206 Partial Content - Partial data returned

[END SECTION 5.3]
================================================================================

SECTION 5.4: 400s - CLIENT ERRORS
----------------------------------

DEFINITION
----------
Anything in the 400s is bad news. 401 means the request is unauthorized.

DETAILED EXPLANATION
--------------------
400-level status codes indicate that there was a problem with the request 
itself. The client made an error - the request was malformed, unauthorized, 
or requested something that doesn't exist. The server understood the request 
but couldn't process it due to a client-side issue.

WHAT ARE CLIENT ERRORS?
-----------------------
Client errors mean:
• Problem with the request
• Client made a mistake
• Server understood but couldn't process
• Client needs to fix the request

COMMON 400-LEVEL CODES
----------------------
1. 400 BAD REQUEST
   • Request was malformed
   • Syntax error in request
   • Server couldn't understand
   • Client needs to fix request

2. 401 UNAUTHORIZED
   • Authentication required
   • Client not authenticated
   • Need to provide credentials
   • "Who are you?"

3. 403 FORBIDDEN
   • Authenticated but not authorized
   • Don't have permission
   • Server understood but refuses
   • "You can't do that"

4. 404 NOT FOUND
   • Resource doesn't exist
   • URL not found
   • Most common error
   • "Can't find what you're looking for"

5. 405 METHOD NOT ALLOWED
   • HTTP method not allowed
   • Can't use GET on this resource
   • Wrong method used
   • "Can't do that action"

6. 409 CONFLICT
   • Conflict with current state
   • Resource already exists
   • Can't create duplicate
   • "Already exists"

7. 422 UNPROCESSABLE ENTITY
   • Syntax correct but semantic error
   • Validation failed
   • Data format wrong
   • "Looks right but isn't valid"

EXAMPLES OF 400-LEVEL RESPONSES
--------------------------------
EXAMPLE 1: 400 BAD REQUEST
---------------------------
Request:
POST /api/users HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "name": "John"
  "email": "john@example.com"  // Missing comma
}

Response:
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "Invalid JSON syntax"
}

• JSON syntax error
• Server can't parse
• Client needs to fix

EXAMPLE 2: 401 UNAUTHORIZED
----------------------------
Request:
GET /api/users/123 HTTP/1.1
Host: api.example.com
(No Authorization header)

Response:
HTTP/1.1 401 Unauthorized
Content-Type: application/json
WWW-Authenticate: Bearer

{
  "error": "Authentication required"
}

• No authentication provided
• Need to login first
• Server requires credentials

EXAMPLE 3: 404 NOT FOUND
------------------------
Request:
GET /api/users/999 HTTP/1.1
Host: api.example.com

Response:
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": "User not found"
}

• User ID 999 doesn't exist
• Resource not found
• Most common error

EXAMPLE 4: 403 FORBIDDEN
-------------------------
Request:
DELETE /api/users/123 HTTP/1.1
Host: api.example.com
Authorization: Bearer user_token

Response:
HTTP/1.1 403 Forbidden
Content-Type: application/json

{
  "error": "You don't have permission to delete users"
}

• Authenticated (logged in)
• But not authorized (no permission)
• Can't perform this action

WHEN TO USE EACH 400-LEVEL CODE
--------------------------------
• 400 Bad Request - Malformed request
• 401 Unauthorized - Need authentication
• 403 Forbidden - No permission
• 404 Not Found - Resource doesn't exist
• 405 Method Not AllOWED - Wrong HTTP method
• 409 Conflict - Resource conflict
• 422 Unprocessable Entity - Validation failed

[END SECTION 5.4]
================================================================================

SECTION 5.5: 500s - SERVER ERRORS
----------------------------------

DEFINITION
----------
500's stands for server errors, like 501 for not Implemented.

DETAILED EXPLANATION
--------------------
500-level status codes indicate that the server encountered an error while 
processing the request. The request was valid, but the server failed to 
fulfill it due to a server-side problem. These are server errors, not client 
errors.

WHAT ARE SERVER ERRORS?
-----------------------
Server errors mean:
• Problem on the server side
• Request was valid
• Server failed to process
• Not the client's fault

COMMON 500-LEVEL CODES
---------------------
1. 500 INTERNAL SERVER ERROR
   • Generic server error
   • Something went wrong
   • Server couldn't complete request
   • Most common server error

2. 501 NOT IMPLEMENTED
   • Method not implemented
   • Server doesn't support this
   • Can't perform this action
   • "Not available"

3. 502 BAD GATEWAY
   • Invalid response from upstream
   • Gateway/proxy error
   • Upstream server problem
   • "Can't reach other server"

4. 503 SERVICE UNAVAILABLE
   • Service temporarily unavailable
   • Server overloaded
   • Maintenance mode
   • "Try again later"

5. 504 GATEWAY TIMEOUT
   • Upstream server timeout
   • Took too long to respond
   • Gateway waited too long
   • "Other server too slow"

EXAMPLES OF 500-LEVEL RESPONSES
--------------------------------
EXAMPLE 1: 500 INTERNAL SERVER ERROR
--------------------------------------
Request:
GET /api/users/123 HTTP/1.1
Host: api.example.com

Response:
HTTP/1.1 500 Internal Server Error
Content-Type: application/json

{
  "error": "Internal server error",
  "message": "Database connection failed"
}

• Server error occurred
• Database problem
• Not client's fault
• Server needs to fix

EXAMPLE 2: 501 NOT IMPLEMENTED
-------------------------------
Request:
PATCH /api/users/123 HTTP/1.1
Host: api.example.com

Response:
HTTP/1.1 501 Not Implemented
Content-Type: application/json

{
  "error": "PATCH method not implemented"
}

• Server doesn't support PATCH
• Method not available
• Can't perform this action

EXAMPLE 3: 503 SERVICE UNAVAILABLE
-----------------------------------
Request:
GET /api/users HTTP/1.1
Host: api.example.com

Response:
HTTP/1.1 503 Service Unavailable
Content-Type: application/json
Retry-After: 3600

{
  "error": "Service temporarily unavailable",
  "message": "Server maintenance in progress"
}

• Service down temporarily
• Maintenance mode
• Retry-After tells when to try again
• "Come back later"

WHEN TO USE EACH 500-LEVEL CODE
--------------------------------
• 500 Internal Server Error - Generic server error
• 501 Not Implemented - Method not supported
• 502 Bad Gateway - Upstream server error
• 503 Service Unavailable - Temporarily down
• 504 Gateway Timeout - Upstream timeout

WHAT TO DO WITH SERVER ERRORS?
------------------------------
For clients:
• Usually can't fix (server problem)
• May retry later (503)
• Report to server administrator
• Check server status

For servers:
• Log the error
• Fix the problem
• Return appropriate error code
• Provide helpful error messages

[END SECTION 5.5]
================================================================================

PART 6: HTTP METHODS
================================================================================

SECTION 6.1: UNDERSTANDING HTTP METHODS
-----------------------------------------

DEFINITION
----------
When an HTTP request is made, an HTTP method is sent. This tells the server 
what action to perform. A list of several HTTP methods is shown here. In the 
next video, we will use Python to apply the GET method that retrieves data 
from the server and the post method that sends data to the server.

DETAILED EXPLANATION
--------------------
HTTP methods (also called HTTP verbs) tell the server what action to perform 
on a resource. They're part of the request start line and indicate the 
intention of the request - whether you want to retrieve, create, update, or 
delete a resource.

WHAT ARE HTTP METHODS?
----------------------
HTTP methods are:
• Verbs that indicate the action to perform
• Part of the request start line
• Tell server what to do
• Examples: GET, POST, PUT, DELETE

REAL-WORLD ANALOGY
------------------
Think of HTTP methods like commands:

• GET = "Show me..."
• POST = "Create a new..."
• PUT = "Replace/update..."
• DELETE = "Remove..."

Just like you use different verbs to express different actions in language, 
HTTP uses different methods to express different actions on resources.

THE PURPOSE OF HTTP METHODS
----------------------------
HTTP methods serve to:

1. INDICATE INTENTION
   • GET = I want to read/retrieve
   • POST = I want to create
   • PUT = I want to update/replace
   • DELETE = I want to remove

2. DETERMINE PROCESSING
   • Server routes based on method
   • Different methods = different code
   • Security checks depend on method

3. FOLLOW REST PRINCIPLES
   • REST APIs use methods semantically
   • GET for reading, POST for creating
   • Standard conventions

COMMON HTTP METHODS
-------------------
1. GET - Retrieve/read data
2. POST - Create new data
3. PUT - Update/replace data
4. DELETE - Remove data
5. PATCH - Partially update data
6. HEAD - Get headers only
7. OPTIONS - Get allowed methods

WHERE METHODS APPEAR
--------------------
Methods appear in the request start line:

GET /api/users HTTP/1.1
POST /api/users HTTP/1.1
PUT /api/users/123 HTTP/1.1
DELETE /api/users/123 HTTP/1.1

The method is always the first word in the request line.

[END SECTION 6.1]
================================================================================

SECTION 6.2: GET METHOD
------------------------

DEFINITION
----------
The GET method retrieves data from the server.

DETAILED EXPLANATION
--------------------
GET is the most common HTTP method. It's used to retrieve or read data from 
the server. GET requests should only retrieve data and not modify anything on 
the server. They're safe and idempotent - you can make the same GET request 
multiple times and get the same result.

WHAT IS THE GET METHOD?
-----------------------
GET is:
• Used to retrieve data
• Should not modify server state
• Safe (no side effects)
• Idempotent (same request = same result)

CHARACTERISTICS OF GET
----------------------
1. RETRIEVE ONLY
   • Only reads data
   • Doesn't change anything
   • Safe to use repeatedly

2. NO BODY
   • Usually no request body
   • Data in URL/query parameters
   • Body is empty or absent

3. CACHEABLE
   • Responses can be cached
   • Browser caches GET responses
   • Improves performance

4. IDEMPOTENT
   • Same request = same result
   • Can repeat safely
   • No side effects

EXAMPLES OF GET REQUESTS
------------------------
EXAMPLE 1: Get a Web Page
--------------------------
GET /index.html HTTP/1.1
Host: www.example.com

• Retrieves the home page
• Server returns HTML
• Browser displays it

EXAMPLE 2: Get API Data
------------------------
GET /api/users/123 HTTP/1.1
Host: api.example.com
Accept: application/json

• Retrieves user with ID 123
• Server returns JSON
• Client uses the data

EXAMPLE 3: Get with Query Parameters
-------------------------------------
GET /api/users?page=1&limit=10 HTTP/1.1
Host: api.example.com

• Retrieves users
• Query parameters: page=1, limit=10
• Server filters/paginates results

WHEN TO USE GET
---------------
Use GET when:
• Retrieving data
• Reading resources
• Fetching information
• Browsing web pages
• Getting API data

Don't use GET when:
• Creating data (use POST)
• Updating data (use PUT/PATCH)
• Deleting data (use DELETE)
• Sending sensitive data (use POST)

[END SECTION 6.2]
================================================================================

SECTION 6.3: POST METHOD
-------------------------

DEFINITION
----------
The POST method sends data to the server.

DETAILED EXPLANATION
--------------------
POST is used to create new resources or submit data to the server. Unlike GET, 
POST requests typically have a body containing the data to be created or 
submitted. POST is not idempotent - making the same POST request multiple 
times may create multiple resources.

WHAT IS THE POST METHOD?
------------------------
POST is:
• Used to create new resources
• Used to submit data
• Usually has a request body
• Not idempotent (creates new each time)

CHARACTERISTICS OF POST
-----------------------
1. CREATES DATA
   • Creates new resources
   • Submits information
   • Sends data to server

2. HAS BODY
   • Usually has request body
   • Contains data to create
   • JSON, form data, etc.

3. NOT CACHEABLE
   • Responses usually not cached
   • Each request may be different
   • Browser doesn't cache

4. NOT IDEMPOTENT
   • Same request = different result
   • May create duplicates
   • Has side effects

EXAMPLES OF POST REQUESTS
--------------------------
EXAMPLE 1: Create a User
-------------------------
POST /api/users HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com"
}

• Creates a new user
• Sends user data in body
• Server creates and returns new user

EXAMPLE 2: Submit a Form
-------------------------
POST /contact HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded

name=John+Doe&email=john%40example.com&message=Hello

• Submits contact form
• Form data in body
• Server processes submission

EXAMPLE 3: Upload a File
-------------------------
POST /upload HTTP/1.1
Host: www.example.com
Content-Type: multipart/form-data

(binary file data)

• Uploads a file
• File data in body
• Server saves the file

WHEN TO USE POST
----------------
Use POST when:
• Creating new resources
• Submitting forms
• Uploading files
• Sending data to server
• Performing actions

Don't use POST when:
• Just retrieving data (use GET)
• Updating existing data (use PUT/PATCH)
• Deleting data (use DELETE)

[END SECTION 6.3]
================================================================================

SECTION 6.4: OTHER HTTP METHODS
--------------------------------

DEFINITION
----------
There are other HTTP methods we can use besides GET and POST.

DETAILED EXPLANATION
--------------------
While GET and POST are the most common, there are other HTTP methods that 
serve specific purposes. Each method has a specific semantic meaning and 
should be used appropriately.

OTHER COMMON HTTP METHODS
-------------------------
1. PUT
   • Updates/replaces entire resource
   • Idempotent (same request = same result)
   • Usually has a body
   • Example: PUT /api/users/123

2. DELETE
   • Removes a resource
   • Idempotent
   • Usually no body
   • Example: DELETE /api/users/123

3. PATCH
   • Partially updates resource
   • Not idempotent
   • Has a body with changes
   • Example: PATCH /api/users/123

4. HEAD
   • Gets headers only
   • No body in response
   • Like GET but headers only
   • Example: HEAD /api/users/123

5. OPTIONS
   • Gets allowed methods
   • CORS preflight requests
   • Tells what methods are allowed
   • Example: OPTIONS /api/users

QUICK REFERENCE
---------------
• GET - Read/retrieve (safe, idempotent)
• POST - Create (not safe, not idempotent)
• PUT - Update/replace (not safe, idempotent)
• DELETE - Remove (not safe, idempotent)
• PATCH - Partial update (not safe, not idempotent)
• HEAD - Headers only (safe, idempotent)
• OPTIONS - Allowed methods (safe, idempotent)

[END SECTION 6.4]
================================================================================

END OF PART 2
=============

This concludes Part 2 of the REST APIs and HTTP Requests comprehensive study 
guide. You have learned:

✓ The complete structure of HTTP requests
✓ Request start line (method, path, version)
✓ Request headers and their purposes
✓ Request bodies and when they're used
✓ The complete structure of HTTP responses
✓ Response status line (version, code, text)
✓ Response headers and their purposes
✓ Response bodies and their content
✓ HTTP status codes (100s, 200s, 300s, 400s, 500s)
✓ What each status code category means
✓ HTTP methods (GET, POST, PUT, DELETE, etc.)
✓ When to use each HTTP method

You now have a comprehensive understanding of:
• How HTTP requests work
• How HTTP responses work
• What status codes mean
• What HTTP methods do
• How clients and servers communicate

This knowledge is fundamental for:
• Working with REST APIs
• Web development
• API integration
• Understanding web communication

Continue practicing with real examples and building applications that use 
these concepts!

================================================================================
