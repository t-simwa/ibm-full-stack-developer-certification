================================================================================
LOOPS IN PYTHON
Comprehensive Study Guide - Part 3
================================================================================

WELCOME TO PART 3
-----------------
This part covers while loops in detail, including conditional iteration, 
infinite loops, comparing for loops vs while loops, and real-world 
applications.

ESTIMATED TIME NEEDED
---------------------
15 minutes (for basic reading)
90-120 minutes (for comprehensive study with practice)

================================================================================
TABLE OF CONTENTS - PART 3
================================================================================

PART 4: WHILE LOOPS
  SECTION 4.1: INTRODUCTION TO WHILE LOOPS
  SECTION 4.2: HOW WHILE LOOPS WORK
  SECTION 4.3: WHILE LOOPS WITH CONDITIONS
  SECTION 4.4: THE ORANGE SQUARES EXAMPLE
  SECTION 4.5: INFINITE LOOPS AND HOW TO AVOID THEM
  SECTION 4.6: COMMON WHILE LOOP PATTERNS
  SECTION 4.7: COMPARING FOR LOOPS VS WHILE LOOPS
  SECTION 4.8: REAL-WORLD APPLICATIONS

PART 5: SUMMARY AND BEST PRACTICES
  SECTION 5.1: QUICK REFERENCE GUIDE
  SECTION 5.2: COMMON MISTAKES TO AVOID
  SECTION 5.3: BEST PRACTICES
  SECTION 5.4: PRACTICE EXERCISES

================================================================================
PART 4: WHILE LOOPS
================================================================================

SECTION 4.1: INTRODUCTION TO WHILE LOOPS
-----------------------------------------

DEFINITION
----------
While loops are similar to for loops, but instead of executing a statement a 
set number of times, a while loop will only run if a condition is met.

DETAILED EXPLANATION
--------------------
A while loop repeats a block of code as long as a condition is true. Unlike 
for loops that iterate through a sequence or run a specific number of times, 
while loops continue until the condition becomes false.

KEY CHARACTERISTICS
-------------------
• Condition-controlled: Runs based on a condition, not a count
• Flexible: Can run an unknown number of times
• Requires management: You must ensure the condition eventually becomes false
• Powerful: Can handle situations where you don't know iterations in advance

BASIC SYNTAX
------------
  while condition:
      # Code to execute while condition is True
      # This code is indented
      # IMPORTANT: Must modify something that affects the condition

COMPONENTS EXPLAINED
--------------------
• while - Python keyword that starts the while loop
• condition - A boolean expression that determines if the loop continues
• : - Colon indicates the start of the loop body
• Indented code - The code that executes while condition is True
• Condition modification - Code that eventually makes condition False

REAL-WORLD ANALOGY
------------------
Think of a while loop like a security guard checking IDs:
• While there are people in line (condition is True)
• Check each person's ID (execute loop body)
• When the line is empty (condition becomes False)
• Stop checking (exit loop)

The key difference from a for loop:
• For loop: "Do this 10 times" (you know exactly how many)
• While loop: "Do this while people are waiting" (unknown how many)

[END SECTION 4.1]
================================================================================

SECTION 4.2: HOW WHILE LOOPS WORK
----------------------------------

DEFINITION
----------
A while loop repeatedly executes the statements within the indent until the 
condition inside the bracket is false.

DETAILED EXPLANATION
--------------------
The while statement will repeatedly execute the statements within the indent 
until the condition inside the bracket is false.

HOW IT WORKS STEP-BY-STEP
-------------------------
1. Python evaluates the condition
2. If condition is True:
   • Execute all code in the loop body (indented code)
   • Go back to step 1 (check condition again)
3. If condition is False:
   • Skip the loop body
   • Continue with code after the loop

IMPORTANT: The condition is checked BEFORE each iteration, not during.

VISUAL FLOWCHART
----------------
  START
    |
    v
  Check Condition
    |
    +---> True ---> Execute Loop Body
    |                |
    |                v
    |            Modify Variables
    |                |
    |                +--- (Loop back)
    |                |
    v                v
  False          (Check condition again)
    |
    v
  Continue After Loop

EXAMPLE 1: BASIC COUNTING
--------------------------
CODE:
  i = 0
  
  while i < 5:
      print(i)
      i = i + 1
  
  print("Loop finished")

OUTPUT:
  0
  1
  2
  3
  4
  Loop finished

LINE-BY-LINE EXPLANATION:
  Line 1: i = 0
           • Initialize loop variable
           • Starts at 0
  
  Line 3: while i < 5:
           • Condition: Is i less than 5?
           • Loop continues while this is True
           • : starts the loop body
  
  Line 4:     print(i)
           • Prints current value of i
           • Indented, so it's inside the loop
  
  Line 5:     i = i + 1
           • CRITICAL: Increments i by 1
           • Without this, i would stay 0 forever (infinite loop!)
           • Eventually makes i >= 5, so condition becomes False
  
  Line 7: print("Loop finished")
           • Not indented, so it's after the loop
           • Executes when loop condition becomes False

STEP-BY-STEP EXECUTION
----------------------
ITERATION 1:
  • Check: i < 5? 0 < 5? True
  • Execute: print(0) → Output: 0
  • Execute: i = 0 + 1 = 1
  • i is now 1

ITERATION 2:
  • Check: i < 5? 1 < 5? True
  • Execute: print(1) → Output: 1
  • Execute: i = 1 + 1 = 2
  • i is now 2

ITERATION 3:
  • Check: i < 5? 2 < 5? True
  • Execute: print(2) → Output: 2
  • Execute: i = 2 + 1 = 3
  • i is now 3

ITERATION 4:
  • Check: i < 5? 3 < 5? True
  • Execute: print(3) → Output: 3
  • Execute: i = 3 + 1 = 4
  • i is now 4

ITERATION 5:
  • Check: i < 5? 4 < 5? True
  • Execute: print(4) → Output: 4
  • Execute: i = 4 + 1 = 5
  • i is now 5

ITERATION 6 (CHECK ONLY):
  • Check: i < 5? 5 < 5? False
  • Condition is False, so skip loop body
  • Continue after loop

AFTER LOOP:
  • Execute: print("Loop finished") → Output: Loop finished

EXAMPLE 2: USER INPUT VALIDATION
---------------------------------
CODE:
  password = ""
  
  while password != "secret":
      password = input("Enter password: ")
  
  print("Access granted!")

POSSIBLE EXECUTION:
  Enter password: wrong
  Enter password: incorrect
  Enter password: secret
  Access granted!

LINE-BY-LINE EXPLANATION:
  Line 1: password = ""
           • Initialize password variable
           • Empty string ensures condition is True initially
  
  Line 3: while password != "secret":
           • Condition: Is password NOT equal to "secret"?
           • Loop continues while password is wrong
           • != means "not equal to"
  
  Line 4:     password = input("Enter password: ")
           • Asks user for password
           • Updates password variable
           • If user enters "secret", condition becomes False
  
  Line 6: print("Access granted!")
           • Executes after loop exits
           • Only runs when password == "secret"

EXAMPLE 3: PROCESSING UNTIL EMPTY
----------------------------------
CODE:
  numbers = [1, 2, 3, 4, 5]
  
  while len(numbers) > 0:
      print(numbers.pop(0))
  
  print("List is empty")

OUTPUT:
  1
  2
  3
  4
  5
  List is empty

LINE-BY-LINE EXPLANATION:
  Line 1: numbers = [1, 2, 3, 4, 5]
           • List with 5 elements
  
  Line 3: while len(numbers) > 0:
           • Condition: Is list length greater than 0?
           • Continues while list has elements
           • len(numbers) returns number of elements
  
  Line 4:     print(numbers.pop(0))
           • .pop(0) removes and returns first element
           • Each iteration removes one element
           • Eventually list becomes empty, condition becomes False
  
  Line 6: print("List is empty")
           • Executes when list is empty

STEP-BY-STEP EXECUTION:
  Iteration 1: len([1,2,3,4,5]) = 5 > 0? True → pop(0) = 1, list = [2,3,4,5]
  Iteration 2: len([2,3,4,5]) = 4 > 0? True → pop(0) = 2, list = [3,4,5]
  Iteration 3: len([3,4,5]) = 3 > 0? True → pop(0) = 3, list = [4,5]
  Iteration 4: len([4,5]) = 2 > 0? True → pop(0) = 4, list = [5]
  Iteration 5: len([5]) = 1 > 0? True → pop(0) = 5, list = []
  Check: len([]) = 0 > 0? False → Exit loop

[END SECTION 4.2]
================================================================================

SECTION 4.3: WHILE LOOPS WITH CONDITIONS
-----------------------------------------

DEFINITION
----------
While loops use boolean conditions to determine when to continue or stop. 
The condition can be any expression that evaluates to True or False.

TYPES OF CONDITIONS
-------------------

CONDITION TYPE 1: COMPARISON OPERATORS
---------------------------------------
  while x < 10:        # Less than
  while x > 0:          # Greater than
  while x <= 5:         # Less than or equal
  while x >= 1:         # Greater than or equal
  while x == 5:         # Equal to
  while x != 0:         # Not equal to

CONDITION TYPE 2: MEMBERSHIP OPERATORS
--------------------------------------
  while item in list:   # Item is in list
  while item not in list: # Item is not in list

CONDITION TYPE 3: BOOLEAN VARIABLES
-----------------------------------
  while running:        # Variable is True
  while not done:       # Variable is False

CONDITION TYPE 4: COMPLEX CONDITIONS
-------------------------------------
  while x < 10 and y > 0:     # Both must be True
  while x < 10 or y > 0:      # Either can be True
  while not (x == 0):         # Negation

EXAMPLE 1: COUNTING WITH CONDITION
-----------------------------------
CODE:
  count = 0
  
  while count < 10:
      print(f"Count: {count}")
      count += 1  # Same as count = count + 1
  
  print("Done counting")

OUTPUT:
  Count: 0
  Count: 1
  Count: 2
  Count: 3
  Count: 4
  Count: 5
  Count: 6
  Count: 7
  Count: 8
  Count: 9
  Done counting

LINE-BY-LINE EXPLANATION:
  Line 1: count = 0
           • Initialize counter
  
  Line 3: while count < 10:
           • Condition: count < 10
           • Continues while count is less than 10
           • Stops when count reaches 10
  
  Line 4:     print(f"Count: {count}")
           • Prints current count
  
  Line 5:     count += 1
           • Increments count by 1
           • += is shorthand for count = count + 1
           • Critical: Without this, infinite loop!
  
  Line 7: print("Done counting")
           • After loop completes

EXAMPLE 2: PROCESSING UNTIL CONDITION MET
------------------------------------------
CODE:
  numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  index = 0
  
  while numbers[index] < 7:
      print(numbers[index])
      index += 1
  
  print("Stopped at", numbers[index])

OUTPUT:
  1
  2
  3
  4
  5
  6
  Stopped at 7

LINE-BY-LINE EXPLANATION:
  Line 1: numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  
  Line 2: index = 0
           • Start at first element
  
  Line 4: while numbers[index] < 7:
           • Condition: Is current element less than 7?
           • Continues while element is less than 7
           • Stops when element is 7 or greater
  
  Line 5:     print(numbers[index])
           • Prints current element
  
  Line 6:     index += 1
           • Move to next element
           • Critical: Without this, same element checked forever!
  
  Line 8: print("Stopped at", numbers[index])
           • Shows where we stopped

EXAMPLE 3: BOOLEAN FLAG CONDITION
----------------------------------
CODE:
  running = True
  count = 0
  
  while running:
      count += 1
      print(f"Running... {count}")
      
      if count >= 5:
          running = False  # Change flag to stop loop
  
  print("Stopped")

OUTPUT:
  Running... 1
  Running... 2
  Running... 3
  Running... 4
  Running... 5
  Stopped

LINE-BY-LINE EXPLANATION:
  Line 1: running = True
           • Boolean flag to control loop
           • Starts as True
  
  Line 2: count = 0
           • Counter variable
  
  Line 4: while running:
           • Condition: Is running True?
           • Continues while running is True
           • Stops when running becomes False
  
  Line 5:     count += 1
           • Increment counter
  
  Line 6:     print(f"Running... {count}")
           • Show progress
  
  Line 8:     if count >= 5:
           • Check if we've reached limit
  
  Line 9:         running = False
           • Change flag to False
           • This makes condition False, loop stops
           • Alternative to break statement
  
  Line 11: print("Stopped")
           • After loop

[END SECTION 4.3]
================================================================================

SECTION 4.4: THE ORANGE SQUARES EXAMPLE
----------------------------------------

DEFINITION
----------
This example from the original material demonstrates how while loops can 
process data until a condition is no longer met, even when you don't know 
how many items will be processed beforehand.

ORIGINAL MATERIAL EXPLANATION
------------------------------
Let's say we would like to copy all the orange squares from the list squares 
to the list new squares, but we would like to stop if we encounter a 
non-orange square. We don't know the value of the squares beforehand. We would 
simply continue the process while the square is orange or see if the square 
equals orange. If not, we would stop.

DETAILED EXPLANATION
--------------------
For the first example, we would check if the square was orange. It satisfies 
the condition, so we would copy the square. We repeat the process for the 
second square. The condition is met, so we copy the square. In the next 
iteration, we encounter a purple square. The condition is not met, so we 
stop the process. This is essentially what a while loop does.

THE PROBLEM
-----------
• We have a list of colored squares
• We want to copy orange squares to a new list
• We want to stop when we encounter a non-orange square
• We don't know how many orange squares there are beforehand
• This is perfect for a while loop!

THE SOLUTION
------------
CODE:
  squares = ["orange", "orange", "purple", "blue", "orange"]
  new_squares = []  # Empty list to store orange squares
  i = 0  # Start at index 0
  
  while i < len(squares) and squares[i] == "orange":
      new_squares.append(squares[i])
      i += 1
  
  print("Original squares:", squares)
  print("New squares (orange only):", new_squares)

OUTPUT:
  Original squares: ['orange', 'orange', 'purple', 'blue', 'orange']
  New squares (orange only): ['orange', 'orange']

LINE-BY-LINE EXPLANATION:
  Line 1: squares = ["orange", "orange", "purple", "blue", "orange"]
           • List with colored squares
           • First two are orange, then purple, then blue, then orange
  
  Line 2: new_squares = []
           • Empty list to store orange squares
           • In reality, the list is of indeterminate size
  
  Line 3: i = 0
           • Start the index at 0
           • We start checking from the first element
  
  Line 5: while i < len(squares) and squares[i] == "orange":
           • Condition has TWO parts:
             - i < len(squares): Make sure we don't go out of bounds
             - squares[i] == "orange": Current square is orange
           • Loop continues ONLY if BOTH are True
           • Stops if we run out of squares OR encounter non-orange
  
  Line 6:     new_squares.append(squares[i])
           • Adds current square to new list
           • .append() adds element to end of list
           • Only orange squares are added
  
  Line 7:     i += 1
           • Increment index to check next square
           • Critical: Without this, infinite loop!
  
  Line 9: print("Original squares:", squares)
           • Shows original list
  
  Line 10: print("New squares (orange only):", new_squares)
           • Shows the orange squares we copied

STEP-BY-STEP EXECUTION FROM ORIGINAL MATERIAL
---------------------------------------------
Let's use the figure on the left to represent the code. We will use a list with 
the names of the color to represent the different squares. We create an empty 
list of new squares. In reality, the list is of indeterminate size. We start 
the index at 0. The while statement will repeatedly execute the statements 
within the indent until the condition inside the bracket is false.

ITERATION 1:
  • i = 0
  • Check: i < len(squares)? 0 < 5? True
  • Check: squares[0] == "orange"? "orange" == "orange"? True
  • Condition: True AND True = True → Continue
  • Execute: new_squares.append("orange")
  • new_squares = ["orange"]
  • Execute: i = 0 + 1 = 1
  • i is now 1

ITERATION 2:
  • i = 1
  • Check: i < len(squares)? 1 < 5? True
  • Check: squares[1] == "orange"? "orange" == "orange"? True
  • Condition: True AND True = True → Continue
  • Execute: new_squares.append("orange")
  • new_squares = ["orange", "orange"]
  • Execute: i = 1 + 1 = 2
  • i is now 2

ITERATION 3:
  • i = 2
  • Check: i < len(squares)? 2 < 5? True
  • Check: squares[2] == "orange"? "purple" == "orange"? False
  • Condition: True AND False = False → STOP
  • Loop exits immediately
  • new_squares remains ["orange", "orange"]

AFTER LOOP:
  • new_squares contains ["orange", "orange"]
  • We stopped when we encountered "purple" (non-orange)

VISUAL REPRESENTATION
---------------------
ORIGINAL LIST:
  Index:  0        1        2        3        4
  Value: "orange" "orange" "purple" "blue"   "orange"
          ↑        ↑        ↑
        Copy    Copy    Stop here (not orange)

NEW LIST AFTER LOOP:
  Index:  0        1
  Value: "orange" "orange"

WHY THIS EXAMPLE IS PERFECT FOR WHILE LOOPS
-------------------------------------------
• Unknown iterations: We don't know how many orange squares there are
• Condition-based: We stop when condition is no longer met
• Flexible: Works with any number of orange squares
• Safe: Stops at first non-orange square

ALTERNATIVE APPROACH WITH FOR LOOP
-----------------------------------
You could use a for loop with break, but while loop is more natural:

  squares = ["orange", "orange", "purple", "blue", "orange"]
  new_squares = []
  
  for square in squares:
      if square != "orange":
          break  # Stop at first non-orange
      new_squares.append(square)
  
  print(new_squares)  # Output: ['orange', 'orange']

Both work, but the while loop version makes the condition explicit in the 
loop header, which can be clearer.

[END SECTION 4.4]
================================================================================

SECTION 4.5: INFINITE LOOPS AND HOW TO AVOID THEM
---------------------------------------------------

DEFINITION
----------
An infinite loop is a loop that never stops because its condition never 
becomes False. This is a common mistake with while loops.

WHAT CAUSES INFINITE LOOPS
--------------------------
1. Forgetting to modify the loop variable
2. Condition that's always True
3. Modifying the wrong variable
4. Logic error in condition

EXAMPLE 1: INFINITE LOOP (BAD)
-------------------------------
CODE:
  i = 0
  
  while i < 5:
      print(i)
      # FORGOT TO INCREMENT i!
      # i stays 0 forever, condition always True

RESULT:
  Prints "0" forever (until you stop the program)

WHY IT'S INFINITE:
  • i starts at 0
  • Condition: i < 5? 0 < 5? True
  • We print i (0)
  • We DON'T increment i
  • i is still 0
  • Condition: i < 5? 0 < 5? True (still!)
  • Loop continues forever

FIX:
  i = 0
  
  while i < 5:
      print(i)
      i += 1  # ADD THIS LINE!

EXAMPLE 2: ALWAYS TRUE CONDITION
---------------------------------
CODE:
  while True:  # Condition is always True!
      print("This runs forever")

RESULT:
  Prints "This runs forever" forever

WHY IT'S INFINITE:
  • Condition is literally True
  • True is always True
  • Condition never becomes False
  • Loop never stops

FIX (USE break):
  while True:
      user_input = input("Enter 'quit' to stop: ")
      if user_input == "quit":
          break  # Exit loop
      print("You entered:", user_input)

EXAMPLE 3: WRONG VARIABLE MODIFIED
-----------------------------------
CODE:
  i = 0
  j = 0
  
  while i < 5:
      print(i)
      j += 1  # WRONG! Incrementing j instead of i
      # i never changes, stays 0 forever

RESULT:
  Prints "0" forever

WHY IT'S INFINITE:
  • We're modifying j, but condition checks i
  • i never changes
  • Condition always True

FIX:
  i = 0
  j = 0
  
  while i < 5:
      print(i)
      i += 1  # Correct: increment i

HOW TO AVOID INFINITE LOOPS
---------------------------

RULE 1: ALWAYS MODIFY THE LOOP VARIABLE
---------------------------------------
  i = 0
  while i < 10:
      # Do something
      i += 1  # MUST modify i!

RULE 2: ENSURE CONDITION CAN BECOME FALSE
------------------------------------------
  count = 0
  while count < 10:  # Condition CAN become False
      count += 1     # This makes count eventually >= 10

RULE 3: USE A SAFETY COUNTER (FOR DEBUGGING)
---------------------------------------------
  i = 0
  safety_counter = 0
  max_iterations = 1000
  
  while i < 10 and safety_counter < max_iterations:
      # Do something
      i += 1
      safety_counter += 1  # Prevents infinite loop during development
  
  if safety_counter >= max_iterations:
      print("Warning: Loop may be infinite!")

RULE 4: TEST WITH SMALL VALUES FIRST
------------------------------------
  # Test with small numbers first
  while i < 3:  # Test with 3, not 1000
      # Your code
      i += 1

RULE 5: USE FOR LOOPS WHEN POSSIBLE
------------------------------------
  # If you know the number of iterations, use for loop
  for i in range(10):  # Safer - automatically stops
      print(i)

COMMON PATTERNS THAT PREVENT INFINITE LOOPS
--------------------------------------------

PATTERN 1: COUNTING UP
-----------------------
  i = 0
  while i < 10:
      # Process
      i += 1  # Always increment

PATTERN 2: COUNTING DOWN
-------------------------
  i = 10
  while i > 0:
      # Process
      i -= 1  # Always decrement

PATTERN 3: PROCESSING UNTIL EMPTY
----------------------------------
  while len(items) > 0:
      item = items.pop()  # Removes item, list gets smaller
      # Process item

PATTERN 4: USER INPUT WITH SENTINEL
------------------------------------
  while True:
      user_input = input("Enter data (or 'quit'): ")
      if user_input == "quit":
          break  # Exit loop
      # Process input

PATTERN 5: FLAG VARIABLE
------------------------
  done = False
  while not done:
      # Do something
      if some_condition:
          done = True  # Exit loop

[END SECTION 4.5]
================================================================================

SECTION 4.6: COMMON WHILE LOOP PATTERNS
----------------------------------------

PATTERN 1: COUNTING PATTERN
----------------------------
CODE:
  count = 0
  while count < 5:
      print(f"Count: {count}")
      count += 1

USE WHEN:
• You need to count something
• You know the maximum count

PATTERN 2: PROCESS UNTIL CONDITION
-----------------------------------
CODE:
  i = 0
  while i < len(data) and data[i] < threshold:
      process(data[i])
      i += 1

USE WHEN:
• Processing items until a condition is met
• Don't know how many items will be processed

PATTERN 3: USER INPUT VALIDATION
----------------------------------
CODE:
  user_input = ""
  while user_input != "yes" and user_input != "no":
      user_input = input("Enter yes or no: ")

USE WHEN:
• Need valid input from user
• Keep asking until valid input received

PATTERN 4: MENU SYSTEM
-----------------------
CODE:
  choice = ""
  while choice != "quit":
      print_menu()
      choice = input("Enter choice: ")
      if choice == "1":
          do_option_1()
      elif choice == "2":
          do_option_2()
      # ... etc

USE WHEN:
• Creating interactive menus
• Program runs until user quits

PATTERN 5: READING UNTIL END
----------------------------
CODE:
  line = file.readline()
  while line != "":
      process(line)
      line = file.readline()

USE WHEN:
• Reading files line by line
• Don't know how many lines

PATTERN 6: GAME LOOP
--------------------
CODE:
  game_running = True
  while game_running:
      update_game()
      render_game()
      if game_over():
          game_running = False

USE WHEN:
• Game development
• Continuous loop until game ends

[END SECTION 4.6]
================================================================================

SECTION 4.7: COMPARING FOR LOOPS VS WHILE LOOPS
------------------------------------------------

DEFINITION
----------
Understanding when to use for loops vs while loops is crucial for writing 
effective Python code.

KEY DIFFERENCES
---------------

CHARACTERISTIC          | FOR LOOP              | WHILE LOOP
------------------------|-----------------------|-------------------
Iteration control       | Sequence or count     | Condition
Number of iterations    | Usually known         | Usually unknown
Loop variable           | Automatic             | Manual management
Risk of infinite loop   | Low                   | High
Best for                | Iterating sequences   | Conditional repetition
Syntax complexity       | Simpler               | More complex

WHEN TO USE FOR LOOPS
---------------------
USE FOR LOOPS WHEN:
• You know how many iterations you need
• You're iterating through a sequence (list, tuple, string)
• You want automatic progression
• You want safer code (less risk of infinite loops)

EXAMPLES:
  # Known number of iterations
  for i in range(10):
      print(i)
  
  # Iterating through sequence
  for item in my_list:
      print(item)
  
  # Processing each character
  for char in "hello":
      print(char)

WHEN TO USE WHILE LOOPS
-----------------------
USE WHILE LOOPS WHEN:
• You don't know how many iterations you need
• You need to continue until a condition changes
• You're waiting for a specific event
• You need more flexible control

EXAMPLES:
  # Unknown iterations
  while user_input != "quit":
      user_input = input("Enter command: ")
  
  # Until condition met
  while not found:
      search_next()
      if item == target:
          found = True
  
  # Processing until empty
  while len(queue) > 0:
      process(queue.pop())

SIDE-BY-SIDE COMPARISON
-----------------------

EXAMPLE: COUNTING FROM 0 TO 4

FOR LOOP:
  for i in range(5):
      print(i)

WHILE LOOP:
  i = 0
  while i < 5:
      print(i)
      i += 1

BOTH PRODUCE SAME OUTPUT, BUT:
• For loop is simpler and more Pythonic
• While loop requires manual variable management
• For loop is safer (can't forget to increment)

EXAMPLE: PROCESSING LIST UNTIL CONDITION

FOR LOOP (WITH break):
  for item in items:
      if item == "stop":
          break
      process(item)

WHILE LOOP:
  i = 0
  while i < len(items) and items[i] != "stop":
      process(items[i])
      i += 1

BOTH WORK, BUT:
• For loop is simpler when iterating sequences
• While loop makes condition explicit in header
• Choose based on clarity for your specific case

EXAMPLE: USER INPUT VALIDATION

FOR LOOP (LIMITED ATTEMPTS):
  for attempt in range(3):
      password = input("Enter password: ")
      if password == "secret":
          break
  else:
      print("Access denied")

WHILE LOOP (UNLIMITED ATTEMPTS):
  password = ""
  while password != "secret":
      password = input("Enter password: ")
  print("Access granted!")

DIFFERENCE:
• For loop: Limited to 3 attempts
• While loop: Continues until correct password
• Choose based on requirements

CONVERTING BETWEEN LOOPS
------------------------

CONVERTING FOR TO WHILE:
  # FOR LOOP
  for i in range(5):
      print(i)
  
  # EQUIVALENT WHILE LOOP
  i = 0
  while i < 5:
      print(i)
      i += 1

CONVERTING WHILE TO FOR (WHEN POSSIBLE):
  # WHILE LOOP
  i = 0
  while i < len(items):
      print(items[i])
      i += 1
  
  # EQUIVALENT FOR LOOP (BETTER)
  for item in items:
      print(item)

GENERAL RULE
------------
• Prefer for loops when possible (simpler, safer)
• Use while loops when you need condition-based iteration
• If you can use a for loop, do it
• Use while loops for cases where for loops don't fit

[END SECTION 4.7]
================================================================================

SECTION 4.8: REAL-WORLD APPLICATIONS
--------------------------------------

APPLICATION 1: DATA PROCESSING
--------------------------------
PROBLEM: Process data until you find an invalid entry

CODE:
  data = [10, 20, 30, -1, 40, 50]  # -1 indicates invalid
  valid_data = []
  i = 0
  
  while i < len(data) and data[i] >= 0:
      valid_data.append(data[i])
      i += 1
  
  print("Valid data:", valid_data)

OUTPUT:
  Valid data: [10, 20, 30]

APPLICATION 2: MENU SYSTEM
--------------------------
PROBLEM: Create an interactive menu that runs until user quits

CODE:
  choice = ""
  
  while choice != "4":
      print("\nMenu:")
      print("1. Option 1")
      print("2. Option 2")
      print("3. Option 3")
      print("4. Quit")
      choice = input("Enter choice: ")
      
      if choice == "1":
          print("You chose option 1")
      elif choice == "2":
          print("You chose option 2")
      elif choice == "3":
          print("You chose option 3")
  
  print("Goodbye!")

APPLICATION 3: READING FILES
----------------------------
PROBLEM: Read file line by line until end

CODE:
  file = open("data.txt", "r")
  line = file.readline()
  
  while line != "":
      print(line.strip())
      line = file.readline()
  
  file.close()

APPLICATION 4: GAME DEVELOPMENT
-------------------------------
PROBLEM: Game loop that runs until game over

CODE:
  game_over = False
  score = 0
  
  while not game_over:
      # Update game state
      update_player()
      update_enemies()
      
      # Check for collisions
      if check_collision():
          game_over = True
      
      # Render game
      render_game()
      
      # Update score
      score += 1
  
  print(f"Game Over! Final score: {score}")

APPLICATION 5: SEARCH ALGORITHMS
---------------------------------
PROBLEM: Search through data until found

CODE:
  items = ["apple", "banana", "cherry", "date"]
  target = "cherry"
  found = False
  index = 0
  
  while index < len(items) and not found:
      if items[index] == target:
          found = True
          print(f"Found at index {index}")
      index += 1
  
  if not found:
      print("Not found")

[END SECTION 4.8]
================================================================================

PART 5: SUMMARY AND BEST PRACTICES
================================================================================

SECTION 5.1: QUICK REFERENCE GUIDE
-----------------------------------

FOR LOOPS
---------
  # With range
  for i in range(5):
      print(i)
  
  # With list
  for item in my_list:
      print(item)
  
  # With enumerate
  for i, item in enumerate(my_list):
      print(f"{i}: {item}")

WHILE LOOPS
-----------
  # Basic
  i = 0
  while i < 5:
      print(i)
      i += 1
  
  # With condition
  while condition:
      # Do something
      # Modify condition

RANGE() FUNCTION
----------------
  range(5)              # 0, 1, 2, 3, 4
  range(1, 5)           # 1, 2, 3, 4
  range(0, 10, 2)       # 0, 2, 4, 6, 8
  range(10, 0, -1)      # 10, 9, 8, 7, 6, 5, 4, 3, 2, 1

LOOP CONTROL
------------
  break      # Exit loop
  continue   # Skip to next iteration
  pass       # Do nothing

[END SECTION 5.1]
================================================================================

SECTION 5.2: COMMON MISTAKES TO AVOID
--------------------------------------

MISTAKE 1: FORGETTING TO INCREMENT IN WHILE LOOPS
--------------------------------------------------
BAD:
  i = 0
  while i < 5:
      print(i)
      # Forgot i += 1!

GOOD:
  i = 0
  while i < 5:
      print(i)
      i += 1

MISTAKE 2: MODIFYING LIST DURING ITERATION
------------------------------------------
BAD:
  items = [1, 2, 3, 4, 5]
  for item in items:
      if item == 3:
          items.remove(item)  # Can cause issues!

GOOD:
  items = [1, 2, 3, 4, 5]
  items = [item for item in items if item != 3]

MISTAKE 3: USING WHILE WHEN FOR IS BETTER
------------------------------------------
BAD:
  i = 0
  while i < len(my_list):
      print(my_list[i])
      i += 1

GOOD:
  for item in my_list:
      print(item)

MISTAKE 4: OFF-BY-ONE ERRORS WITH RANGE
----------------------------------------
BAD:
  for i in range(5):
      print(i)  # Prints 0-4, not 1-5

GOOD (if you want 1-5):
  for i in range(1, 6):
      print(i)

MISTAKE 5: INFINITE LOOPS
-------------------------
BAD:
  while True:
      print("Forever")  # No way to exit!

GOOD:
  while True:
      user_input = input("Enter 'quit': ")
      if user_input == "quit":
          break

[END SECTION 5.2]
================================================================================

SECTION 5.3: BEST PRACTICES
----------------------------

PRACTICE 1: USE DESCRIPTIVE VARIABLE NAMES
-------------------------------------------
BAD:
  for x in y:
      print(x)

GOOD:
  for student in students:
      print(student.name)

PRACTICE 2: PREFER FOR LOOPS WHEN POSSIBLE
------------------------------------------
BAD:
  i = 0
  while i < len(items):
      process(items[i])
      i += 1

GOOD:
  for item in items:
      process(item)

PRACTICE 3: ALWAYS MODIFY LOOP VARIABLES
-----------------------------------------
BAD:
  i = 0
  while i < 10:
      print(i)
      # Missing i += 1

GOOD:
  i = 0
  while i < 10:
      print(i)
      i += 1  # Always modify!

PRACTICE 4: USE enumerate() WHEN YOU NEED INDEX
------------------------------------------------
BAD:
  i = 0
  for item in my_list:
      print(f"{i}: {item}")
      i += 1

GOOD:
  for i, item in enumerate(my_list):
      print(f"{i}: {item}")

PRACTICE 5: ADD COMMENTS FOR COMPLEX LOGIC
-------------------------------------------
GOOD:
  # Process items until we find a negative number
  i = 0
  while i < len(numbers) and numbers[i] >= 0:
      process(numbers[i])
      i += 1

[END SECTION 5.3]
================================================================================

SECTION 5.4: PRACTICE EXERCISES
--------------------------------

EXERCISE 1: COUNT EVEN NUMBERS
-------------------------------
Write a for loop that counts even numbers from 0 to 20.

SOLUTION:
  count = 0
  for i in range(0, 21, 2):
      count += 1
  print(f"Found {count} even numbers")

EXERCISE 2: FIND FIRST NEGATIVE
--------------------------------
Write a while loop that finds the first negative number in a list.

SOLUTION:
  numbers = [10, 20, -5, 30, -10]
  i = 0
  while i < len(numbers) and numbers[i] >= 0:
      i += 1
  if i < len(numbers):
      print(f"First negative: {numbers[i]} at index {i}")

EXERCISE 3: REVERSE A LIST
---------------------------
Write a for loop that prints a list in reverse order.

SOLUTION:
  items = [1, 2, 3, 4, 5]
  for i in range(len(items) - 1, -1, -1):
      print(items[i])

EXERCISE 4: USER MENU
---------------------
Write a while loop that creates a menu system.

SOLUTION:
  choice = ""
  while choice != "quit":
      print("1. Option 1")
      print("2. Option 2")
      print("Type 'quit' to exit")
      choice = input("Enter choice: ")

[END SECTION 5.4]
================================================================================

FINAL SUMMARY
=============

WHAT YOU'VE LEARNED:
• The range() function and its variations
• For loops and how to use them
• While loops and conditional iteration
• The enumerate() function
• Nested loops
• Loop control statements
• When to use for vs while loops
• Common patterns and best practices

KEY TAKEAWAYS:
• Loops eliminate repetitive code
• For loops are best for known iterations
• While loops are best for conditional iteration
• Always modify loop variables in while loops
• Use enumerate() when you need both index and value
• Prefer for loops when possible (simpler, safer)

NEXT STEPS:
• Practice writing loops with different scenarios
• Try solving problems using both for and while loops
• Experiment with nested loops
• Check out the labs for examples with real data

Remember: Check out the labs for more examples of loops, many with real data.

================================================================================
END OF COMPREHENSIVE STUDY GUIDE
================================================================================
