================================================================================
OBJECTS AND CLASSES IN PYTHON
Comprehensive Study Guide - Part 1
================================================================================

WELCOME
-------
Welcome to Objects and Classes in Python. This comprehensive guide will teach you 
everything you need to know about objects, classes, types, methods, and how to 
create your own custom classes in Python. You'll learn the fundamentals, 
understand the relationship between objects and classes, and master object-oriented 
programming concepts through detailed examples and exhaustive explanations.

ESTIMATED TIME NEEDED
---------------------
10 minutes (for basic reading)
90-120 minutes (for comprehensive study with practice)

LEARNING OBJECTIVES
-------------------
After studying this guide, you will be able to:
• Explain what an object is in Python
• Understand that everything in Python is an object
• Identify the three components of every object (type, internal representation, methods)
• Explain what a type is and how it relates to objects
• Understand what methods are and how they work
• Use the type() function to identify object types
• Call methods on objects using dot notation
• Understand how methods change the state of objects
• Recognize the relationship between classes and objects
• Understand the concept of instances and instantiation

OVERVIEW
--------
Python is an object-oriented programming language, which means that everything in 
Python is an object. Every piece of data you work with - whether it's an integer, 
a string, a list, or a dictionary - is an object. Each object has a type (which 
determines what kind of object it is), an internal representation (how the data 
is stored), and methods (functions that allow you to interact with the object).

Understanding objects and classes is fundamental to Python programming because:
• Everything you work with is an object
• Objects have built-in methods that make your code more powerful
• You can create your own custom types (classes) to model real-world concepts
• Object-oriented programming helps organize and structure your code
• Classes allow you to create reusable, maintainable code

================================================================================
TABLE OF CONTENTS - PART 1
================================================================================

This part covers the fundamentals of objects, types, and methods:

PART 1: UNDERSTANDING OBJECTS IN PYTHON
  SECTION 1.1: WHAT IS AN OBJECT?
  SECTION 1.2: THE THREE COMPONENTS OF EVERY OBJECT
  SECTION 1.3: OBJECTS AS INSTANCES OF TYPES
  SECTION 1.4: EXAMPLES OF OBJECTS IN PYTHON
  SECTION 1.5: USING THE TYPE() FUNCTION
  SECTION 1.6: UNDERSTANDING METHODS
  SECTION 1.7: HOW METHODS WORK WITH OBJECTS
  SECTION 1.8: METHODS CHANGE THE STATE OF OBJECTS

NOTE: Part 2 covers creating your own classes (Circle and Rectangle classes).
Part 3 covers advanced class concepts, constructors, accessing attributes, and 
the dir() function.

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 1.3:") to quickly jump to any section.

================================================================================
PART 1: UNDERSTANDING OBJECTS IN PYTHON
================================================================================

SECTION 1.1: WHAT IS AN OBJECT?
--------------------------------

DEFINITION
----------
An object is an instance of a particular type. In Python, every piece of data 
is an object. Objects are the fundamental building blocks of Python programs.

DETAILED EXPLANATION
--------------------
An object is a self-contained unit that combines:
• Data (the information stored in the object)
• Behavior (the actions the object can perform)
• Identity (what makes this object unique)

Think of an object like a physical object in the real world. For example, a car 
is an object. It has:
• Data: color, make, model, year, mileage
• Behavior: start engine, accelerate, brake, turn
• Identity: a unique vehicle identification number (VIN)

In Python, everything follows this same pattern. Even simple things like numbers 
and strings are objects with data and behavior.

KEY POINT: EVERYTHING IN PYTHON IS AN OBJECT
---------------------------------------------
This is a fundamental concept in Python. Unlike some programming languages where 
primitive types (like integers) are treated differently from objects, Python 
treats everything uniformly as an object. This means:
• Integers are objects
• Floats are objects
• Strings are objects
• Lists are objects
• Dictionaries are objects
• Booleans are objects
• Functions are objects
• Classes are objects
• Even modules are objects!

This uniformity makes Python consistent and powerful. You can use the same 
techniques and patterns with all types of data.

REAL-WORLD ANALOGY
------------------
Think of objects like different types of vehicles:
• A "Car" is a type (class)
• Your specific car (with license plate ABC-123) is an object (instance)
• Another person's car (with license plate XYZ-789) is a different object (instance)
• Both are cars (same type), but they are different objects (different instances)

Similarly in Python:
• "int" is a type (class)
• The number 5 is an object (instance of int)
• The number 10 is a different object (instance of int)
• Both are integers (same type), but they are different objects (different instances)

WHY IS THIS IMPORTANT?
----------------------
Understanding that everything is an object means:
• You can use the same techniques with all data types
• You can call methods on any object
• You can create your own types (classes) that work just like built-in types
• The language is consistent and predictable
• You have more power and flexibility in your code

[END SECTION 1.1]
================================================================================

SECTION 1.2: THE THREE COMPONENTS OF EVERY OBJECT
--------------------------------------------------

DEFINITION
----------
Every object in Python has three essential components:
1. A type (what kind of object it is)
2. An internal representation (how the data is stored)
3. A set of functions called methods (how to interact with the data)

DETAILED EXPLANATION
--------------------
These three components work together to define what an object is and what it can do.

COMPONENT 1: TYPE
-----------------
The type tells Python (and you) what kind of object you're working with. It's 
like a label that categorizes the object.

Examples of types:
• int - for integers (whole numbers)
• float - for floating-point numbers (decimal numbers)
• str - for strings (text)
• list - for lists (ordered collections)
• dict - for dictionaries (key-value pairs)
• bool - for Booleans (True/False)

The type determines:
• What operations are allowed on the object
• What methods are available
• How the object behaves
• How much memory it uses

COMPONENT 2: INTERNAL REPRESENTATION
------------------------------------
The internal representation is how Python stores the actual data inside the object 
in computer memory. This is usually hidden from you, but it's important because 
it affects:
• How much memory the object uses
• How fast operations are
• What values the object can hold

For example:
• An integer might be stored as a binary number
• A string might be stored as a sequence of characters
• A list might be stored as a dynamic array

You don't usually need to worry about the internal representation - Python handles 
it for you. But understanding that it exists helps you understand how objects work.

COMPONENT 3: METHODS
--------------------
Methods are functions that belong to the object. They allow you to interact with 
and manipulate the object's data. Methods are like tools that come with the object.

Key characteristics of methods:
• They are functions that are attached to objects
• They can access and modify the object's data
• They are called using dot notation (object.method())
• Different types have different methods available

Examples:
• Lists have methods like append(), sort(), reverse()
• Strings have methods like upper(), lower(), split()
• Dictionaries have methods like keys(), values(), items()

VISUAL REPRESENTATION
---------------------
Think of an object like a toolbox:

┌─────────────────────────────────────┐
│         OBJECT (Toolbox)            │
├─────────────────────────────────────┤
│ TYPE: "List"                        │  ← Label on the box
│                                     │
│ INTERNAL REPRESENTATION:            │  ← What's inside
│   [1, 2, 3, 4, 5]                  │
│                                     │
│ METHODS:                            │  ← Tools available
│   • append()                        │
│   • sort()                          │
│   • reverse()                       │
│   • remove()                        │
└─────────────────────────────────────┘

The type is the label (what kind of toolbox it is).
The internal representation is the contents (what's stored inside).
The methods are the tools (what you can do with it).

REAL-WORLD ANALOGY
------------------
Think of a smartphone:
• TYPE: "iPhone" or "Android" (what kind of phone it is)
• INTERNAL REPRESENTATION: The actual hardware, memory, storage, etc. (how it's built)
• METHODS: The apps and functions (what you can do with it - call, text, browse, etc.)

All smartphones have these three components, just like all Python objects do.

[END SECTION 1.2]
================================================================================

SECTION 1.3: OBJECTS AS INSTANCES OF TYPES
-------------------------------------------

DEFINITION
----------
An object is an instance of a particular type. Multiple objects can be instances 
of the same type, but each object is a separate, independent instance.

DETAILED EXPLANATION
--------------------
The relationship between types and objects is fundamental:
• A TYPE (or class) is like a blueprint or template
• An OBJECT (or instance) is a specific realization of that blueprint

Think of it like this:
• TYPE = Cookie cutter
• OBJECT = Individual cookie made with that cutter

You can use one cookie cutter (type) to make many cookies (objects). All the 
cookies have the same shape (same type), but each cookie is a separate, 
independent object.

VISUAL EXAMPLE
--------------
Imagine we have two types: Type 1 and Type 2.

Type 1 objects (shown in yellow):
┌─────┐  ┌─────┐  ┌─────┐
│ Obj │  │ Obj │  │ Obj │  ← Three objects, all instances of Type 1
│  1  │  │  2  │  │  3  │
└─────┘  └─────┘  └─────┘
   ↓       ↓       ↓
All are instances of Type 1

Type 2 objects (shown in green):
┌─────┐  ┌─────┐
│ Obj │  │ Obj │  ← Two objects, all instances of Type 2
│  A  │  │  B  │
└─────┘  └─────┘
   ↓       ↓
All are instances of Type 2

KEY CONCEPTS
------------
1. ONE TYPE, MANY OBJECTS
   You can create many objects from the same type. Each object is independent.

2. EACH OBJECT IS UNIQUE
   Even if two objects have the same data, they are separate objects in memory.

3. OBJECTS SHARE THE TYPE'S METHODS
   All objects of the same type have access to the same methods, but they operate 
   on their own data.

EXAMPLE IN PYTHON
-----------------
Let's see this concept with integers:

# Creating multiple integer objects (all instances of type int)
number1 = 5    # Object 1: instance of type int
number2 = 10   # Object 2: instance of type int
number3 = 5    # Object 3: instance of type int (same value as number1, but different object)
number4 = 20   # Object 4: instance of type int
number5 = 10   # Object 5: instance of type int (same value as number2, but different object)

# All five are objects
# All five are instances of type int
# But each is a separate, independent object

Similarly with lists:

# Creating multiple list objects (all instances of type list)
list1 = [1, 2, 3]      # Object 1: instance of type list
list2 = [4, 5, 6]      # Object 2: instance of type list
list3 = [1, 2, 3]      # Object 3: instance of type list (same values as list1, but different object)
list4 = [7, 8, 9]      # Object 4: instance of type list
list5 = [4, 5, 6]      # Object 5: instance of type list (same values as list2, but different object)

# All five are objects
# All five are instances of type list
# But each is a separate, independent object
# Changes to one list don't affect the others

WHY THIS MATTERS
----------------
Understanding that objects are instances of types helps you:
• Understand how Python organizes data
• See why you can create multiple objects from one type
• Understand that each object is independent
• Recognize that objects of the same type share methods but have separate data
• Prepare for creating your own classes (custom types)

[END SECTION 1.3]
================================================================================

SECTION 1.4: EXAMPLES OF OBJECTS IN PYTHON
-------------------------------------------

DEFINITION
----------
Every time you create a piece of data in Python, you are creating an object. 
This includes integers, floats, strings, lists, dictionaries, and Booleans.

DETAILED EXPLANATION WITH EXAMPLES
----------------------------------
Let's look at concrete examples of creating objects in Python.

EXAMPLE 1: CREATING INTEGER OBJECTS
-----------------------------------
Every time you create an integer, you are creating an instance of type integer, 
or you are creating an integer object.

Code:
number1 = 5
number2 = 10
number3 = 15
number4 = 20
number5 = 25

Line-by-line explanation:
• number1 = 5
  - "number1" is a variable name (a label)
  - "=" is the assignment operator (assigns a value to the variable)
  - "5" creates a new integer object with the value 5
  - This integer object is an instance of type int
  - The variable "number1" now refers to (points to) this integer object

• number2 = 10
  - Creates a new integer object with the value 10
  - This is a different object from number1
  - Both are instances of type int, but they are separate objects

• number3 = 15
  - Creates another new integer object with the value 15
  - This is a third separate object

• number4 = 20
  - Creates a fourth integer object

• number5 = 25
  - Creates a fifth integer object

In this case, we are creating five instances of type integer or five integer 
objects. Each one is separate and independent.

VISUAL REPRESENTATION:
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│  int    │    │  int    │    │  int    │    │  int    │    │  int    │
│    5    │    │   10    │    │   15    │    │   20    │    │   25    │
└─────────┘    └─────────┘    └─────────┘    └─────────┘    └─────────┘
   ↓              ↓              ↓              ↓              ↓
number1        number2        number3        number4        number5

All are type: int
All are separate objects

EXAMPLE 2: CREATING LIST OBJECTS
---------------------------------
Similarly, every time you create a list, you are creating an instance of type 
list, or you are creating a list object.

Code:
list1 = [1, 2, 3]
list2 = [4, 5, 6]
list3 = [7, 8, 9]
list4 = [10, 11, 12]
list5 = [13, 14, 15]

Line-by-line explanation:
• list1 = [1, 2, 3]
  - "list1" is a variable name
  - "=" assigns a value to the variable
  - "[1, 2, 3]" creates a new list object containing the integers 1, 2, and 3
  - This list object is an instance of type list
  - The variable "list1" now refers to this list object

• list2 = [4, 5, 6]
  - Creates a new list object with different values
  - This is a completely separate object from list1
  - Both are instances of type list, but they are different objects

• list3 = [7, 8, 9]
  - Creates a third list object

• list4 = [10, 11, 12]
  - Creates a fourth list object

• list5 = [13, 14, 15]
  - Creates a fifth list object

In this case, we are creating five instances of type list or five list objects. 
Each list is independent - modifying one doesn't affect the others.

VISUAL REPRESENTATION:
┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│    list     │  │    list     │  │    list     │  │    list     │  │    list     │
│  [1,2,3]    │  │  [4,5,6]    │  │  [7,8,9]    │  │ [10,11,12]  │  │ [13,14,15]  │
└─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘
     ↓                ↓                ↓                ↓                ↓
   list1            list2            list3            list4            list5

All are type: list
All are separate objects

EXAMPLE 3: OTHER TYPES OF OBJECTS
----------------------------------
The same principle applies to all data types:

Strings:
str1 = "Hello"        # Object 1: instance of type str
str2 = "World"       # Object 2: instance of type str
str3 = "Python"      # Object 3: instance of type str

Dictionaries:
dict1 = {"name": "Alice"}           # Object 1: instance of type dict
dict2 = {"name": "Bob"}              # Object 2: instance of type dict
dict3 = {"age": 25}                 # Object 3: instance of type dict

Booleans:
bool1 = True         # Object 1: instance of type bool
bool2 = False        # Object 2: instance of type bool

Floats:
float1 = 3.14        # Object 1: instance of type float
float2 = 2.71        # Object 2: instance of type float

KEY TAKEAWAY
------------
Every piece of data you create in Python is an object. Whether it's a simple 
integer or a complex data structure, Python treats it as an object with a type, 
internal representation, and methods.

[END SECTION 1.4]
================================================================================

SECTION 1.5: USING THE TYPE() FUNCTION
---------------------------------------

DEFINITION
----------
We can find out the type of an object by using the type() function. This function 
returns the type (class) that an object belongs to.

DETAILED EXPLANATION
--------------------
The type() function is a built-in Python function that tells you what type an 
object is. It's like asking "What kind of object is this?"

SYNTAX
------
type(object)

Where:
• type is the function name
• object is the object whose type you want to know
• Returns the type (class) of the object

EXAMPLES WITH DETAILED EXPLANATIONS
-----------------------------------

EXAMPLE 1: CHECKING THE TYPE OF A LIST
---------------------------------------
Code:
my_list = [1, 2, 3, 4, 5]
print(type(my_list))

Line-by-line explanation:
• my_list = [1, 2, 3, 4, 5]
  - Creates a list object containing the integers 1, 2, 3, 4, and 5
  - The variable "my_list" refers to this list object

• print(type(my_list))
  - type(my_list) calls the type() function with my_list as the argument
  - The type() function examines the object that my_list refers to
  - It determines that this object is an instance of type list
  - It returns the type <class 'list'>
  - print() displays this result on the screen

Output:
<class 'list'>

This tells us that my_list is an object of type list.

EXAMPLE 2: CHECKING THE TYPE OF AN INTEGER
-------------------------------------------
Code:
my_number = 42
print(type(my_number))

Line-by-line explanation:
• my_number = 42
  - Creates an integer object with the value 42
  - The variable "my_number" refers to this integer object

• print(type(my_number))
  - type(my_number) calls the type() function
  - It determines that this object is an instance of type int
  - Returns <class 'int'>
  - print() displays the result

Output:
<class 'int'>

This tells us that my_number is an object of type integer.

EXAMPLE 3: CHECKING THE TYPE OF A STRING
----------------------------------------
Code:
my_text = "Hello, Python!"
print(type(my_text))

Line-by-line explanation:
• my_text = "Hello, Python!"
  - Creates a string object containing the text "Hello, Python!"
  - The variable "my_text" refers to this string object

• print(type(my_text))
  - type(my_text) calls the type() function
  - It determines that this object is an instance of type str
  - Returns <class 'str'>
  - print() displays the result

Output:
<class 'str'>

This tells us that my_text is an object of type string.

EXAMPLE 4: CHECKING THE TYPE OF A DICTIONARY
--------------------------------------------
Code:
my_dict = {"name": "Alice", "age": 30}
print(type(my_dict))

Line-by-line explanation:
• my_dict = {"name": "Alice", "age": 30}
  - Creates a dictionary object with key-value pairs
  - The variable "my_dict" refers to this dictionary object

• print(type(my_dict))
  - type(my_dict) calls the type() function
  - It determines that this object is an instance of type dict
  - Returns <class 'dict'>
  - print() displays the result

Output:
<class 'dict'>

This tells us that my_dict is an object of type dictionary.

COMPREHENSIVE EXAMPLE: CHECKING MULTIPLE TYPES
----------------------------------------------
Code:
# Different types of objects
my_list = [1, 2, 3]
my_int = 42
my_string = "Hello"
my_dict = {"key": "value"}

# Check each type
print("Type of my_list:", type(my_list))
print("Type of my_int:", type(my_int))
print("Type of my_string:", type(my_string))
print("Type of my_dict:", type(my_dict))

Line-by-line explanation:
• my_list = [1, 2, 3]
  - Creates a list object

• my_int = 42
  - Creates an integer object

• my_string = "Hello"
  - Creates a string object

• my_dict = {"key": "value"}
  - Creates a dictionary object

• print("Type of my_list:", type(my_list))
  - First part: "Type of my_list:" is a string that will be printed
  - Second part: type(my_list) gets the type of the my_list object
  - The comma separates the two parts, and print() displays both

• Similar explanations apply to the other print statements

Output:
Type of my_list: <class 'list'>
Type of my_int: <class 'int'>
Type of my_string: <class 'str'>
Type of my_dict: <class 'dict'>

UNDERSTANDING THE OUTPUT
------------------------
The output format <class 'typename'> tells us:
• <class ...> means this is a class (type) in Python
• 'typename' is the name of the type (list, int, str, dict, etc.)

WHY USE TYPE()?
--------------
The type() function is useful for:
• Debugging: Understanding what type of object you're working with
• Type checking: Verifying that an object is the expected type
• Learning: Exploring Python and understanding how objects work
• Conditional logic: Writing code that behaves differently based on type

[END SECTION 1.5]
================================================================================

SECTION 1.6: UNDERSTANDING METHODS
-----------------------------------

DEFINITION
----------
A class or type's methods are functions that every instance of that class or type 
provides. Methods are how you interact with objects. They allow you to perform 
actions on the object's data.

DETAILED EXPLANATION
--------------------
Methods are special functions that belong to objects. They're like tools that 
come with each object, allowing you to do things with the object's data.

KEY CHARACTERISTICS OF METHODS
------------------------------
1. METHODS BELONG TO OBJECTS
   Methods are attached to objects. You can't use a method without an object.

2. METHODS OPERATE ON OBJECT DATA
   Methods can access and modify the data stored in the object.

3. METHODS ARE CALLED WITH DOT NOTATION
   You call a method using: object.method()

4. DIFFERENT TYPES HAVE DIFFERENT METHODS
   Each type (int, str, list, dict, etc.) has its own set of methods.

5. METHODS ARE FUNCTIONS
   Methods are essentially functions, but they're associated with objects.

REAL-WORLD ANALOGY
------------------
Think of methods like the buttons on a remote control:
• The remote control is the object
• Each button is a method
• Pressing a button (calling a method) performs an action
• Different remotes (different object types) have different buttons (methods)
• You need the remote (object) to press the button (use the method)

EXAMPLES OF METHODS WE'VE BEEN USING
------------------------------------
We have been using methods all this time, for example, on lists. Many common 
operations in Python are actually method calls.

EXAMPLE: LIST METHODS
---------------------
Lists have many useful methods:
• append() - adds an item to the end of the list
• sort() - sorts the list
• reverse() - reverses the order of items
• remove() - removes an item from the list
• count() - counts how many times an item appears
• index() - finds the position of an item

HOW TO CALL METHODS
-------------------
To call a method, you use dot notation:

object_name.method_name(arguments)

Where:
• object_name is the name of the object (or variable referring to the object)
• . (dot) connects the object to the method
• method_name is the name of the method you want to call
• (arguments) are any values you pass to the method (some methods don't need arguments)

EXAMPLE: CALLING THE APPEND METHOD
----------------------------------
Code:
my_list = [1, 2, 3]
my_list.append(4)
print(my_list)

Line-by-line explanation:
• my_list = [1, 2, 3]
  - Creates a list object containing [1, 2, 3]
  - The variable "my_list" refers to this list object

• my_list.append(4)
  - "my_list" refers to our list object
  - "." is the dot operator that accesses the method
  - "append" is the method name
  - "(4)" passes the value 4 as an argument to the append method
  - The append method adds 4 to the end of the list
  - This modifies the list object (changes its internal data)

• print(my_list)
  - Displays the modified list

Output:
[1, 2, 3, 4]

The list now contains four items instead of three.

KEY POINT: METHODS CHANGE THE OBJECT
------------------------------------
When you call a method, it can change the object's data. This is called changing 
the state of the object. The object's state is the current values of all its data.

[END SECTION 1.6]
================================================================================

SECTION 1.7: HOW METHODS WORK WITH OBJECTS
-------------------------------------------

DEFINITION
----------
Methods interact with the data in objects. When you call a method, it performs 
operations on the object's data, potentially changing the object's state.

DETAILED EXPLANATION WITH EXAMPLE
----------------------------------
Let's examine a concrete example to understand how methods work with objects.

EXAMPLE: THE SORT METHOD ON A LIST
-----------------------------------
Consider the list ratings. The data is a series of numbers contained within the 
list. The method sort() will change the data within the object.

Code:
ratings = [8, 5, 9, 2, 7]
print("Before sorting:", ratings)
ratings.sort()
print("After sorting:", ratings)

Line-by-line explanation:
• ratings = [8, 5, 9, 2, 7]
  - Creates a list object containing the numbers 8, 5, 9, 2, and 7
  - The variable "ratings" refers to this list object
  - The list's internal data is: [8, 5, 9, 2, 7]

• print("Before sorting:", ratings)
  - Displays the list before any changes
  - Shows us the original state of the object

• ratings.sort()
  - "ratings" refers to our list object
  - "." accesses the method
  - "sort" is the method name
  - "()" calls the method with no arguments (sort() doesn't need arguments)
  - The sort() method examines the data in the list
  - It rearranges the numbers in ascending order (smallest to largest)
  - This changes the internal data of the list object
  - The list's state changes from [8, 5, 9, 2, 7] to [2, 5, 7, 8, 9]

• print("After sorting:", ratings)
  - Displays the list after sorting
  - Shows us the new state of the object

Output:
Before sorting: [8, 5, 9, 2, 7]
After sorting: [2, 5, 7, 8, 9]

VISUAL REPRESENTATION
---------------------
Before calling sort():

┌─────────────────────────┐
│      List Object        │
│   (represented in       │
│        orange)          │
├─────────────────────────┤
│ Internal Data:          │
│   [8, 5, 9, 2, 7]       │  ← Sequence of numbers
└─────────────────────────┘
         ↓
      ratings

After calling sort():

┌─────────────────────────┐
│      List Object        │
│   (represented in       │
│        orange)          │
├─────────────────────────┤
│ Internal Data:          │
│   [2, 5, 7, 8, 9]       │  ← Changed! Now sorted
└─────────────────────────┘
         ↓
      ratings

The same object, but its internal data has changed.

UNDERSTANDING THE CHANGE
------------------------
When we call the sort method:
1. The method accesses the list's data
2. It examines all the numbers
3. It rearranges them in order
4. It updates the list's internal data
5. The object's state changes

You can say it changes the state of the object. The state is the current 
condition or values of the object's data.

EXAMPLE: THE REVERSE METHOD
---------------------------
We can call the reverse() method on the list, changing the list again.

Code:
ratings = [2, 5, 7, 8, 9]
print("Before reverse:", ratings)
ratings.reverse()
print("After reverse:", ratings)

Line-by-line explanation:
• ratings = [2, 5, 7, 8, 9]
  - Creates a list object (or uses existing one)
  - Contains sorted numbers

• print("Before reverse:", ratings)
  - Shows the list before reversing

• ratings.reverse()
  - Calls the reverse() method on the list
  - The reverse() method reverses the order of the sequence within the object
  - Changes [2, 5, 7, 8, 9] to [9, 8, 7, 5, 2]
  - This modifies the object's state again

• print("After reverse:", ratings)
  - Shows the list after reversing

Output:
Before reverse: [2, 5, 7, 8, 9]
After reverse: [9, 8, 7, 5, 2]

VISUAL REPRESENTATION
---------------------
Before reverse():
┌─────────────────────────┐
│      List Object        │
├─────────────────────────┤
│ Internal Data:          │
│   [2, 5, 7, 8, 9]       │
└─────────────────────────┘

After reverse():
┌─────────────────────────┐
│      List Object        │
├─────────────────────────┤
│ Internal Data:          │
│   [9, 8, 7, 5, 2]       │  ← Reversed order
└─────────────────────────┘

KEY CONCEPTS
------------
1. METHODS MODIFY OBJECTS
   Methods can change the object's internal data.

2. THE OBJECT'S STATE CHANGES
   Each method call can change what data is stored in the object.

3. THE SAME OBJECT, DIFFERENT STATE
   It's the same object (same variable name), but its contents have changed.

4. METHODS OPERATE ON THE OBJECT'S DATA
   Methods work with the data that belongs to that specific object.

[END SECTION 1.7]
================================================================================

SECTION 1.8: METHODS CHANGE THE STATE OF OBJECTS
--------------------------------------------------

DEFINITION
----------
When you call a method on an object, it can change the object's state. The state 
of an object is the current values of all its data attributes.

DETAILED EXPLANATION
--------------------
The state of an object is like a snapshot of what the object contains at a 
particular moment. When you call methods that modify the object, you're changing 
its state.

UNDERSTANDING STATE
-------------------
Think of an object's state like the settings on your phone:
• State 1: Volume at 50%, brightness at 70%, Wi-Fi on
• State 2: Volume at 75%, brightness at 70%, Wi-Fi on (volume changed)
• State 3: Volume at 75%, brightness at 50%, Wi-Fi on (brightness changed)

Each change modifies the state. The phone (object) is the same, but its settings 
(state) have changed.

COMPREHENSIVE EXAMPLE: TRACKING STATE CHANGES
---------------------------------------------
Let's trace through a complete example showing how methods change an object's state.

Code:
# Step 1: Create a list object
numbers = [3, 1, 4, 1, 5]
print("Initial state:", numbers)

# Step 2: Add an item (changes state)
numbers.append(9)
print("After append(9):", numbers)

# Step 3: Sort the list (changes state)
numbers.sort()
print("After sort():", numbers)

# Step 4: Reverse the list (changes state)
numbers.reverse()
print("After reverse():", numbers)

# Step 5: Remove an item (changes state)
numbers.remove(1)
print("After remove(1):", numbers)

Line-by-line explanation:

STEP 1: CREATING THE OBJECT
• numbers = [3, 1, 4, 1, 5]
  - Creates a list object
  - Initial state: [3, 1, 4, 1, 5]
  - The object exists in memory with this data

• print("Initial state:", numbers)
  - Displays the initial state

STEP 2: APPENDING AN ITEM
• numbers.append(9)
  - Calls the append() method
  - Adds 9 to the end of the list
  - Changes state from [3, 1, 4, 1, 5] to [3, 1, 4, 1, 5, 9]
  - The same object, but state has changed

• print("After append(9):", numbers)
  - Shows the new state

STEP 3: SORTING THE LIST
• numbers.sort()
  - Calls the sort() method
  - Rearranges items in ascending order
  - Changes state from [3, 1, 4, 1, 5, 9] to [1, 1, 3, 4, 5, 9]
  - State changed again

• print("After sort():", numbers)
  - Shows the sorted state

STEP 4: REVERSING THE LIST
• numbers.reverse()
  - Calls the reverse() method
  - Reverses the order of items
  - Changes state from [1, 1, 3, 4, 5, 9] to [9, 5, 4, 3, 1, 1]
  - State changed again

• print("After reverse():", numbers)
  - Shows the reversed state

STEP 5: REMOVING AN ITEM
• numbers.remove(1)
  - Calls the remove() method
  - Removes the first occurrence of 1
  - Changes state from [9, 5, 4, 3, 1, 1] to [9, 5, 4, 3, 1]
  - State changed again

• print("After remove(1):", numbers)
  - Shows the final state

Output:
Initial state: [3, 1, 4, 1, 5]
After append(9): [3, 1, 4, 1, 5, 9]
After sort(): [1, 1, 3, 4, 5, 9]
After reverse(): [9, 5, 4, 3, 1, 1]
After remove(1): [9, 5, 4, 3, 1]

VISUAL TIMELINE OF STATE CHANGES
---------------------------------
State 1: [3, 1, 4, 1, 5]          ← Initial state
         ↓ append(9)
State 2: [3, 1, 4, 1, 5, 9]       ← Added 9
         ↓ sort()
State 3: [1, 1, 3, 4, 5, 9]       ← Sorted
         ↓ reverse()
State 4: [9, 5, 4, 3, 1, 1]       ← Reversed
         ↓ remove(1)
State 5: [9, 5, 4, 3, 1]          ← Removed first 1

Each arrow represents a method call that changes the state.

IMPORTANT POINTS
----------------
1. THE OBJECT REMAINS THE SAME
   Throughout all these operations, "numbers" refers to the same object in memory. 
   We're not creating new objects; we're modifying the existing one.

2. THE STATE KEEPS CHANGING
   Each method call potentially changes what data is stored in the object.

3. METHODS THAT DON'T CHANGE STATE
   Some methods don't change the object's state. For example:
   - len(numbers) - just returns the length, doesn't change the list
   - numbers.count(1) - just counts occurrences, doesn't change the list

4. METHODS THAT DO CHANGE STATE
   Methods like append(), sort(), reverse(), remove() modify the object's data.

WHY THIS MATTERS
----------------
Understanding that methods change state helps you:
• Predict how your code will behave
• Understand why objects change when you call methods
• Debug issues related to unexpected changes
• Write code that modifies objects correctly
• Understand the difference between methods that modify vs. those that don't

[END SECTION 1.8]
================================================================================

SUMMARY OF PART 1
=================

KEY CONCEPTS COVERED
--------------------
1. Everything in Python is an object
2. Every object has three components: type, internal representation, and methods
3. Objects are instances of types
4. You can create multiple objects from the same type
5. The type() function tells you what type an object is
6. Methods are functions that belong to objects
7. Methods are called using dot notation: object.method()
8. Methods can change the state of objects
9. Different types have different methods available

WHAT YOU'VE LEARNED
-------------------
• What objects are and why they're fundamental to Python
• How to identify the type of any object
• How methods work and how to call them
• How methods modify objects and change their state
• The relationship between types and objects

NEXT STEPS
----------
In Part 2, you'll learn:
• How to create your own custom classes (types)
• How to define data attributes for your classes
• How to create objects from your custom classes
• How to work with the Circle and Rectangle class examples
• Understanding constructors and the __init__ method

================================================================================
END OF PART 1
================================================================================
