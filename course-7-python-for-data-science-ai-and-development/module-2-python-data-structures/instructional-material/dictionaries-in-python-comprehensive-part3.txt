================================================================================
COMPREHENSIVE STUDY GUIDE: DICTIONARIES IN PYTHON
Part 3: Advanced Methods, Comprehensions, Nested Dictionaries, and Best Practices
================================================================================

================================================================================
TABLE OF CONTENTS - PART 3
================================================================================

PART 3: ADVANCED METHODS, COMPREHENSIONS, NESTED DICTIONARIES, AND BEST PRACTICES
  SECTION 12: MORE DICTIONARY METHODS
    • The update() Method
    • The pop() Method
    • The popitem() Method
    • The clear() Method
  
  SECTION 13: DICTIONARY COMPREHENSIONS
    • What Are Dictionary Comprehensions?
  
  SECTION 14: NESTED DICTIONARIES
    • What Are Nested Dictionaries?
    • Accessing Values in Nested Dictionaries
    • Modifying Nested Dictionaries
    • Iterating Over Nested Dictionaries
  
  SECTION 15: COPYING DICTIONARIES
    • Shallow Copy vs Deep Copy
  
  SECTION 16: DICTIONARY VIEWS AND THEIR BEHAVIOR
    • Understanding View Objects
    • Set-Like Operations on Views
  
  SECTION 17: BEST PRACTICES AND COMMON PATTERNS
    • Best Practices for Working with Dictionaries
    • Common Patterns
  
  SECTION 18: SUMMARY AND KEY TAKEAWAYS
    • Essential Dictionary Concepts
    • When to Use Dictionaries

NOTE: Part 1 of this guide covers:
  • Introduction to dictionaries
  • Understanding dictionary structure
  • Creating dictionaries
  • Understanding keys and values
  • Accessing, adding, modifying, and deleting entries

NOTE: Part 2 of this guide covers:
  • Checking if keys exist in dictionaries (the "in" operator)
  • Dictionary methods (keys(), values(), items())
  • Iterating over dictionaries
  • The get() method for safe value access

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 12:") to quickly jump to any section.

================================================================================
SECTION 12: MORE DICTIONARY METHODS
================================================================================

THE update() METHOD
================================================================================

The update() method adds or updates multiple key-value pairs at once. It can 
take another dictionary, an iterable of key-value pairs, or keyword arguments.

Syntax:
dictionary_name.update(other_dictionary)
dictionary_name.update(iterable_of_pairs)
dictionary_name.update(key1=value1, key2=value2)

Breaking Down the Syntax:
- dictionary_name = The dictionary to update
- . = Dot operator
- update() = Method name
- Arguments can be: another dictionary, iterable of pairs, or keyword arguments

How It Works:
- If a key from the update source already exists: updates the value
- If a key from the update source doesn't exist: adds the new key-value pair
- Modifies the dictionary in place (doesn't return a new dictionary)

Example 1: Updating with Another Dictionary
---------------------------------------------
album_releases = {
    "Back in Black": 1980,
    "The Dark Side of the Moon": 1973
}

new_albums = {
    "The Bodyguard": 1992,
    "Graduation": 2007
}

album_releases.update(new_albums)

Line-by-line explanation:
- Lines 1-4: Creates original dictionary with two entries
- Lines 6-9: Creates another dictionary with two new entries
- Line 11: Updates the original dictionary
  - "album_releases" = dictionary to update
  - "." = dot operator
  - "update(new_albums)" = method call with another dictionary as argument
  - Python takes all key-value pairs from new_albums
  - Python adds them to album_releases
  - Since none of these keys exist in album_releases, they are added

Result: album_releases now contains:
{
    "Back in Black": 1980,
    "The Dark Side of the Moon": 1973,
    "The Bodyguard": 1992,      ← Added
    "Graduation": 2007           ← Added
}

Example 2: Updating Existing Keys
-----------------------------------
album_releases = {
    "Back in Black": 1980,
    "The Dark Side of the Moon": 1973
}

updates = {
    "Back in Black": 1981,  # This will update the existing key
    "Thriller": 1982         # This will add a new key
}

album_releases.update(updates)

Line-by-line explanation:
- Lines 1-4: Creates original dictionary
- Lines 6-9: Creates dictionary with updates
  - "Back in Black": 1981 = key exists, so value will be updated
  - "Thriller": 1982 = key doesn't exist, so it will be added
- Line 11: Updates the dictionary
  - Python processes each key-value pair
  - "Back in Black" exists → updates value from 1980 to 1981
  - "Thriller" doesn't exist → adds new key-value pair

Result: album_releases now contains:
{
    "Back in Black": 1981,        ← Updated (was 1980)
    "The Dark Side of the Moon": 1973,
    "Thriller": 1982              ← Added
}

Example 3: Updating with Keyword Arguments
-------------------------------------------
album_releases = {
    "Back in Black": 1980
}

album_releases.update(Thriller=1982, Graduation=2007)

Line-by-line explanation:
- Lines 1-3: Creates dictionary with one entry
- Line 5: Updates using keyword arguments
  - "update(Thriller=1982, Graduation=2007)" = keyword arguments
  - Python converts these to key-value pairs
  - Thriller=1982 becomes "Thriller": 1982
  - Graduation=2007 becomes "Graduation": 2007
  - Both are added to the dictionary

Result: album_releases now contains:
{
    "Back in Black": 1980,
    "Thriller": 1982,      ← Added
    "Graduation": 2007     ← Added
}

Note: When using keyword arguments, the keys must be valid Python identifiers 
(no spaces, no special characters that aren't allowed in variable names).

THE pop() METHOD
================================================================================

The pop() method removes a key-value pair from the dictionary and returns the 
value. This is safer than using del because it can return a default value if 
the key doesn't exist.

Syntax:
dictionary_name.pop(key, default_value)

Breaking Down the Syntax:
- dictionary_name = The dictionary variable name
- . = Dot operator
- pop() = Method name
- key = The key to remove
- default_value = Optional. Value to return if key doesn't exist. If not 
  provided and key doesn't exist, raises KeyError.

How It Works:
- Removes the key-value pair from the dictionary
- Returns the value that was associated with the key
- If key doesn't exist and default provided: returns default value
- If key doesn't exist and no default: raises KeyError

Example 1: Popping an Existing Key
------------------------------------
album_releases = {
    "Back in Black": 1980,
    "The Dark Side of the Moon": 1973,
    "The Bodyguard": 1992
}

year = album_releases.pop("The Bodyguard")

Line-by-line explanation:
- Lines 1-5: Creates dictionary with three entries
- Line 7: Removes key and gets its value
  - "album_releases" = dictionary name
  - "." = dot operator
  - "pop(\"The Bodyguard\")" = method call with key to remove
  - Python finds the key "The Bodyguard"
  - Python removes the key-value pair from the dictionary
  - Python returns the value: 1992
  - "year" = variable storing the returned value
  - "=" = assignment operator

Result:
- year = 1992 (the value that was removed)
- album_releases now contains:
  {
      "Back in Black": 1980,
      "The Dark Side of the Moon": 1973
      # "The Bodyguard": 1992 has been removed
  }

Example 2: Popping a Non-Existent Key with Default
----------------------------------------------------
album_releases = {
    "Back in Black": 1980
}

year = album_releases.pop("Thriller", "Not found")

Line-by-line explanation:
- Lines 1-3: Creates dictionary with one entry
- Line 5: Attempts to pop non-existent key
  - "pop(\"Thriller\", \"Not found\")" = method call with key and default
  - Python searches for "Thriller"
  - Python doesn't find it
  - Python returns the default value: "Not found"
  - Dictionary remains unchanged (no key to remove)

Result:
- year = "Not found"
- album_releases remains: {"Back in Black": 1980}

No KeyError! The method safely returns the default value.

Example 3: Popping a Non-Existent Key Without Default
------------------------------------------------------
album_releases = {
    "Back in Black": 1980
}

# This will raise KeyError!
year = album_releases.pop("Thriller")

Line-by-line explanation:
- Lines 1-3: Creates dictionary
- Line 5: Attempts to pop non-existent key without default
  - Python searches for "Thriller"
  - Python doesn't find it
  - Python raises KeyError: 'Thriller'

Error Message:
KeyError: 'Thriller'

This happens because there's no default value provided and the key doesn't exist.

Best Practice: Always provide a default value when using pop() if you're not 
certain the key exists.

THE popitem() METHOD
================================================================================

The popitem() method removes and returns the last key-value pair that was 
inserted into the dictionary (in Python 3.7+, dictionaries maintain insertion 
order). This is useful when you want to process items one at a time.

Syntax:
dictionary_name.popitem()

Breaking Down the Syntax:
- dictionary_name = The dictionary variable name
- . = Dot operator
- popitem() = Method name (no arguments needed)

How It Works:
- Removes the last inserted key-value pair
- Returns it as a tuple: (key, value)
- If dictionary is empty: raises KeyError

Example 1: Popping the Last Item
----------------------------------
album_releases = {
    "Back in Black": 1980,
    "The Dark Side of the Moon": 1973,
    "The Bodyguard": 1992
}

item = album_releases.popitem()

Line-by-line explanation:
- Lines 1-5: Creates dictionary with three entries
- Line 7: Removes and returns the last item
  - "album_releases" = dictionary name
  - "." = dot operator
  - "popitem()" = method call (no arguments)
  - Python removes the last inserted pair: "The Bodyguard": 1992
  - Python returns it as a tuple: ("The Bodyguard", 1992)
  - "item" = variable storing the tuple

Result:
- item = ("The Bodyguard", 1992)  (a tuple)
- album_releases now contains:
  {
      "Back in Black": 1980,
      "The Dark Side of the Moon": 1973
  }

Example 2: Unpacking popitem() Result
--------------------------------------
album_releases = {
    "Back in Black": 1980,
    "The Dark Side of the Moon": 1973
}

key, value = album_releases.popitem()

Line-by-line explanation:
- Lines 1-4: Creates dictionary
- Line 6: Pops item and unpacks the tuple
  - "popitem()" = returns ("The Dark Side of the Moon", 1973)
  - "key, value" = tuple unpacking
    - "key" = gets "The Dark Side of the Moon"
    - "value" = gets 1973
  - Both variables are assigned simultaneously

Result:
- key = "The Dark Side of the Moon"
- value = 1973
- album_releases now contains: {"Back in Black": 1980}

Example 3: Popping from Empty Dictionary
------------------------------------------
empty_dict = {}

# This will raise KeyError!
item = empty_dict.popitem()

Line-by-line explanation:
- Line 1: Creates empty dictionary
- Line 3: Attempts to pop from empty dictionary
  - Python finds no items to remove
  - Python raises KeyError: 'popitem(): dictionary is empty'

Error Message:
KeyError: 'popitem(): dictionary is empty'

Always check if the dictionary is not empty before using popitem(), or use it 
in a loop that checks for emptiness.

THE clear() METHOD
================================================================================

The clear() method removes all key-value pairs from the dictionary, making it 
empty. This is useful when you want to reset a dictionary without creating a 
new one.

Syntax:
dictionary_name.clear()

Breaking Down the Syntax:
- dictionary_name = The dictionary variable name
- . = Dot operator
- clear() = Method name (no arguments needed)

How It Works:
- Removes all key-value pairs from the dictionary
- Dictionary becomes empty: {}
- Dictionary object itself still exists (not deleted)

Example: Clearing a Dictionary
--------------------------------
album_releases = {
    "Back in Black": 1980,
    "The Dark Side of the Moon": 1973,
    "The Bodyguard": 1992
}

album_releases.clear()

Line-by-line explanation:
- Lines 1-5: Creates dictionary with three entries
- Line 7: Clears all entries
  - "album_releases" = dictionary name
  - "." = dot operator
  - "clear()" = method call (no arguments)
  - Python removes all key-value pairs
  - Dictionary becomes empty

Result: album_releases = {}

The dictionary is now empty, but the variable album_releases still exists and 
points to the same dictionary object (just empty now).

Visual Representation:
Before clear():
┌──────────────────────────────┬──────┐
│            KEY               │ VALUE│
├──────────────────────────────┼──────┤
│ "Back in Black"              │ 1980 │
│ "The Dark Side of the Moon"  │ 1973 │
│ "The Bodyguard"              │ 1992 │
└──────────────────────────────┴──────┘

After clear():
┌──────┬──────┐
│ KEY  │ VALUE│
├──────┼──────┤
│      │      │  ← Empty dictionary
└──────┴──────┘

================================================================================
SECTION 13: DICTIONARY COMPREHENSIONS
================================================================================

WHAT ARE DICTIONARY COMPREHENSIONS?
================================================================================

Dictionary comprehensions are a concise way to create dictionaries from 
iterables (like lists, tuples, or other dictionaries). They follow a similar 
syntax to list comprehensions but create dictionaries instead.

Basic Syntax:
{key_expression: value_expression for item in iterable}
{key_expression: value_expression for item in iterable if condition}

Breaking Down the Syntax:
- { } = Curly brackets (dictionary syntax)
- key_expression = Expression that generates the key
- : = Colon separating key from value
- value_expression = Expression that generates the value
- for item in iterable = Loop that iterates over items
- if condition = Optional filter condition

Example 1: Creating Dictionary from List
------------------------------------------
# Create dictionary from list of numbers
numbers = [1, 2, 3, 4, 5]
squared_dict = {num: num**2 for num in numbers}

Line-by-line explanation:
- Line 1: Creates list of numbers
- Line 2: Creates dictionary using comprehension
  - "{" = opening curly bracket (dictionary syntax)
  - "num" = variable from the loop (becomes the key)
  - ":" = separates key from value
  - "num**2" = expression that calculates square (becomes the value)
  - "for num in numbers" = loop over the list
  - "}" = closing curly bracket

How It Works:
- For each num in numbers:
  - num = 1 → key: 1, value: 1**2 = 1 → {1: 1}
  - num = 2 → key: 2, value: 2**2 = 4 → {2: 4}
  - num = 3 → key: 3, value: 3**2 = 9 → {3: 9}
  - num = 4 → key: 4, value: 4**2 = 16 → {4: 16}
  - num = 5 → key: 5, value: 5**2 = 25 → {5: 25}

Result: squared_dict = {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

Example 2: Creating Dictionary from List of Strings
-----------------------------------------------------
names = ["Alice", "Bob", "Charlie"]
name_lengths = {name: len(name) for name in names}

Line-by-line explanation:
- Line 1: Creates list of names
- Line 2: Creates dictionary mapping names to their lengths
  - "name" = each name from the list (becomes key)
  - "len(name)" = length of the name (becomes value)
  - "for name in names" = loop over names

How It Works:
- "Alice" → key: "Alice", value: len("Alice") = 5
- "Bob" → key: "Bob", value: len("Bob") = 3
- "Charlie" → key: "Charlie", value: len("Charlie") = 7

Result: name_lengths = {"Alice": 5, "Bob": 3, "Charlie": 7}

Example 3: Dictionary Comprehension with Condition
---------------------------------------------------
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_squared = {num: num**2 for num in numbers if num % 2 == 0}

Line-by-line explanation:
- Line 1: Creates list of numbers 1-10
- Line 2: Creates dictionary with condition
  - "num" = key (the number)
  - "num**2" = value (square of the number)
  - "for num in numbers" = loop over numbers
  - "if num % 2 == 0" = condition (only even numbers)
    - "num % 2" = remainder when dividing by 2
    - "== 0" = checks if remainder is 0 (even number)

How It Works:
- Only processes even numbers (2, 4, 6, 8, 10)
- 2 → {2: 4}
- 4 → {4: 16}
- 6 → {6: 36}
- 8 → {8: 64}
- 10 → {10: 100}

Result: even_squared = {2: 4, 4: 16, 6: 36, 8: 64, 10: 100}

Example 4: Transforming Existing Dictionary
----------------------------------------------
original = {"a": 1, "b": 2, "c": 3}
doubled = {key: value * 2 for key, value in original.items()}

Line-by-line explanation:
- Line 1: Creates original dictionary
- Line 2: Creates new dictionary with doubled values
  - "key, value" = unpacks each key-value pair from original.items()
  - "key" = keeps the same key
  - "value * 2" = doubles the value
  - "for key, value in original.items()" = iterates over all pairs

How It Works:
- ("a", 1) → key: "a", value: 1 * 2 = 2 → {"a": 2}
- ("b", 2) → key: "b", value: 2 * 2 = 4 → {"b": 4}
- ("c", 3) → key: "c", value: 3 * 2 = 6 → {"c": 6}

Result: doubled = {"a": 2, "b": 4, "c": 6}

Example 5: Swapping Keys and Values
------------------------------------
original = {"a": 1, "b": 2, "c": 3}
swapped = {value: key for key, value in original.items()}

Line-by-line explanation:
- Line 1: Creates original dictionary
- Line 2: Swaps keys and values
  - "value" = becomes the new key (was the old value)
  - "key" = becomes the new value (was the old key)
  - "for key, value in original.items()" = iterates over pairs

How It Works:
- ("a", 1) → new key: 1, new value: "a" → {1: "a"}
- ("b", 2) → new key: 2, new value: "b" → {2: "b"}
- ("c", 3) → new key: 3, new value: "c" → {3: "c"}

Result: swapped = {1: "a", 2: "b", 3: "c"}

Warning: This only works if all values are unique and immutable (can be used as 
keys). If values are duplicated, later entries will overwrite earlier ones.

================================================================================
SECTION 14: NESTED DICTIONARIES
================================================================================

WHAT ARE NESTED DICTIONARIES?
================================================================================

A nested dictionary is a dictionary that contains other dictionaries as values. 
This allows you to create complex, hierarchical data structures. Think of it like 
a tree structure where each level can contain more dictionaries.

Why Use Nested Dictionaries?
- Represent complex, hierarchical data
- Organize related information together
- Model real-world structures (like JSON data)
- Create multi-level lookups

Example 1: Simple Nested Dictionary
-------------------------------------
students = {
    "Alice": {
        "age": 20,
        "major": "Computer Science",
        "grades": [85, 90, 88]
    },
    "Bob": {
        "age": 22,
        "major": "Mathematics",
        "grades": [92, 87, 95]
    }
}

Line-by-line explanation:
- Line 1: Creates outer dictionary "students"
- Line 2: First key "Alice" with nested dictionary as value
  - "Alice": { ... } = key-value pair where value is another dictionary
  - Inner dictionary has keys: "age", "major", "grades"
- Line 7: Second key "Bob" with nested dictionary as value
  - Similar structure to Alice's dictionary

Visual Representation:
students = {
    "Alice" → {
        "age" → 20,
        "major" → "Computer Science",
        "grades" → [85, 90, 88]
    },
    "Bob" → {
        "age" → 22,
        "major" → "Mathematics",
        "grades" → [92, 87, 95]
    }
}

ACCESSING VALUES IN NESTED DICTIONARIES
================================================================================

To access values in nested dictionaries, you chain square bracket accesses 
together.

Syntax:
outer_dict[key1][key2]
outer_dict[key1][key2][key3]  # For deeper nesting

Example: Accessing Nested Values
---------------------------------
students = {
    "Alice": {
        "age": 20,
        "major": "Computer Science"
    }
}

# Access Alice's age
alice_age = students["Alice"]["age"]

Line-by-line explanation:
- Lines 1-6: Creates nested dictionary
- Line 8: Accesses nested value
  - "students" = outer dictionary
  - "[\"Alice\"]" = accesses the inner dictionary for Alice
    - Returns: {"age": 20, "major": "Computer Science"}
  - "[\"age\"]" = accesses "age" key in the inner dictionary
    - Returns: 20
  - "alice_age" = variable storing the result

Result: alice_age = 20

Step-by-Step Breakdown:
1. students["Alice"] → returns {"age": 20, "major": "Computer Science"}
2. {"age": 20, "major": "Computer Science"}["age"] → returns 20
3. Final result: 20

Example: Accessing Deeper Nested Values
-----------------------------------------
company = {
    "employees": {
        "Alice": {
            "department": {
                "name": "Engineering",
                "location": "Building A"
            }
        }
    }
}

dept_name = company["employees"]["Alice"]["department"]["name"]

Line-by-line explanation:
- Lines 1-10: Creates deeply nested dictionary
- Line 12: Accesses deeply nested value
  - "company" = outermost dictionary
  - "[\"employees\"]" = accesses "employees" key → returns inner dict
  - "[\"Alice\"]" = accesses "Alice" key → returns another inner dict
  - "[\"department\"]" = accesses "department" key → returns another inner dict
  - "[\"name\"]" = accesses "name" key → returns "Engineering"

Result: dept_name = "Engineering"

Step-by-Step Breakdown:
1. company["employees"] → {"Alice": {...}}
2. {"Alice": {...}}["Alice"] → {"department": {...}}
3. {"department": {...}}["department"] → {"name": "Engineering", "location": "Building A"}
4. {"name": "Engineering", ...}["name"] → "Engineering"

MODIFYING NESTED DICTIONARIES
================================================================================

You can modify nested dictionaries using the same chained bracket syntax.

Example: Modifying Nested Values
----------------------------------
students = {
    "Alice": {
        "age": 20,
        "major": "Computer Science"
    }
}

# Modify Alice's age
students["Alice"]["age"] = 21

Line-by-line explanation:
- Lines 1-6: Creates nested dictionary
- Line 8: Modifies nested value
  - "students[\"Alice\"]" = accesses Alice's dictionary
  - "[\"age\"]" = accesses the "age" key
  - "= 21" = assigns new value

Result: students["Alice"]["age"] is now 21 (changed from 20)

Example: Adding New Keys to Nested Dictionary
-----------------------------------------------
students = {
    "Alice": {
        "age": 20
    }
}

# Add new key to Alice's nested dictionary
students["Alice"]["major"] = "Computer Science"

Line-by-line explanation:
- Lines 1-4: Creates nested dictionary with one key in inner dict
- Line 6: Adds new key-value pair to nested dictionary
  - Accesses Alice's dictionary
  - Adds "major": "Computer Science" to it

Result: students["Alice"] now contains:
{
    "age": 20,
    "major": "Computer Science"  ← Added
}

Example: Adding Entire New Nested Dictionary
----------------------------------------------
students = {
    "Alice": {"age": 20}
}

# Add a new student with nested dictionary
students["Bob"] = {"age": 22, "major": "Mathematics"}

Line-by-line explanation:
- Lines 1-3: Creates dictionary with one student
- Line 5: Adds new key-value pair where value is a nested dictionary
  - "students[\"Bob\"]" = new key in outer dictionary
  - "= {...}" = assigns a nested dictionary as the value

Result: students now contains:
{
    "Alice": {"age": 20},
    "Bob": {"age": 22, "major": "Mathematics"}  ← Added
}

ITERATING OVER NESTED DICTIONARIES
================================================================================

Iterating over nested dictionaries requires nested loops or careful key access.

Example: Iterating Over Outer and Inner Dictionaries
------------------------------------------------------
students = {
    "Alice": {
        "age": 20,
        "major": "Computer Science"
    },
    "Bob": {
        "age": 22,
        "major": "Mathematics"
    }
}

for student_name, student_info in students.items():
    print(f"Student: {student_name}")
    for key, value in student_info.items():
        print(f"  {key}: {value}")
    print()  # Empty line for readability

Line-by-line explanation:
- Lines 1-10: Creates nested dictionary
- Line 12: Outer loop iterates over students
  - "student_name" = gets the key (e.g., "Alice")
  - "student_info" = gets the nested dictionary (e.g., {"age": 20, ...})
  - "students.items()" = gets all key-value pairs
- Line 13: Prints student name
- Line 14: Inner loop iterates over nested dictionary
  - "key" = gets key from nested dict (e.g., "age")
  - "value" = gets value from nested dict (e.g., 20)
  - "student_info.items()" = gets pairs from nested dictionary
- Line 15: Prints each key-value pair with indentation
- Line 16: Prints empty line for spacing

Result: Prints:
Student: Alice
  age: 20
  major: Computer Science

Student: Bob
  age: 22
  major: Mathematics

================================================================================
SECTION 15: COPYING DICTIONARIES
================================================================================

SHALLOW COPY VS DEEP COPY
================================================================================

When you assign one dictionary to another variable, both variables reference 
the same dictionary object. To create an independent copy, you need to use 
copying methods.

Shallow Copy:
- Creates a new dictionary object
- Copies the key-value pairs
- If values are mutable objects (like lists or dictionaries), both copies 
  reference the same mutable objects

Deep Copy:
- Creates a completely independent copy
- Recursively copies all nested objects
- No shared references between original and copy

Example 1: Reference Assignment (Not a Copy)
---------------------------------------------
original = {"a": 1, "b": 2}
reference = original

# Modify through reference
reference["a"] = 100

print(original)  # Also changed!

Line-by-line explanation:
- Line 1: Creates dictionary
- Line 2: Assigns reference (not a copy)
  - Both variables point to the same dictionary object
- Line 4: Modifies through reference variable
- Line 6: Prints original dictionary

Result: Both original and reference show {"a": 100, "b": 2}

The original dictionary was modified because both variables reference the same 
object.

Example 2: Shallow Copy Using copy() Method
---------------------------------------------
original = {"a": 1, "b": 2}
shallow_copy = original.copy()

# Modify the copy
shallow_copy["a"] = 100

print(original)    # Not changed: {"a": 1, "b": 2}
print(shallow_copy)  # Changed: {"a": 100, "b": 2}

Line-by-line explanation:
- Line 1: Creates original dictionary
- Line 2: Creates shallow copy
  - "original.copy()" = creates a new dictionary with copied key-value pairs
  - "shallow_copy" = new variable pointing to the new dictionary
- Line 4: Modifies the copy
- Line 6: Prints original (unchanged)
- Line 7: Prints copy (changed)

Result:
- original = {"a": 1, "b": 2} (unchanged)
- shallow_copy = {"a": 100, "b": 2} (changed)

The original dictionary remains unchanged because shallow_copy is a separate 
object.

Example 3: Shallow Copy Limitation with Nested Objects
--------------------------------------------------------
original = {"a": [1, 2, 3], "b": 2}
shallow_copy = original.copy()

# Modify nested list in copy
shallow_copy["a"].append(4)

print(original)    # Also changed! {"a": [1, 2, 3, 4], "b": 2}
print(shallow_copy)  # Changed: {"a": [1, 2, 3, 4], "b": 2}

Line-by-line explanation:
- Line 1: Creates dictionary with list as value
- Line 2: Creates shallow copy
  - The dictionary is copied, but the list object is not
  - Both dictionaries reference the same list object
- Line 4: Modifies list through copy
  - "shallow_copy[\"a\"]" = accesses the list (same object as original)
  - ".append(4)" = adds 4 to the list
- Line 6: Prints original (list was modified!)
- Line 7: Prints copy (list was modified)

Result: Both dictionaries show the modified list because they share the same 
list object.

This is the limitation of shallow copy: nested mutable objects are not copied, 
only referenced.

Example 4: Deep Copy Using copy Module
----------------------------------------
import copy

original = {"a": [1, 2, 3], "b": 2}
deep_copy = copy.deepcopy(original)

# Modify nested list in copy
deep_copy["a"].append(4)

print(original)    # Not changed: {"a": [1, 2, 3], "b": 2}
print(deep_copy)   # Changed: {"a": [1, 2, 3, 4], "b": 2}

Line-by-line explanation:
- Line 1: Imports copy module (provides deepcopy function)
- Line 3: Creates dictionary with list as value
- Line 4: Creates deep copy
  - "copy.deepcopy(original)" = recursively copies everything
  - Creates completely independent copy, including nested objects
- Line 6: Modifies list in copy
- Line 8: Prints original (unchanged!)
- Line 9: Prints copy (changed)

Result:
- original = {"a": [1, 2, 3], "b": 2} (unchanged)
- deep_copy = {"a": [1, 2, 3, 4], "b": 2} (changed)

The original dictionary remains unchanged because deep_copy is completely 
independent, including the nested list.

When to Use Each:
- Shallow copy: When values are immutable (strings, numbers, tuples)
- Deep copy: When values are mutable (lists, dictionaries, sets) and you need 
  complete independence

================================================================================
SECTION 16: DICTIONARY VIEWS AND THEIR BEHAVIOR
================================================================================

UNDERSTANDING VIEW OBJECTS
================================================================================

When you call .keys(), .values(), or .items(), Python returns "view objects" 
rather than lists. These views are dynamic - they reflect changes to the 
dictionary in real-time.

Key Characteristics of Views:
1. Dynamic: Automatically reflect dictionary changes
2. Memory Efficient: Don't create copies of data
3. Iterable: Can be used in loops and converted to lists
4. Set-like Operations: Support some set operations (for keys() and items())

Example: Dynamic View Behavior
-------------------------------
album_releases = {
    "Back in Black": 1980,
    "The Dark Side of the Moon": 1973
}

keys_view = album_releases.keys()
print(list(keys_view))  # ['Back in Black', 'The Dark Side of the Moon']

# Add a new entry
album_releases["The Bodyguard"] = 1992

# View automatically reflects the change
print(list(keys_view))  # ['Back in Black', 'The Dark Side of the Moon', 'The Bodyguard']

Line-by-line explanation:
- Lines 1-4: Creates dictionary
- Line 6: Gets keys view
  - "keys_view" = stores the view object (not a list!)
- Line 7: Converts view to list and prints
  - Shows initial keys
- Line 9: Adds new entry to dictionary
- Line 11: Converts view to list again and prints
  - View automatically shows the new key!

The view object is "live" - it always reflects the current state of the 
dictionary.

SET-LIKE OPERATIONS ON VIEWS
================================================================================

The keys() and items() views support set-like operations because keys are 
unique and items (as tuples) can be treated as sets.

Example: Set Operations on keys() View
----------------------------------------
dict1 = {"a": 1, "b": 2, "c": 3}
dict2 = {"b": 2, "c": 3, "d": 4}

keys1 = dict1.keys()
keys2 = dict2.keys()

# Find common keys
common = keys1 & keys2  # Intersection
print(common)  # {'b', 'c'}

# Find all keys
all_keys = keys1 | keys2  # Union
print(all_keys)  # {'a', 'b', 'c', 'd'}

# Find keys only in dict1
only_in_dict1 = keys1 - keys2  # Difference
print(only_in_dict1)  # {'a'}

Line-by-line explanation:
- Lines 1-2: Creates two dictionaries
- Lines 4-5: Gets keys views
- Line 7: Finds intersection (common keys)
  - "keys1 & keys2" = set intersection operator
  - Returns keys that exist in both dictionaries
- Line 10: Finds union (all keys)
  - "keys1 | keys2" = set union operator
  - Returns all unique keys from both dictionaries
- Line 13: Finds difference (keys only in first)
  - "keys1 - keys2" = set difference operator
  - Returns keys in keys1 but not in keys2

These operations are useful for comparing dictionaries and finding relationships 
between their keys.

================================================================================
SECTION 17: BEST PRACTICES AND COMMON PATTERNS
================================================================================

BEST PRACTICES FOR WORKING WITH DICTIONARIES
================================================================================

1. Use Meaningful Key Names
----------------------------
Good: student_info = {"name": "Alice", "age": 20}
Bad: student_info = {"n": "Alice", "a": 20}

Meaningful keys make code readable and maintainable.

2. Use get() for Safe Access
-----------------------------
Good: value = my_dict.get("key", "default")
Bad: value = my_dict["key"]  # May raise KeyError

Using get() prevents crashes when keys might not exist.

3. Check Key Existence Before Accessing
----------------------------------------
Good:
if "key" in my_dict:
    value = my_dict["key"]

Bad:
value = my_dict["key"]  # May raise KeyError

4. Use Dictionary Comprehensions for Transformations
-----------------------------------------------------
Good: squared = {k: v**2 for k, v in original.items()}
Bad: 
squared = {}
for k, v in original.items():
    squared[k] = v**2

Comprehensions are more Pythonic and often more readable.

5. Use items() for Iteration
-----------------------------
Good: for key, value in my_dict.items():
Bad: for key in my_dict:
         value = my_dict[key]  # Extra lookup

Using items() is more efficient and cleaner.

COMMON PATTERNS
================================================================================

Pattern 1: Counting Occurrences
---------------------------------
# Count occurrences of items in a list
items = ["apple", "banana", "apple", "orange", "banana", "apple"]
counts = {}

for item in items:
    counts[item] = counts.get(item, 0) + 1

# Result: {"apple": 3, "banana": 2, "orange": 1}

Line-by-line explanation:
- Line 1: Creates list with duplicates
- Line 2: Creates empty dictionary for counts
- Line 4: Iterates over items
- Line 5: Increments count for each item
  - "counts.get(item, 0)" = gets current count (or 0 if first time)
  - "+ 1" = increments the count
  - "counts[item] = ..." = stores updated count

Pattern 2: Grouping Data
--------------------------
# Group students by major
students = [
    {"name": "Alice", "major": "CS"},
    {"name": "Bob", "major": "Math"},
    {"name": "Charlie", "major": "CS"}
]

grouped = {}
for student in students:
    major = student["major"]
    if major not in grouped:
        grouped[major] = []
    grouped[major].append(student["name"])

# Result: {"CS": ["Alice", "Charlie"], "Math": ["Bob"]}

Line-by-line explanation:
- Lines 1-5: Creates list of student dictionaries
- Line 7: Creates empty dictionary for grouping
- Line 8: Iterates over students
- Line 9: Gets student's major
- Line 10: Checks if major key exists
- Line 11: Creates empty list if major doesn't exist
- Line 12: Adds student name to the list for that major

Pattern 3: Default Dictionary Values
--------------------------------------
# Initialize dictionary with default values
defaults = {"a": 0, "b": 0, "c": 0}

# Or use dict.fromkeys()
defaults = dict.fromkeys(["a", "b", "c"], 0)

# Result: {"a": 0, "b": 0, "c": 0}

Line-by-line explanation:
- Line 1: Manual initialization
- Line 4: Using fromkeys() method
  - "dict.fromkeys(keys, value)" = creates dictionary with specified keys
  - All keys get the same default value

================================================================================
SECTION 18: SUMMARY AND KEY TAKEAWAYS
================================================================================

ESSENTIAL DICTIONARY CONCEPTS
================================================================================

1. Structure: Dictionaries store key-value pairs
   - Keys must be immutable and unique
   - Values can be any type and can be duplicated

2. Creation: Use curly brackets {}
   - {key: value, key: value}
   - Empty: {} or dict()

3. Access: Use square brackets with key
   - dictionary[key] → returns value
   - Use get() for safe access with defaults

4. Modification: Assign to add or update
   - dictionary[key] = value

5. Deletion: Use del statement or pop() method
   - del dictionary[key]
   - value = dictionary.pop(key, default)

6. Checking: Use "in" operator
   - key in dictionary → True/False

7. Iteration: Multiple methods available
   - for key in dictionary (iterates over keys)
   - for value in dictionary.values() (iterates over values)
   - for key, value in dictionary.items() (iterates over pairs)

8. Methods: Many useful methods available
   - keys(), values(), items() → get views
   - get(), update(), pop(), popitem(), clear()

9. Advanced: Comprehensions, nesting, copying
   - Dictionary comprehensions for creating dictionaries
   - Nested dictionaries for hierarchical data
   - Shallow vs deep copying

WHEN TO USE DICTIONARIES
================================================================================

Use dictionaries when:
- You need to map relationships between data
- You want fast lookups by meaningful keys (not just integer indexes)
- You're working with key-value data structures
- You need to represent structured, labeled data
- You're processing JSON-like data
- You need to count or group items

Dictionaries are one of Python's most powerful and versatile data structures. 
Mastering them will significantly improve your Python programming skills!

================================================================================
END OF COMPREHENSIVE DICTIONARY STUDY GUIDE
================================================================================

Congratulations! You have completed the comprehensive study guide on dictionaries 
in Python. You now understand:

✓ Dictionary structure and key-value pairs
✓ Creating and accessing dictionaries
✓ Adding, modifying, and deleting entries
✓ Checking for key existence
✓ Dictionary methods (keys, values, items, get, update, pop, etc.)
✓ Iterating over dictionaries
✓ Dictionary comprehensions
✓ Nested dictionaries
✓ Copying dictionaries (shallow vs deep)
✓ Dictionary views and their behavior
✓ Best practices and common patterns

Practice using dictionaries in your own code to reinforce these concepts. 
Dictionaries are essential for Python programming, and the more you use them, 
the more natural they will become!

Happy coding!
