================================================================================
EXPRESS BEST PRACTICES
Comprehensive Study Guide - Part 2
================================================================================

WELCOME TO PART 2
-----------------
This part continues from Part 1 and covers:
• RESTful API best practices
• HTTP status codes
• Black-box testing with SuperTest
• JWT-based stateless authentication
• API documentation
• Additional Express best practices
• NPM usage guidelines
• Capitalization conventions

================================================================================
TABLE OF CONTENTS - PART 2
================================================================================

PART 2: BEST PRACTICES FOR RESTFUL APIS
  SECTION 2.1: API ROUTE NAMING CONVENTIONS
  SECTION 2.2: HTTP STATUS CODES
  SECTION 2.3: BLACK-BOX TESTING WITH SUPERTEST
  SECTION 2.4: JWT-BASED STATELESS AUTHENTICATION
  SECTION 2.5: API DOCUMENTATION

PART 3: ADDITIONAL EXPRESS BEST PRACTICES
  SECTION 3.1: NPM USAGE GUIDELINES
  SECTION 3.2: CAPITALIZATION CONVENTIONS
  SECTION 3.3: CONFIGURATION FILE BEST PRACTICES
  SECTION 3.4: ROUTE ORGANIZATION BEST PRACTICES

PART 4: SUMMARY AND KEY TAKEAWAYS
  SECTION 4.1: FOLDER STRUCTURE SUMMARY
  SECTION 4.2: API BEST PRACTICES SUMMARY
  SECTION 4.3: QUICK REFERENCE GUIDE

================================================================================
PART 2: BEST PRACTICES FOR RESTFUL APIS
================================================================================

SECTION 2.1: API ROUTE NAMING CONVENTIONS
------------------------------------------

OVERVIEW
--------
When naming an API route, be sure to use a noun as a resource identifier. 
This table provides examples of HTTP routes for post, get, patch, and delete 
using the word employee in the route. These routes are examples if you are 
writing HTTP methods and API routes to modify employee data.

THE FUNDAMENTAL RULE
--------------------
USE NOUNS, NOT VERBS

CORRECT:
  GET    /employees        # Get all employees
  GET    /employees/:id   # Get one employee
  POST   /employees       # Create new employee
  PATCH  /employees/:id   # Update employee
  DELETE /employees/:id  # Delete employee

INCORRECT:
  GET    /getEmployees         # ❌ Verb in URL
  POST   /createEmployee       # ❌ Verb in URL
  POST   /employees/create     # ❌ Verb in URL
  GET    /employees/:id/delete # ❌ Verb in URL

WHY USE NOUNS?
--------------
1. RESTFUL PRINCIPLES
   • REST (Representational State Transfer) uses nouns for resources
   • HTTP methods (GET, POST, etc.) already indicate the action
   • URLs should represent resources, not actions

2. CONSISTENCY
   • All routes follow the same pattern
   • Easy to predict route names
   • Clear and intuitive

3. STANDARD PRACTICE
   • Industry-standard approach
   • Other developers understand it immediately
   • Works well with REST clients and tools

COMPLETE ROUTE TABLE FOR EMPLOYEE RESOURCE
-------------------------------------------
This table provides examples of HTTP routes for post, get, patch, and delete 
using the word employee in the route:

  HTTP Method | Route              | Description
  ------------|-------------------|------------------------------------------
  GET         | /employees        | Get all employees
  GET         | /employees/:id    | Get a specific employee by ID
  POST        | /employees        | Create a new employee
  PATCH       | /employees/:id    | Update an existing employee (partial)
  PUT         | /employees/:id   | Replace an entire employee
  DELETE      | /employees/:id    | Delete an employee

DETAILED EXPLANATION OF EACH ROUTE
-----------------------------------

ROUTE 1: GET /employees
------------------------
PURPOSE:
Get all employees (list all employees)

EXAMPLE REQUEST:
  GET /employees
  Headers: Content-Type: application/json

EXAMPLE RESPONSE:
  [
    { "id": 1, "name": "John Doe", "email": "john@example.com" },
    { "id": 2, "name": "Jane Smith", "email": "jane@example.com" }
  ]

CODE EXAMPLE:
  // routes/employees.js
  router.get('/', async (req, res) => {
    try {
      const employees = await Employee.find();
      res.json(employees);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: router.get('/', async (req, res) => {
         • Defines GET route at root path
         • When mounted at /employees, becomes GET /employees
         • async - Allows await for database operations

Line 2: try {
         • Starts error handling block

Line 3: const employees = await Employee.find();
         • Finds all employees in database
         • Employee.find() - Mongoose method (no filter = all documents)
         • await - Waits for database query
         • employees - Array of employee documents

Line 4: res.json(employees);
         • Sends JSON response with employees array
         • Sets Content-Type: application/json header
         • Converts JavaScript array to JSON string

Line 5: } catch (error) {
         • Catches any errors

Line 6: res.status(500).json({ error: error.message });
         • Sends 500 error if something goes wrong
         • 500 - Internal Server Error
         • Includes error message in response

ROUTE 2: GET /employees/:id
----------------------------
PURPOSE:
Get a specific employee by their ID

EXAMPLE REQUEST:
  GET /employees/123
  Headers: Content-Type: application/json

EXAMPLE RESPONSE:
  { "id": 123, "name": "John Doe", "email": "john@example.com" }

CODE EXAMPLE:
  router.get('/:id', async (req, res) => {
    try {
      const employee = await Employee.findById(req.params.id);
      if (!employee) {
        return res.status(404).json({ error: 'Employee not found' });
      }
      res.json(employee);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: router.get('/:id', async (req, res) => {
         • GET route with id parameter
         • :id - Route parameter (dynamic value)
         • Example: /employees/123 → req.params.id = '123'

Line 2: try {
         • Error handling

Line 3: const employee = await Employee.findById(req.params.id);
         • Finds employee by ID
         • Employee.findById() - Mongoose method to find by ID
         • req.params.id - Gets id from URL
         • Returns null if not found

Line 4: if (!employee) {
         • Checks if employee exists
         • !employee - If employee is null/undefined

Line 5: return res.status(404).json({ error: 'Employee not found' });
         • Returns 404 if employee not found
         • 404 - Not Found status code
         • return - Exits function early
         • Sends error message

Line 6: }
         • Closes if statement

Line 7: res.json(employee);
         • Sends employee data if found

Line 8: } catch (error) {
         • Catches database/other errors

Line 9: res.status(500).json({ error: error.message });
         • Sends 500 error

ROUTE 3: POST /employees
------------------------
PURPOSE:
Create a new employee

EXAMPLE REQUEST:
  POST /employees
  Headers: Content-Type: application/json
  Body: {
    "name": "John Doe",
    "email": "john@example.com",
    "position": "Developer"
  }

EXAMPLE RESPONSE:
  {
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com",
    "position": "Developer",
    "createdAt": "2024-01-15T10:30:00Z"
  }

CODE EXAMPLE:
  router.post('/', async (req, res) => {
    try {
      const employee = new Employee(req.body);
      await employee.save();
      res.status(201).json(employee);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: router.post('/', async (req, res) => {
         • POST route to create resource
         • POST - HTTP method for creating resources
         • '/' - Same path as GET all, different method

Line 2: try {
         • Error handling

Line 3: const employee = new Employee(req.body);
         • Creates new employee instance
         • new Employee() - Creates new document
         • req.body - Request body (JSON data from client)
         • Example: { name: "John", email: "john@example.com" }

Line 4: await employee.save();
         • Saves employee to database
         • employee.save() - Mongoose method to persist document
         • Validates data before saving
         • Throws error if validation fails

Line 5: res.status(201).json(employee);
         • Sends success response
         • 201 - Created status code (successful creation)
         • Sends created employee back to client

Line 6: } catch (error) {
         • Catches validation/save errors

Line 7: res.status(400).json({ error: error.message });
         • Sends bad request error
         • 400 - Bad Request (invalid data from client)
         • Usually validation errors

ROUTE 4: PATCH /employees/:id
-----------------------------
PURPOSE:
Update an existing employee (partial update - only specified fields)

EXAMPLE REQUEST:
  PATCH /employees/123
  Headers: Content-Type: application/json
  Body: {
    "position": "Senior Developer"
  }

EXAMPLE RESPONSE:
  {
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com",
    "position": "Senior Developer",  // Updated
    "updatedAt": "2024-01-15T11:00:00Z"
  }

CODE EXAMPLE:
  router.patch('/:id', async (req, res) => {
    try {
      const employee = await Employee.findByIdAndUpdate(
        req.params.id,
        req.body,
        { new: true, runValidators: true }
      );
      if (!employee) {
        return res.status(404).json({ error: 'Employee not found' });
      }
      res.json(employee);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: router.patch('/:id', async (req, res) => {
         • PATCH route for partial updates
         • PATCH - HTTP method for partial updates
         • :id - Employee ID to update

Line 2: try {
         • Error handling

Line 3-6: const employee = await Employee.findByIdAndUpdate(
           req.params.id,
           req.body,
           { new: true, runValidators: true }
         );
         • Finds and updates employee
         • findByIdAndUpdate() - Mongoose method
         • req.params.id - ID of employee to update
         • req.body - Fields to update (only specified fields)
         • { new: true } - Returns updated document (not old one)
         • { runValidators: true } - Runs validation on update

Line 7: if (!employee) {
         • Checks if employee was found

Line 8: return res.status(404).json({ error: 'Employee not found' });
         • Returns 404 if employee doesn't exist

Line 9: }
         • Closes if

Line 10: res.json(employee);
          • Sends updated employee

Line 11: } catch (error) {
          • Catches errors

Line 12: res.status(400).json({ error: error.message });
          • Sends 400 for validation errors

PATCH VS PUT:
-------------
PATCH - Partial update (only update specified fields)
  PATCH /employees/123
  Body: { "position": "Senior Developer" }
  // Only position is updated, other fields unchanged

PUT - Full replacement (replace entire resource)
  PUT /employees/123
  Body: { "name": "John", "email": "john@example.com", "position": "Senior" }
  // Entire employee replaced, missing fields may be lost

ROUTE 5: DELETE /employees/:id
-------------------------------
PURPOSE:
Delete an employee

EXAMPLE REQUEST:
  DELETE /employees/123
  Headers: Content-Type: application/json

EXAMPLE RESPONSE:
  204 No Content
  (or)
  { "message": "Employee deleted successfully" }

CODE EXAMPLE:
  router.delete('/:id', async (req, res) => {
    try {
      const employee = await Employee.findByIdAndDelete(req.params.id);
      if (!employee) {
        return res.status(404).json({ error: 'Employee not found' });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: router.delete('/:id', async (req, res) => {
         • DELETE route to remove resource
         • DELETE - HTTP method for deletion
         • :id - ID of employee to delete

Line 2: try {
         • Error handling

Line 3: const employee = await Employee.findByIdAndDelete(req.params.id);
         • Finds and deletes employee
         • findByIdAndDelete() - Mongoose method
         • Returns deleted document if found, null if not found

Line 4: if (!employee) {
         • Checks if employee existed

Line 5: return res.status(404).json({ error: 'Employee not found' });
         • Returns 404 if employee doesn't exist

Line 6: }
         • Closes if

Line 7: res.status(204).send();
         • Sends 204 No Content response
         • 204 - Success but no content to return
         • .send() - Sends empty response body
         • Standard for successful deletions

Line 8: } catch (error) {
         • Catches errors

Line 9: res.status(500).json({ error: error.message });
         • Sends 500 for server errors

BEST PRACTICES FOR ROUTE NAMING
--------------------------------
1. USE PLURAL NOUNS
   ✅ /employees (not /employee)
   ✅ /products (not /product)
   ✅ /users (not /user)

2. USE CONSISTENT NAMING
   ✅ /employees/:id/comments (nested resources)
   ✅ /employees/:id/department (relationships)
   ❌ /employees/:id/getComments (verb in URL)

3. USE HYPHENS FOR MULTI-WORD RESOURCES
   ✅ /user-profiles
   ✅ /order-items
   ❌ /user_profiles (underscores)
   ❌ /userProfiles (camelCase)

4. KEEP URLS SHORT AND DESCRIPTIVE
   ✅ /employees/:id
   ❌ /company/employees/by/id/:id

[END SECTION 2.1]
================================================================================

SECTION 2.2: HTTP STATUS CODES
-------------------------------

OVERVIEW
--------
Be sure to use HTTP status codes correctly. A 200s code means everything is ok, 
a 300s code means the resource has been moved, a code in the 400s means there 
has been a client-side error, and a number in the 500s means something went wrong 
on the side of the API.

WHAT ARE HTTP STATUS CODES?
---------------------------
HTTP status codes are three-digit numbers returned by servers to indicate the 
result of a request. They tell the client whether the request was successful, 
failed, or needs further action.

STATUS CODE CATEGORIES
----------------------

CATEGORY 1: 200s (SUCCESS)
---------------------------
A 200s code means everything is ok.

COMMON 200s STATUS CODES:
• 200 OK - Request succeeded
• 201 Created - Resource created successfully
• 204 No Content - Success but no content to return

EXAMPLE USAGE:
  // 200 OK - Successful GET request
  router.get('/employees', async (req, res) => {
    const employees = await Employee.find();
    res.status(200).json(employees);  // 200 is default, can omit
  });

  // 201 Created - Successful POST request
  router.post('/employees', async (req, res) => {
    const employee = new Employee(req.body);
    await employee.save();
    res.status(201).json(employee);  // Must specify 201
  });

  // 204 No Content - Successful DELETE
  router.delete('/employees/:id', async (req, res) => {
    await Employee.findByIdAndDelete(req.params.id);
    res.status(204).send();  // No response body
  });

DETAILED EXPLANATION:
---------------------
200 OK:
• Standard success response
• Used for GET, PUT, PATCH requests
• Response body contains requested data
• Default status if not specified

201 Created:
• Resource successfully created
• Used for POST requests
• Should include Location header with new resource URL
• Response body typically contains created resource

204 No Content:
• Success but no content to return
• Used for DELETE requests
• Response body should be empty
• Client doesn't need to parse response

CATEGORY 2: 300s (REDIRECTION)
-------------------------------
A 300s code means the resource has been moved.

COMMON 300s STATUS CODES:
• 301 Moved Permanently - Resource permanently moved
• 302 Found - Temporary redirect
• 304 Not Modified - Resource not modified (caching)

EXAMPLE USAGE:
  // 301 Permanent Redirect
  router.get('/old-path', (req, res) => {
    res.redirect(301, '/new-path');
  });

  // 302 Temporary Redirect
  router.get('/temp', (req, res) => {
    res.redirect(302, '/other-path');
  });

DETAILED EXPLANATION:
---------------------
301 Moved Permanently:
• Resource permanently moved to new location
• Search engines update their indexes
• Browsers may cache the redirect
• Use when URL structure changes permanently

302 Found (Temporary Redirect):
• Resource temporarily available at different location
• Search engines don't update indexes
• Browsers don't cache as aggressively
• Use for temporary moves or maintenance

304 Not Modified:
• Resource hasn't changed since last request
• Used with caching (If-Modified-Since header)
• Server doesn't send body, saves bandwidth
• Client uses cached version

CATEGORY 3: 400s (CLIENT ERRORS)
--------------------------------
A code in the 400s means there has been a client-side error.

COMMON 400s STATUS CODES:
• 400 Bad Request - Invalid request syntax
• 401 Unauthorized - Authentication required
• 403 Forbidden - Server understood but refuses
• 404 Not Found - Resource doesn't exist
• 409 Conflict - Request conflicts with current state
• 422 Unprocessable Entity - Validation errors

EXAMPLE USAGE:
  // 400 Bad Request - Invalid data
  router.post('/employees', async (req, res) => {
    try {
      const employee = new Employee(req.body);
      await employee.save();
      res.status(201).json(employee);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  });

  // 401 Unauthorized - Not authenticated
  router.get('/profile', authenticateToken, (req, res) => {
    // authenticateToken middleware checks for valid token
    // If no token, returns 401
    res.json(req.user);
  });

  // 403 Forbidden - Authenticated but not authorized
  router.delete('/employees/:id', authenticateToken, checkAdmin, (req, res) => {
    // checkAdmin middleware verifies user is admin
    // If not admin, returns 403
    await Employee.findByIdAndDelete(req.params.id);
    res.status(204).send();
  });

  // 404 Not Found - Resource doesn't exist
  router.get('/employees/:id', async (req, res) => {
    const employee = await Employee.findById(req.params.id);
    if (!employee) {
      return res.status(404).json({ error: 'Employee not found' });
    }
    res.json(employee);
  });

  // 409 Conflict - Resource conflict
  router.post('/employees', async (req, res) => {
    const existing = await Employee.findOne({ email: req.body.email });
    if (existing) {
      return res.status(409).json({ error: 'Email already exists' });
    }
    const employee = new Employee(req.body);
    await employee.save();
    res.status(201).json(employee);
  });

  // 422 Unprocessable Entity - Validation errors
  router.post('/employees', validateEmployee, async (req, res) => {
    // validateEmployee middleware checks data
    // If validation fails, returns 422 with error details
    const employee = new Employee(req.body);
    await employee.save();
    res.status(201).json(employee);
  });

DETAILED EXPLANATION:
---------------------
400 Bad Request:
• Client sent invalid request syntax
• Server cannot process request
• Usually validation errors or malformed JSON
• Client should fix request before retrying

401 Unauthorized:
• Authentication required but not provided
• Invalid or missing authentication token
• Client needs to authenticate first
• Response should include WWW-Authenticate header

403 Forbidden:
• Server understood request but refuses to fulfill it
• User is authenticated but lacks permission
• Different from 401 (not authenticated vs not authorized)
• Client shouldn't retry with same credentials

404 Not Found:
• Requested resource doesn't exist
• URL might be incorrect
• Resource may have been deleted
• Most common error in APIs

409 Conflict:
• Request conflicts with current state
• Example: Creating resource that already exists
• Usually requires client action to resolve
• Common for duplicate email/username

422 Unprocessable Entity:
• Request is well-formed but semantically incorrect
• Validation errors
• More specific than 400
• Response should include error details

CATEGORY 4: 500s (SERVER ERRORS)
--------------------------------
A number in the 500s means something went wrong on the side of the API.

COMMON 500s STATUS CODES:
• 500 Internal Server Error - Generic server error
• 502 Bad Gateway - Invalid response from upstream server
• 503 Service Unavailable - Server temporarily unavailable
• 504 Gateway Timeout - Upstream server timeout

EXAMPLE USAGE:
  // 500 Internal Server Error - Generic error handler
  app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ 
      error: 'Internal server error',
      message: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  });

  // 503 Service Unavailable - Maintenance mode
  app.use((req, res, next) => {
    if (process.env.MAINTENANCE_MODE === 'true') {
      return res.status(503).json({ 
        error: 'Service temporarily unavailable',
        retryAfter: 3600  // Retry after 1 hour
      });
    }
    next();
  });

DETAILED EXPLANATION:
---------------------
500 Internal Server Error:
• Generic server error
• Something went wrong on server
• Client shouldn't retry immediately
• Server should log error for debugging

502 Bad Gateway:
• Server acting as gateway received invalid response
• Upstream server returned invalid response
• Usually infrastructure issue
• Client can retry later

503 Service Unavailable:
• Server temporarily unavailable
• Overloaded or under maintenance
• Client can retry after delay
• Should include Retry-After header

504 Gateway Timeout:
• Server acting as gateway didn't receive timely response
• Upstream server took too long
• Timeout occurred
• Client can retry

COMPLETE STATUS CODE REFERENCE TABLE
------------------------------------
  Code | Category        | Meaning                          | Common Use Cases
  -----|-----------------|----------------------------------|------------------
  200  | Success         | OK                               | GET, PUT, PATCH success
  201  | Success         | Created                          | POST success
  204  | Success         | No Content                       | DELETE success
  301  | Redirection     | Moved Permanently                | Permanent URL change
  302  | Redirection     | Found                            | Temporary redirect
  304  | Redirection     | Not Modified                      | Caching
  400  | Client Error    | Bad Request                      | Invalid request syntax
  401  | Client Error    | Unauthorized                     | Missing/invalid auth
  403  | Client Error    | Forbidden                        | Insufficient permissions
  404  | Client Error    | Not Found                        | Resource doesn't exist
  409  | Client Error    | Conflict                         | Resource conflict
  422  | Client Error    | Unprocessable Entity             | Validation errors
  500  | Server Error    | Internal Server Error            | Generic server error
  502  | Server Error    | Bad Gateway                      | Invalid upstream response
  503  | Server Error    | Service Unavailable              | Server overloaded/maintenance
  504  | Server Error    | Gateway Timeout                  | Upstream timeout

BEST PRACTICES FOR STATUS CODES
--------------------------------
1. BE CONSISTENT
   • Use same status codes for same situations
   • Document which codes your API returns
   • Follow REST conventions

2. BE SPECIFIC
   • Use most specific code possible
   • 404 for not found, not 400
   • 422 for validation errors, not 400

3. INCLUDE ERROR DETAILS
   • Provide helpful error messages
   • Include field-level validation errors
   • Help clients fix their requests

4. LOG SERVER ERRORS
   • Always log 500 errors
   • Include stack traces in logs
   • Don't expose internals to clients

[END SECTION 2.2]
================================================================================

SECTION 2.3: BLACK-BOX TESTING WITH SUPERTEST
----------------------------------------------

OVERVIEW
--------
Another best practice is to black-box test your node.js REST APIs. Black-box 
testing means you test the code without looking at its internal structure. 
The system is tested as a whole without mocked or stubbed dependencies. Mocha, 
which is a JavaScript test framework that runs on Node.js, contains a simple 
module called "supertest." SuperTest provides you with a way to test HTTP 
requests, which is exactly what you need when you want to black-box test REST APIs.

WHAT IS BLACK-BOX TESTING?
--------------------------
DEFINITION:
Black-box testing means you test the code without looking at its internal 
structure. The system is tested as a whole without mocked or stubbed dependencies.

KEY CHARACTERISTICS:
• Tests from user's perspective
• Doesn't care about internal implementation
• Tests complete system (end-to-end)
• Uses real HTTP requests
• No mocking or stubbing

REAL-WORLD ANALOGY:
Think of black-box testing like testing a car:
• You test by driving (making HTTP requests)
• You don't need to know how the engine works (internal code)
• You test if it works as expected (correct responses)
• You test the whole car (complete system)

WHY BLACK-BOX TESTING?
----------------------
1. TESTS REAL BEHAVIOR
   • Tests what users actually experience
   • Catches integration issues
   • Verifies complete request/response cycle

2. INDEPENDENT OF IMPLEMENTATION
   • Can refactor code without changing tests
   • Tests focus on behavior, not code structure
   • More maintainable tests

3. CATCHES INTEGRATION ISSUES
   • Tests how components work together
   • Catches middleware issues
   • Verifies database interactions

WHAT IS SUPERTEST?
------------------
DEFINITION:
Mocha, which is a JavaScript test framework that runs on Node.js, contains a 
simple module called "supertest." SuperTest provides you with a way to test 
HTTP requests, which is exactly what you need when you want to black-box test REST APIs.

KEY FEATURES:
• Makes HTTP requests to your Express app
• Asserts on responses (status, body, headers)
• Works with Mocha test framework
• Easy to use API

INSTALLATION
------------
  npm install --save-dev mocha supertest

OR

  npm install --save-dev jest supertest

SETUP EXAMPLE WITH MOCHA
------------------------
  // test/employees.test.js
  const request = require('supertest');
  const app = require('../app');
  const { expect } = require('chai');

  describe('Employee API', () => {
    describe('GET /employees', () => {
      it('should get all employees', async () => {
        const res = await request(app)
          .get('/employees')
          .expect(200);
        
        expect(res.body).to.be.an('array');
      });
    });
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: // test/employees.test.js
         • Comment showing test file path
         • .test.js suffix indicates test file

Line 2: const request = require('supertest');
         • Imports SuperTest library
         • request is a function to make HTTP requests

Line 3: const app = require('../app');
         • Imports Express app
         • '../app' - Path to app.js file
         • SuperTest needs the app to make requests to it

Line 4: const { expect } = require('chai');
         • Imports Chai assertion library
         • expect - Function for making assertions
         • Chai provides readable assertions

Line 6: describe('Employee API', () => {
         • Mocha test suite
         • Groups related tests together
         • 'Employee API' - Description of test suite

Line 7: describe('GET /employees', () => {
         • Nested test suite
         • Groups tests for GET /employees endpoint

Line 8: it('should get all employees', async () => {
         • Individual test case
         • 'should get all employees' - Test description
         • async - Allows await in test

Line 9: const res = await request(app)
         • Makes HTTP request to app
         • request(app) - Creates request object
         • await - Waits for request to complete
         • res - Response object

Line 10: .get('/employees')
          • Sets HTTP method and path
          • .get() - Makes GET request
          • '/employees' - Route path

Line 11: .expect(200);
          • Asserts status code is 200
          • .expect() - SuperTest assertion method
          • 200 - Expected status code
          • Throws error if status doesn't match

Line 13: expect(res.body).to.be.an('array');
         • Chai assertion
         • expect() - Starts assertion
         • res.body - Response body (parsed JSON)
         • .to.be.an('array') - Asserts body is an array

COMPLETE TEST EXAMPLES
----------------------

EXAMPLE 1: GET ALL EMPLOYEES
-----------------------------
  describe('GET /employees', () => {
    it('should return 200 and array of employees', async () => {
      const res = await request(app)
        .get('/employees')
        .expect(200)
        .expect('Content-Type', /json/);
      
      expect(res.body).to.be.an('array');
      expect(res.body.length).to.be.at.least(0);
    });

    it('should return employees with correct structure', async () => {
      const res = await request(app)
        .get('/employees')
        .expect(200);
      
      if (res.body.length > 0) {
        expect(res.body[0]).to.have.property('id');
        expect(res.body[0]).to.have.property('name');
        expect(res.body[0]).to.have.property('email');
      }
    });
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: describe('GET /employees', () => {
         • Test suite for GET /employees endpoint

Line 2: it('should return 200 and array of employees', async () => {
         • Test case description
         • Tests basic functionality

Line 3: const res = await request(app)
         • Creates request to app

Line 4: .get('/employees')
         • Makes GET request to /employees

Line 5: .expect(200)
         • Asserts status code is 200

Line 6: .expect('Content-Type', /json/);
         • Asserts Content-Type header contains 'json'
         • /json/ - Regular expression matching 'json'
         • Ensures response is JSON

Line 8: expect(res.body).to.be.an('array');
         • Asserts response body is an array

Line 9: expect(res.body.length).to.be.at.least(0);
         • Asserts array has at least 0 items
         • Allows empty array (valid response)

Line 11: it('should return employees with correct structure', async () => {
         • Second test case
         • Tests response structure

Line 12-14: const res = await request(app)
             .get('/employees')
             .expect(200);
         • Makes request and asserts status

Line 16: if (res.body.length > 0) {
         • Only test structure if employees exist
         • Avoids errors on empty array

Line 17: expect(res.body[0]).to.have.property('id');
         • Asserts first employee has 'id' property
         • .to.have.property() - Chai assertion

Line 18: expect(res.body[0]).to.have.property('name');
         • Asserts employee has 'name' property

Line 19: expect(res.body[0]).to.have.property('email');
         • Asserts employee has 'email' property

EXAMPLE 2: GET SINGLE EMPLOYEE
-------------------------------
  describe('GET /employees/:id', () => {
    it('should return 200 and employee when found', async () => {
      // First create an employee
      const createRes = await request(app)
        .post('/employees')
        .send({ name: 'Test User', email: 'test@example.com' })
        .expect(201);
      
      const employeeId = createRes.body.id;
      
      // Then get it
      const res = await request(app)
        .get(`/employees/${employeeId}`)
        .expect(200);
      
      expect(res.body).to.have.property('id', employeeId);
      expect(res.body).to.have.property('name', 'Test User');
      expect(res.body).to.have.property('email', 'test@example.com');
    });

    it('should return 404 when employee not found', async () => {
      const res = await request(app)
        .get('/employees/999999')
        .expect(404);
      
      expect(res.body).to.have.property('error');
    });
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: describe('GET /employees/:id', () => {
         • Test suite for GET single employee

Line 2: it('should return 200 and employee when found', async () => {
         • Test for successful retrieval

Line 3-6: // First create an employee
          const createRes = await request(app)
            .post('/employees')
            .send({ name: 'Test User', email: 'test@example.com' })
            .expect(201);
         • Creates employee first (setup)
         • .post() - Makes POST request
         • .send() - Sends request body (JSON)
         • .expect(201) - Asserts created status
         • createRes - Response from creation

Line 8: const employeeId = createRes.body.id;
         • Gets ID from created employee
         • createRes.body - Response body
         • .id - ID property

Line 10-13: // Then get it
            const res = await request(app)
              .get(`/employees/${employeeId}`)
              .expect(200);
         • Gets employee by ID
         • Template literal: `/employees/${employeeId}`
         • Example: /employees/123

Line 15-17: expect(res.body).to.have.property('id', employeeId);
            expect(res.body).to.have.property('name', 'Test User');
            expect(res.body).to.have.property('email', 'test@example.com');
         • Asserts response has correct data
         • .to.have.property('id', employeeId) - Asserts property exists and equals value

Line 19: it('should return 404 when employee not found', async () => {
         • Test for not found case

Line 20-22: const res = await request(app)
             .get('/employees/999999')
             .expect(404);
         • Requests non-existent employee
         • 999999 - Fake ID that doesn't exist
         • Expects 404 status

Line 24: expect(res.body).to.have.property('error');
         • Asserts error message in response

EXAMPLE 3: CREATE EMPLOYEE
---------------------------
  describe('POST /employees', () => {
    it('should create employee and return 201', async () => {
      const newEmployee = {
        name: 'John Doe',
        email: 'john@example.com',
        position: 'Developer'
      };
      
      const res = await request(app)
        .post('/employees')
        .send(newEmployee)
        .expect(201);
      
      expect(res.body).to.have.property('id');
      expect(res.body).to.have.property('name', 'John Doe');
      expect(res.body).to.have.property('email', 'john@example.com');
    });

    it('should return 400 for invalid data', async () => {
      const invalidEmployee = {
        name: '',  // Empty name (invalid)
        email: 'not-an-email'  // Invalid email format
      };
      
      const res = await request(app)
        .post('/employees')
        .send(invalidEmployee)
        .expect(400);
      
      expect(res.body).to.have.property('error');
    });
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: describe('POST /employees', () => {
         • Test suite for creating employees

Line 2: it('should create employee and return 201', async () => {
         • Test for successful creation

Line 3-7: const newEmployee = {
           name: 'John Doe',
           email: 'john@example.com',
           position: 'Developer'
         };
         • Test data object
         • Contains valid employee data

Line 9-12: const res = await request(app)
            .post('/employees')
            .send(newEmployee)
            .expect(201);
         • Makes POST request
         • .post() - HTTP POST method
         • .send() - Sends JSON body
         • .expect(201) - Asserts created status

Line 14-16: expect(res.body).to.have.property('id');
            expect(res.body).to.have.property('name', 'John Doe');
            expect(res.body).to.have.property('email', 'john@example.com');
         • Asserts created employee has correct data
         • ID should be auto-generated
         • Name and email should match sent data

Line 18: it('should return 400 for invalid data', async () => {
         • Test for validation errors

Line 19-22: const invalidEmployee = {
             name: '',  // Empty name (invalid)
             email: 'not-an-email'  // Invalid email format
           };
         • Invalid test data
         • Empty name violates required rule
         • Invalid email format

Line 24-27: const res = await request(app)
              .post('/employees')
              .send(invalidEmployee)
              .expect(400);
         • Sends invalid data
         • Expects 400 Bad Request

Line 29: expect(res.body).to.have.property('error');
         • Asserts error message present

EXAMPLE 4: UPDATE EMPLOYEE
---------------------------
  describe('PATCH /employees/:id', () => {
    it('should update employee and return 200', async () => {
      // Create employee first
      const createRes = await request(app)
        .post('/employees')
        .send({ name: 'Original Name', email: 'original@example.com' })
        .expect(201);
      
      const employeeId = createRes.body.id;
      
      // Update employee
      const res = await request(app)
        .patch(`/employees/${employeeId}`)
        .send({ name: 'Updated Name' })
        .expect(200);
      
      expect(res.body).to.have.property('name', 'Updated Name');
      expect(res.body).to.have.property('email', 'original@example.com');  // Unchanged
    });
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: describe('PATCH /employees/:id', () => {
         • Test suite for updating employees

Line 2: it('should update employee and return 200', async () => {
         • Test for successful update

Line 3-6: // Create employee first
          const createRes = await request(app)
            .post('/employees')
            .send({ name: 'Original Name', email: 'original@example.com' })
            .expect(201);
         • Setup: Creates employee to update
         • Original data for comparison

Line 8: const employeeId = createRes.body.id;
         • Gets ID of created employee

Line 10-13: // Update employee
            const res = await request(app)
              .patch(`/employees/${employeeId}`)
              .send({ name: 'Updated Name' })
              .expect(200);
         • Makes PATCH request
         • .patch() - HTTP PATCH method
         • .send() - Sends only fields to update
         • Expects 200 OK

Line 15: expect(res.body).to.have.property('name', 'Updated Name');
         • Asserts name was updated

Line 16: expect(res.body).to.have.property('email', 'original@example.com');
         • Asserts email unchanged (partial update)
         • PATCH only updates specified fields

EXAMPLE 5: DELETE EMPLOYEE
---------------------------
  describe('DELETE /employees/:id', () => {
    it('should delete employee and return 204', async () => {
      // Create employee first
      const createRes = await request(app)
        .post('/employees')
        .send({ name: 'To Delete', email: 'delete@example.com' })
        .expect(201);
      
      const employeeId = createRes.body.id;
      
      // Delete employee
      await request(app)
        .delete(`/employees/${employeeId}`)
        .expect(204);
      
      // Verify deletion
      await request(app)
        .get(`/employees/${employeeId}`)
        .expect(404);
    });
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: describe('DELETE /employees/:id', () => {
         • Test suite for deleting employees

Line 2: it('should delete employee and return 204', async () => {
         • Test for successful deletion

Line 3-6: // Create employee first
          const createRes = await request(app)
            .post('/employees')
            .send({ name: 'To Delete', email: 'delete@example.com' })
            .expect(201);
         • Setup: Creates employee to delete

Line 8: const employeeId = createRes.body.id;
         • Gets ID of employee to delete

Line 10-12: // Delete employee
            await request(app)
              .delete(`/employees/${employeeId}`)
              .expect(204);
         • Makes DELETE request
         • .delete() - HTTP DELETE method
         • Expects 204 No Content

Line 14-16: // Verify deletion
            await request(app)
              .get(`/employees/${employeeId}`)
              .expect(404);
         • Verifies employee was deleted
         • GET request should return 404
         • Confirms deletion worked

BEST PRACTICES FOR BLACK-BOX TESTING
-------------------------------------
1. TEST COMPLETE FLOWS
   • Test entire request/response cycle
   • Include setup and teardown
   • Test realistic scenarios

2. USE REAL DATA WHEN POSSIBLE
   • Use test database
   • Clean up after tests
   • Don't rely on existing data

3. TEST ERROR CASES
   • Test 404, 400, 500 errors
   • Test validation failures
   • Test edge cases

4. KEEP TESTS INDEPENDENT
   • Each test should work alone
   • Don't rely on test execution order
   • Clean up test data

5. USE DESCRIPTIVE TEST NAMES
   • Clear test descriptions
   • Explain what is being tested
   • Make failures easy to understand

[END SECTION 2.3]
================================================================================

SECTION 2.4: JWT-BASED STATELESS AUTHENTICATION
------------------------------------------------

OVERVIEW
--------
And when your API needs to authenticate, it is best practice to use JSON Web 
Token, or JWT based stateless authentication. Since the REST APIs must be 
stateless, your authentication will need to be as well. Stateless 
authentication verifies users by supplying most of the session information, 
such as user properties, on the client side.

WHAT IS STATELESS AUTHENTICATION?
---------------------------------
DEFINITION:
Stateless authentication verifies users by supplying most of the session 
information, such as user properties, on the client side.

KEY CHARACTERISTICS:
• No server-side session storage
• All information in the token
• Client sends token with each request
• Server validates token without database lookup

WHY STATELESS?
-------------
Since the REST APIs must be stateless, your authentication will need to be 
as well.

REST PRINCIPLE:
• REST APIs should be stateless
• Each request contains all information needed
• Server doesn't store client state
• Scalable and simple

STATEFUL VS STATELESS:
---------------------
STATEFUL (Traditional Sessions):
  Client → Login → Server stores session → Returns session ID
  Client → Request + Session ID → Server looks up session → Response
  
  Problems:
  • Server must store sessions (memory/database)
  • Doesn't scale well (multiple servers need shared storage)
  • More complex

STATELESS (JWT):
  Client → Login → Server creates JWT → Returns JWT
  Client → Request + JWT → Server validates JWT → Response
  
  Benefits:
  • No server-side storage needed
  • Scales easily (any server can validate)
  • Simpler architecture

WHAT IS JWT?
------------
DEFINITION:
JSON Web Token, or JWT, is a compact, URL-safe token format for securely 
transmitting information between parties.

JWT STRUCTURE:
A JWT has three parts separated by dots (.):

  header.payload.signature

EXAMPLE:
  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMywibmFtZSI6IkpvaG4gRG9lIn0.signature

PART 1: HEADER
--------------
Contains token type and signing algorithm:

  {
    "alg": "HS256",
    "typ": "JWT"
  }

  • alg - Algorithm used to sign token (HS256 = HMAC SHA-256)
  • typ - Token type (always "JWT")

PART 2: PAYLOAD
---------------
Contains claims (user data):

  {
    "userId": 123,
    "name": "John Doe",
    "email": "john@example.com",
    "iat": 1516239022,
    "exp": 1516242622
  }

  • userId, name, email - Custom claims (user data)
  • iat - Issued at (timestamp)
  • exp - Expiration (timestamp)

PART 3: SIGNATURE
-----------------
Created by signing header + payload with secret:

  HMACSHA256(
    base64UrlEncode(header) + "." + base64UrlEncode(payload),
    secret
  )

  • Ensures token hasn't been tampered with
  • Only server with secret can create valid tokens

INSTALLATION
------------
  npm install jsonwebtoken

BASIC JWT IMPLEMENTATION
-------------------------

STEP 1: CREATE TOKEN ON LOGIN
------------------------------
  // routes/auth.js
  const jwt = require('jsonwebtoken');
  const User = require('../models/User');

  router.post('/login', async (req, res) => {
    try {
      const { email, password } = req.body;
      
      // Find user
      const user = await User.findOne({ email });
      if (!user) {
        return res.status(401).json({ error: 'Invalid credentials' });
      }
      
      // Verify password (simplified - use bcrypt in production)
      if (user.password !== password) {
        return res.status(401).json({ error: 'Invalid credentials' });
      }
      
      // Create JWT token
      const token = jwt.sign(
        { userId: user.id, email: user.email },
        process.env.JWT_SECRET,
        { expiresIn: '24h' }
      );
      
      res.json({ token });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: // routes/auth.js
         • Comment showing file path

Line 2: const jwt = require('jsonwebtoken');
         • Imports jsonwebtoken library
         • Provides JWT creation and verification

Line 3: const User = require('../models/User');
         • Imports User model
         • Needed to find user in database

Line 5: router.post('/login', async (req, res) => {
         • POST route for login
         • '/login' - Login endpoint

Line 6: try {
         • Error handling

Line 7: const { email, password } = req.body;
         • Destructures email and password from request body
         • { email, password } - ES6 destructuring
         • req.body - Request body (JSON data)

Line 9-12: // Find user
           const user = await User.findOne({ email });
           if (!user) {
             return res.status(401).json({ error: 'Invalid credentials' });
           }
         • Finds user by email
         • User.findOne() - Mongoose method to find one document
         • If user not found, returns 401 Unauthorized
         • Don't reveal if email exists (security best practice)

Line 14-17: // Verify password (simplified - use bcrypt in production)
            if (user.password !== password) {
              return res.status(401).json({ error: 'Invalid credentials' });
            }
         • Verifies password
         • ⚠️ Simplified - should use bcrypt.compare() in production!
         • If password doesn't match, returns 401

Line 19-23: // Create JWT token
            const token = jwt.sign(
              { userId: user.id, email: user.email },
              process.env.JWT_SECRET,
              { expiresIn: '24h' }
            );
         • Creates JWT token
         • jwt.sign() - Creates signed token
         • First argument: Payload (user data to include)
         • Second argument: Secret key (from environment)
         • Third argument: Options (expires in 24 hours)
         • Token contains userId and email

Line 25: res.json({ token });
         • Sends token to client
         • Client stores token and sends with requests

Line 26: } catch (error) {
         • Catches errors

Line 27: res.status(500).json({ error: error.message });
         • Sends 500 error

STEP 2: CREATE AUTHENTICATION MIDDLEWARE
----------------------------------------
  // middleware/auth.js
  const jwt = require('jsonwebtoken');

  const authenticateToken = (req, res, next) => {
    // Get token from header
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];  // "Bearer TOKEN"
    
    if (!token) {
      return res.status(401).json({ error: 'Access token required' });
    }
    
    // Verify token
    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
      if (err) {
        return res.status(403).json({ error: 'Invalid or expired token' });
      }
      
      req.user = user;  // Attach user data to request
      next();  // Continue to next middleware/route
    });
  };

  module.exports = authenticateToken;

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: // middleware/auth.js
         • Comment showing middleware file path

Line 2: const jwt = require('jsonwebtoken');
         • Imports jsonwebtoken library

Line 4: const authenticateToken = (req, res, next) => {
         • Defines authentication middleware
         • req - Request object
         • res - Response object
         • next - Function to call next middleware

Line 5-6: // Get token from header
          const authHeader = req.headers['authorization'];
          const token = authHeader && authHeader.split(' ')[1];
         • Gets token from Authorization header
         • req.headers['authorization'] - Authorization header value
         • Format: "Bearer TOKEN"
         • authHeader.split(' ')[1] - Gets token part (after "Bearer ")
         • && - Short-circuit: if authHeader exists, split it

Line 8-10: if (!token) {
            return res.status(401).json({ error: 'Access token required' });
          }
         • Checks if token exists
         • If no token, returns 401 Unauthorized
         • Stops request processing

Line 12-18: // Verify token
            jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
              if (err) {
                return res.status(403).json({ error: 'Invalid or expired token' });
              }
              
              req.user = user;  // Attach user data to request
              next();  // Continue to next middleware/route
            });
         • Verifies token signature
         • jwt.verify() - Verifies token is valid
         • token - Token to verify
         • process.env.JWT_SECRET - Secret key (must match sign key)
         • Callback receives error or decoded payload
         • If error, returns 403 Forbidden
         • If valid, attaches user data to req.user
         • Calls next() to continue request

STEP 3: USE MIDDLEWARE IN PROTECTED ROUTES
------------------------------------------
  // routes/employees.js
  const express = require('express');
  const router = express.Router();
  const authenticateToken = require('../middleware/auth');
  const Employee = require('../models/Employee');

  // Protected route - requires authentication
  router.get('/profile', authenticateToken, async (req, res) => {
    try {
      // req.user is available from authenticateToken middleware
      const user = await User.findById(req.user.userId);
      res.json(user);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });

  // Protected route - create employee (only authenticated users)
  router.post('/', authenticateToken, async (req, res) => {
    try {
      const employee = new Employee(req.body);
      await employee.save();
      res.status(201).json(employee);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: // routes/employees.js
         • Comment showing route file

Line 3: const authenticateToken = require('../middleware/auth');
         • Imports authentication middleware
         • '../middleware/auth' - Path to middleware file

Line 6: router.get('/profile', authenticateToken, async (req, res) => {
         • Protected route
         • authenticateToken - Middleware runs before route handler
         • Middleware checks for valid token
         • If invalid, returns error and stops
         • If valid, continues to route handler

Line 7: try {
         • Error handling

Line 8-9: // req.user is available from authenticateToken middleware
          const user = await User.findById(req.user.userId);
         • Gets user data from token
         • req.user - Set by authenticateToken middleware
         • req.user.userId - User ID from token payload
         • Finds user in database

Line 10: res.json(user);
         • Sends user data

Line 14: router.post('/', authenticateToken, async (req, res) => {
         • Protected POST route
         • Only authenticated users can create employees
         • authenticateToken middleware runs first

HOW CLIENT USES JWT
-------------------
1. CLIENT LOGS IN:
   POST /login
   Body: { "email": "user@example.com", "password": "password123" }
   
   Response: { "token": "eyJhbGci..." }

2. CLIENT STORES TOKEN:
   localStorage.setItem('token', response.token);
   // Or in memory, cookies, etc.

3. CLIENT SENDS TOKEN WITH REQUESTS:
   GET /employees/profile
   Headers: {
     "Authorization": "Bearer eyJhbGci..."
   }

4. SERVER VALIDATES:
   • Middleware extracts token
   • Verifies signature
   • Checks expiration
   • Attaches user data to req.user

BEST PRACTICES FOR JWT
----------------------
1. USE HTTPS
   • Always use HTTPS in production
   • Prevents token interception
   • Required for security

2. SET EXPIRATION
   • Tokens should expire
   • Shorter expiration = more secure
   • Common: 1 hour to 24 hours

3. STORE SECRET SECURELY
   • Never commit secret to git
   • Use environment variables
   • Use strong, random secrets

4. DON'T STORE SENSITIVE DATA
   • Token can be decoded (not encrypted)
   • Don't store passwords in token
   • Only store necessary user data

5. HANDLE EXPIRATION
   • Client should refresh token before expiration
   • Server should return clear error for expired tokens
   • Consider refresh token pattern

[END SECTION 2.4]
================================================================================

SECTION 2.5: API DOCUMENTATION
-------------------------------

OVERVIEW
--------
The last best API practice we will emphasize here is creating proper API 
documentation. The whole purpose of an API is so that someone else can use 
them, so you want to provide appropriate documentation for your Node.js REST API.

WHY DOCUMENTATION MATTERS
--------------------------
1. ENABLES API USAGE
   • The whole purpose of an API is so that someone else can use them
   • Documentation shows how to use the API
   • Without docs, API is unusable

2. REDUCES SUPPORT BURDEN
   • Developers can find answers in docs
   • Fewer questions and support requests
   • Self-service documentation

3. IMPROVES ADOPTION
   • Good docs encourage API usage
   • Clear examples help developers
   • Professional appearance

4. ONBOARDING
   • New team members understand API quickly
   • Consistent understanding across team
   • Easier to maintain

WHAT TO DOCUMENT
----------------
1. ENDPOINTS
   • All available routes
   • HTTP methods
   • URL paths

2. REQUEST FORMAT
   • Required headers
   • Request body structure
   • Query parameters
   • Path parameters

3. RESPONSE FORMAT
   • Status codes
   • Response body structure
   • Error formats

4. AUTHENTICATION
   • How to authenticate
   • Token format
   • Error responses

5. EXAMPLES
   • Request examples
   • Response examples
   • Code samples

DOCUMENTATION TOOLS
-------------------

TOOL 1: API BLUEPRINT
---------------------
DEFINITION:
API Blueprint which can be found at api blueprint dot org

WHAT IT IS:
• Markdown-based API documentation format
• Human-readable and machine-parseable
• Generates interactive documentation

EXAMPLE:
  # Employee API

  ## Get All Employees [GET /employees]
  
  + Response 200 (application/json)
  
          [
            {
              "id": 1,
              "name": "John Doe",
              "email": "john@example.com"
            }
          ]

INSTALLATION:
  npm install -g aglio

USAGE:
  aglio -i api.apib -o api.html

TOOL 2: SWAGGER/OPENAPI
------------------------
DEFINITION:
Swagger, which can be found at swagger dot I O

WHAT IT IS:
• Most popular API documentation tool
• OpenAPI specification (formerly Swagger)
• Interactive API explorer
• Code generation support

INSTALLATION:
  npm install swagger-ui-express swagger-jsdoc

EXAMPLE SETUP:
  // swagger.js
  const swaggerJsdoc = require('swagger-jsdoc');
  const swaggerUi = require('swagger-ui-express');

  const options = {
    definition: {
      openapi: '3.0.0',
      info: {
        title: 'Employee API',
        version: '1.0.0',
        description: 'API for managing employees',
      },
      servers: [
        {
          url: 'http://localhost:3000',
          description: 'Development server',
        },
      ],
    },
    apis: ['./routes/*.js'],  // Path to API files
  };

  const specs = swaggerJsdoc(options);

  module.exports = { swaggerUi, specs };

  // In app.js
  const { swaggerUi, specs } = require('./swagger');
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));

EXAMPLE ROUTE DOCUMENTATION:
----------------------------
  /**
   * @swagger
   * /employees:
   *   get:
   *     summary: Get all employees
   *     tags: [Employees]
   *     responses:
   *       200:
   *         description: List of employees
   *         content:
   *           application/json:
   *             schema:
   *               type: array
   *               items:
   *                 $ref: '#/components/schemas/Employee'
   */
  router.get('/', async (req, res) => {
    // Route implementation
  });

LINE-BY-LINE EXPLANATION:
-------------------------
Line 1: /**
         • JSDoc comment start
         • Swagger reads these comments

Line 2: * @swagger
         • Swagger annotation
         • Tells Swagger to process this

Line 3: * /employees:
         • API endpoint path
         • Defines route

Line 4: *   get:
         • HTTP method
         • Defines GET endpoint

Line 5: *     summary: Get all employees
         • Brief description
         • Shows in documentation

Line 6: *     tags: [Employees]
         • Groups endpoints
         • Organizes documentation

Line 7: *     responses:
         • Response definitions
         • Documents possible responses

Line 8: *       200:
         • Status code
         • Successful response

Line 9-15: *         description: List of employees
            *         content:
            *           application/json:
            *             schema:
            *               type: array
            *               items:
            *                 $ref: '#/components/schemas/Employee'
         • Response structure
         • Array of Employee objects
         • References schema definition

BEST PRACTICES FOR DOCUMENTATION
---------------------------------
1. KEEP IT UPDATED
   • Update docs when API changes
   • Outdated docs are worse than no docs
   • Make docs part of development process

2. INCLUDE EXAMPLES
   • Real request/response examples
   • Multiple scenarios
   • Code samples in multiple languages

3. EXPLAIN ERRORS
   • Document all error responses
   • Explain when errors occur
   • Provide error code meanings

4. MAKE IT SEARCHABLE
   • Use clear headings
   • Organize by resource
   • Include search functionality

5. TEST YOUR EXAMPLES
   • Ensure examples work
   • Test all code samples
   • Keep examples current

[END SECTION 2.5]
[END PART 2]
================================================================================

PART 3: ADDITIONAL EXPRESS BEST PRACTICES
================================================================================

SECTION 3.1: NPM USAGE GUIDELINES
-----------------------------------

OVERVIEW
--------
There are a number of other helpful tips that are widely followed when building 
an express node.js application. Regarding the use of node package manager, or 
NPM, use the npm init command when initializing a node.js project. When using 
the npm install command to install dependencies, use the dash save or the dash 
save dash dev attribute. This makes sure that if the application is moved to a 
different platform, the correct dependencies will be installed with it. Never 
push a node modules repository. And always use npm to install.

BEST PRACTICE 1: USE NPM INIT
-------------------------------
DEFINITION:
Use the npm init command when initializing a node.js project.

WHAT IT DOES:
• Creates package.json file
• Prompts for project information
• Sets up project structure

HOW TO USE:
  npm init

INTERACTIVE PROMPTS:
  package name: (my-app)
  version: (1.0.0)
  description: My Express application
  entry point: (index.js) app.js
  test command:
  git repository:
  keywords:
  author: Your Name
  license: (ISC) MIT

QUICK INIT (SKIP PROMPTS):
  npm init -y

  Creates package.json with defaults:
  {
    "name": "my-app",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
      "test": "echo \"Error: no test specified\" && exit 1"
    },
    "keywords": [],
    "author": "",
    "license": "ISC"
  }

WHY USE NPM INIT:
-----------------
1. CREATES PACKAGE.JSON
   • Essential file for Node.js projects
   • Defines project metadata
   • Required for dependency management

2. STANDARD STRUCTURE
   • Follows Node.js conventions
   • Other developers understand it
   • Works with npm tools

3. VERSION CONTROL
   • Tracks project version
   • Helps with releases
   • Professional project setup

BEST PRACTICE 2: USE --SAVE AND --SAVE-DEV
------------------------------------------
DEFINITION:
When using the npm install command to install dependencies, use the dash save 
or the dash save dash dev attribute. This makes sure that if the application is 
moved to a different platform, the correct dependencies will be installed with it.

WHAT THESE FLAGS DO:
--------------------
--save (or -S):
• Adds package to dependencies in package.json
• Package needed to run the application
• Installed in production

--save-dev (or -D):
• Adds package to devDependencies in package.json
• Package only needed for development
• Not installed in production

EXAMPLES:
---------
INSTALL PRODUCTION DEPENDENCY:
  npm install express --save

  OR (shorthand):
  npm install express -S

  Adds to package.json:
  {
    "dependencies": {
      "express": "^4.18.2"
    }
  }

INSTALL DEVELOPMENT DEPENDENCY:
  npm install nodemon --save-dev

  OR (shorthand):
  npm install nodemon -D

  Adds to package.json:
  {
    "devDependencies": {
      "nodemon": "^2.0.22"
    }
  }

WHY THIS MATTERS:
-----------------
1. PORTABILITY
   • This makes sure that if the application is moved to a different platform, 
     the correct dependencies will be installed with it
   • package.json lists all dependencies
   • npm install reads package.json and installs everything
   • Works on any machine/platform

2. VERSION CONTROL
   • Dependencies tracked in package.json
   • Team members get same versions
   • Reproducible builds

3. PRODUCTION VS DEVELOPMENT
   • Separates production and dev dependencies
   • Production installs only what's needed
   • Smaller production deployments

MODERN NPM BEHAVIOR:
--------------------
Note: In npm 5+, --save is default for npm install:
  npm install express  # Automatically adds to dependencies

But --save-dev still needed for dev dependencies:
  npm install nodemon --save-dev  # Must specify for devDependencies

BEST PRACTICE 3: NEVER PUSH NODE_MODULES
-----------------------------------------
DEFINITION:
Never push a node modules repository.

WHAT THIS MEANS:
• Don't commit node_modules/ to git
• Don't push node_modules/ to version control
• Add node_modules/ to .gitignore

WHY NOT?
--------
1. SIZE
   • node_modules/ can be hundreds of MB
   • Makes repository huge
   • Slow clones and pulls

2. REDUNDANT
   • Can be regenerated from package.json
   • npm install recreates it
   • No need to store it

3. PLATFORM SPECIFIC
   • May contain platform-specific binaries
   • Different on Windows/Mac/Linux
   • Causes conflicts

HOW TO PREVENT:
---------------
CREATE .GITIGNORE FILE:
  # .gitignore
  node_modules/
  .env
  *.log
  .DS_Store

VERIFY:
  git status  # Should not show node_modules/

BEST PRACTICE 4: ALWAYS USE NPM TO INSTALL
------------------------------------------
DEFINITION:
And always use npm to install.

WHAT THIS MEANS:
• Use npm install (not manual copying)
• Let npm manage dependencies
• Use npm for all package management

WHY USE NPM:
------------
1. DEPENDENCY RESOLUTION
   • npm resolves dependency conflicts
   • Handles nested dependencies
   • Ensures compatibility

2. VERSION MANAGEMENT
   • Respects version ranges in package.json
   • Installs compatible versions
   • Handles updates properly

3. CONSISTENCY
   • Same process for all packages
   • Standardized approach
   • Works across projects

[END SECTION 3.1]
================================================================================

SECTION 3.2: CAPITALIZATION CONVENTIONS
----------------------------------------

OVERVIEW
--------
Stick with the following capitalization conventions. Use all lowercase for file 
names, use camel case for variables, and npm modules are named in lowercase, 
separated by dashes. And when using the "require" method for npm modules, use 
camel case.

CONVENTION 1: FILE NAMES - ALL LOWERCASE
-----------------------------------------
DEFINITION:
Use all lowercase for file names.

EXAMPLES:
✅ CORRECT:
  app.js
  routes.js
  user.js
  employee-controller.js
  database-config.js

❌ INCORRECT:
  App.js          # Capital letter
  Routes.js       # Capital letter
  User.js         # Capital letter
  EmployeeController.js  # CamelCase
  Database-Config.js      # Capital letters

WHY LOWERCASE:
--------------
1. CROSS-PLATFORM COMPATIBILITY
   • Some systems are case-sensitive (Linux)
   • Others are case-insensitive (Windows/Mac)
   • Lowercase works everywhere

2. CONSISTENCY
   • All files follow same pattern
   • Easy to remember
   • No confusion

3. CONVENTION
   • Node.js community standard
   • Matches npm package naming
   • Widely adopted

CONVENTION 2: VARIABLES - CAMEL CASE
------------------------------------
DEFINITION:
Use camel case for variables.

EXAMPLES:
✅ CORRECT:
  const userName = 'John';
  const employeeCount = 10;
  const isAuthenticated = true;
  const getUserById = (id) => { ... };
  const expressApp = require('express');

❌ INCORRECT:
  const user_name = 'John';        # snake_case
  const employee-count = 10;        # kebab-case (invalid JS)
  const IsAuthenticated = true;    # PascalCase (for classes)
  const get_user_by_id = (id) => { ... };  # snake_case

WHY CAMEL CASE:
---------------
1. JAVASCRIPT CONVENTION
   • Standard JavaScript style
   • Used throughout JavaScript ecosystem
   • Familiar to JavaScript developers

2. READABILITY
   • Easy to read
   • Clear word boundaries
   • Standard practice

3. CONSISTENCY
   • Matches JavaScript style guides
   • Works with linters (ESLint)
   • Professional code style

CONVENTION 3: NPM MODULES - LOWERCASE WITH DASHES
-------------------------------------------------
DEFINITION:
npm modules are named in lowercase, separated by dashes.

EXAMPLES:
✅ CORRECT NPM PACKAGE NAMES:
  express
  body-parser
  express-validator
  jsonwebtoken
  mongoose

❌ INCORRECT (wouldn't be valid npm packages):
  Express          # Capital letter
  body_parser      # Underscores
  expressValidator # CamelCase
  JSONWebToken     # PascalCase

WHY LOWERCASE WITH DASHES:
--------------------------
1. NPM CONVENTION
   • npm package naming standard
   • All packages follow this
   • Required by npm registry

2. URL FRIENDLY
   • Dashes work in URLs
   • No encoding needed
   • Easy to type

3. CONSISTENCY
   • All packages same format
   • Easy to remember
   • Predictable naming

CONVENTION 4: REQUIRE NPM MODULES - CAMEL CASE
----------------------------------------------
DEFINITION:
And when using the "require" method for npm modules, use camel case.

WHAT THIS MEANS:
• Package name: express-validator (lowercase with dashes)
• Variable name: expressValidator (camelCase)

EXAMPLES:
---------
✅ CORRECT:
  const express = require('express');
  const bodyParser = require('body-parser');
  const expressValidator = require('express-validator');
  const jsonWebToken = require('jsonwebtoken');
  const mongoose = require('mongoose');

❌ INCORRECT:
  const express-validator = require('express-validator');  # Invalid (dash in variable)
  const body_parser = require('body-parser');             # snake_case
  const ExpressValidator = require('express-validator');   # PascalCase (for classes)

CONVERSION PATTERN:
-------------------
Package Name → Variable Name:
  express              → express
  body-parser          → bodyParser
  express-validator    → expressValidator
  jsonwebtoken         → jsonWebToken (or jwt)
  mongoose             → mongoose

RULE:
• Remove dashes
• Capitalize first letter after each dash
• Keep rest lowercase

WHY CAMEL CASE FOR VARIABLES:
------------------------------
1. JAVASCRIPT CONVENTION
   • Variables use camelCase in JavaScript
   • Matches language style
   • Works with all JavaScript tools

2. VALID JAVASCRIPT
   • Dashes not allowed in variable names
   • Must convert to valid identifier
   • camelCase is standard conversion

3. READABILITY
   • Clear and readable
   • Easy to type
   • Consistent with other variables

COMPLETE EXAMPLE:
-----------------
  // File: app.js (lowercase)
  
  // Require npm modules (camelCase variables)
  const express = require('express');
  const bodyParser = require('body-parser');
  const mongoose = require('mongoose');
  
  // Variables (camelCase)
  const app = express();
  const port = process.env.PORT || 3000;
  const dbConnection = mongoose.connection;
  
  // Functions (camelCase)
  const startServer = () => {
    app.listen(port, () => {
      console.log(`Server running on port ${port}`);
    });
  };
  
  module.exports = app;

[END SECTION 3.2]
================================================================================

SECTION 3.3: CONFIGURATION FILE BEST PRACTICES
-----------------------------------------------

OVERVIEW
--------
Using config files for variables and group similar functioning routes into 
their own files.

BEST PRACTICE 1: USE CONFIG FILES FOR VARIABLES
-----------------------------------------------
DEFINITION:
Using config files for variables

WHY USE CONFIG FILES:
---------------------
1. ORGANIZATION
   • All configuration in one place
   • Easy to find and modify
   • Clear separation of concerns

2. SECURITY
   • Keeps sensitive data separate
   • Environment-specific values
   • Not committed to git

3. FLEXIBILITY
   • Easy to change without code changes
   • Different configs for environments
   • Centralized management

EXAMPLE STRUCTURE:
------------------
  // config/database.js
  module.exports = {
    development: {
      host: 'localhost',
      port: 27017,
      database: 'myapp_dev'
    },
    production: {
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      database: process.env.DB_NAME
    }
  };

  // config/app.js
  module.exports = {
    port: process.env.PORT || 3000,
    nodeEnv: process.env.NODE_ENV || 'development',
    jwtSecret: process.env.JWT_SECRET
  };

  // In app.js
  const dbConfig = require('./config/database');
  const appConfig = require('./config/app');
  
  const config = dbConfig[appConfig.nodeEnv];
  // Use config values

BEST PRACTICE 2: GROUP SIMILAR ROUTES
--------------------------------------
DEFINITION:
Group similar functioning routes into their own files.

WHAT THIS MEANS:
• One file per resource type
• Related routes together
• Clear organization

EXAMPLE:
--------
✅ CORRECT STRUCTURE:
  routes/
  ├── users.js        # All user routes
  ├── products.js     # All product routes
  ├── orders.js       # All order routes
  └── auth.js         # Authentication routes

❌ INCORRECT STRUCTURE:
  routes.js            # All routes in one file (too large)
  routes/
  ├── getUsers.js     # One file per route (too many files)
  ├── createUser.js
  ├── updateUser.js
  └── deleteUser.js

EXAMPLE: GROUPED ROUTES
------------------------
  // routes/users.js - All user-related routes
  const express = require('express');
  const router = express.Router();
  const User = require('../models/User');

  // GET /users - Get all users
  router.get('/', async (req, res) => {
    // Implementation
  });

  // GET /users/:id - Get single user
  router.get('/:id', async (req, res) => {
    // Implementation
  });

  // POST /users - Create user
  router.post('/', async (req, res) => {
    // Implementation
  });

  // PATCH /users/:id - Update user
  router.patch('/:id', async (req, res) => {
    // Implementation
  });

  // DELETE /users/:id - Delete user
  router.delete('/:id', async (req, res) => {
    // Implementation
  });

  module.exports = router;

WHY GROUP ROUTES:
-----------------
1. ORGANIZATION
   • Related routes together
   • Easy to find specific routes
   • Clear structure

2. MAINTAINABILITY
   • Easy to modify related routes
   • Changes isolated to one file
   • Less chance of breaking other routes

3. SCALABILITY
   • Can add new route files easily
   • Doesn't create huge files
   • Team members can work on different files

[END SECTION 3.3]
[END PART 3]
================================================================================

PART 4: SUMMARY AND KEY TAKEAWAYS
================================================================================

SECTION 4.1: FOLDER STRUCTURE SUMMARY
--------------------------------------

STANDARD EXPRESS APPLICATION STRUCTURE
---------------------------------------
  my-app/
  ├── node_modules/     # Dependencies (auto-generated, don't commit)
  ├── config/          # Configuration files (database, env, credentials)
  ├── models/          # Data models (database schemas)
  ├── routes/          # Route definitions (one file per resource)
  ├── views/           # Template files (HTML templates)
  ├── public/          # Static files (CSS, images, client JS)
  ├── app.js           # Main application file
  ├── routes.js         # Central routes file
  └── package.json      # Project metadata

STANDARD API STRUCTURE
----------------------
  my-api/
  ├── node_modules/
  ├── config/
  ├── models/
  ├── routes/
  ├── app.js
  ├── routes.js
  └── package.json

KEY DIFFERENCES:
• APIs don't need views/ folder (no HTML templates)
• APIs don't need public/ folder (no static files)
• APIs focus on data exchange (JSON/XML)

FOLDER PURPOSES
---------------
• node_modules/ - Contains application's modules and packages (auto-created)
• config/ - Configuration files (database, environment variables, API keys)
• models/ - Data models (specify datastore type, defined by ORM library)
• routes/ - Route definitions (one file per logical set of routes)
• views/ - Template files (dynamically write HTML, CSS, JavaScript)
• public/ - Static content (images, CSS, JavaScript files)

FILE PURPOSES
-------------
• app.js - Main configuration file for your application
• routes.js - Central location to access all routes (single point of entry)
• package.json - Metadata used to manage project's dependencies

[END SECTION 4.1]
================================================================================

SECTION 4.2: API BEST PRACTICES SUMMARY
----------------------------------------

ROUTE NAMING
------------
✅ USE NOUNS AS RESOURCE IDENTIFIERS
   • GET /employees (not /getEmployees)
   • POST /employees (not /createEmployee)
   • Use plural nouns (/employees, not /employee)

HTTP STATUS CODES
-----------------
• 200s - Success (200 OK, 201 Created, 204 No Content)
• 300s - Redirection (301 Moved, 302 Found, 304 Not Modified)
• 400s - Client Error (400 Bad Request, 401 Unauthorized, 404 Not Found)
• 500s - Server Error (500 Internal Error, 503 Unavailable)

TESTING
-------
✅ BLACK-BOX TEST REST APIs
   • Test without looking at internal structure
   • Test system as a whole
   • Use SuperTest for HTTP request testing

AUTHENTICATION
--------------
✅ USE JWT-BASED STATELESS AUTHENTICATION
   • REST APIs must be stateless
   • Authentication should be stateless too
   • JWT provides stateless authentication
   • Token contains user information

DOCUMENTATION
-------------
✅ CREATE PROPER API DOCUMENTATION
   • Whole purpose of API is for others to use it
   • Document endpoints, requests, responses
   • Use tools like Swagger or API Blueprint
   • Include examples

[END SECTION 4.2]
================================================================================

SECTION 4.3: QUICK REFERENCE GUIDE
-----------------------------------

NPM BEST PRACTICES
------------------
1. Use npm init when initializing project
2. Use --save for production dependencies
3. Use --save-dev for development dependencies
4. Never push node_modules/ to git
5. Always use npm to install packages

CAPITALIZATION CONVENTIONS
--------------------------
1. File names: all lowercase (app.js, routes.js)
2. Variables: camelCase (userName, employeeCount)
3. NPM packages: lowercase with dashes (express-validator)
4. Require variables: camelCase (expressValidator)

CONFIGURATION BEST PRACTICES
----------------------------
1. Use config files for variables
2. Group similar routes into their own files
3. Keep sensitive data in environment variables
4. Separate configs for different environments

FOLDER STRUCTURE QUICK REFERENCE
--------------------------------
APPLICATION (with views/public):
  node_modules/
  config/
  models/
  routes/
  views/        ← For HTML templates
  public/       ← For static files
  app.js
  routes.js
  package.json

API (no views/public):
  node_modules/
  config/
  models/
  routes/
  app.js
  routes.js
  package.json

ROUTE NAMING QUICK REFERENCE
----------------------------
✅ CORRECT:
  GET    /employees
  GET    /employees/:id
  POST   /employees
  PATCH  /employees/:id
  DELETE /employees/:id

❌ INCORRECT:
  GET    /getEmployees
  POST   /createEmployee
  GET    /employees/:id/delete

HTTP STATUS CODES QUICK REFERENCE
---------------------------------
200  OK                    - Successful GET, PUT, PATCH
201  Created                - Successful POST
204  No Content            - Successful DELETE
400  Bad Request           - Invalid request syntax
401  Unauthorized          - Authentication required
403  Forbidden             - Insufficient permissions
404  Not Found             - Resource doesn't exist
500  Internal Server Error - Generic server error

[END SECTION 4.3]
================================================================================

FINAL NOTES
-----------
This comprehensive study guide has expanded on the original Express Best 
Practices content while maintaining all original definitions and information. 
Each concept has been explained in detail with line-by-line code explanations 
to ensure thorough understanding.

KEY TAKEAWAYS:
• Use a directory structure in both Express.js applications and APIs
• Follow standard folder conventions (config, models, routes, etc.)
• Use nouns as resource identifiers in API routes
• Use HTTP status codes correctly
• Black-box test REST APIs using SuperTest
• Use JWT-based stateless authentication
• Create proper API documentation
• Follow capitalization conventions
• Use npm as recommended
• Use config files for variables
• Group similar routes into their own files

Remember:
• Express doesn't require a specific structure, but conventions help
• As applications grow, structure becomes critical
• Following best practices makes code maintainable and scalable
• Good documentation enables others to use your API
• Consistent conventions help team collaboration

You now have a comprehensive understanding of Express Best Practices. These 
concepts are fundamental to building professional Express applications and APIs.

Good luck with your Express development journey!

================================================================================
END OF PART 2
================================================================================

Original Content Maintained
----------------------------
All original definitions, explanations, and concepts from the source material 
have been preserved and expanded upon in this comprehensive guide.
