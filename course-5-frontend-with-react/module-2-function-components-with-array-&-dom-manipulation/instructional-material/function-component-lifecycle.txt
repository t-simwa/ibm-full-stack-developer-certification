[MUSIC] Welcome to Function Component Lifecycle. After watching this video, you will be
able define functional components in React, recognize the four different phases
of a functional component in React. In React, functional components
are the fundamental building blocks for creating user interfaces. Understanding the lifecycle of
functional components is essential for managing the behavior and state of
components throughout their existence. While functional components lack
traditional lifecycle methods found in class components, developers can
achieve similar functions using hooks such as useState, useEffect,
and useReducer, among others. The lifecycle of a functional component
in React undergoes four distinct phases, mounting phase, updating phase, unmounting
phase, and error handling phase. The first phase is the mounting phase,
during the mounting phase, React initializes the functional component,
preparing it for rendering on the DOM. The important steps involved in
the mounting phase include initialization, state initialization, and side effects. The first step is initialization.
In this step, React runs the function body
of the functional component, setting up the initial structure and
behavior of the component. After initialization,
React performs state initialization, in this step, React utilizes
the useState hook to declare and initialize state variables
within the component. These state variables hold data
that may change over time, triggering re-renders of
the component when modified. Let us look at an example. In this example, the useState hook creates a state
variable called count initialized to 0. This state variable can be actively
updated using the setCount function triggering re-renders of the component
whenever its value changes. Finally, React performs side effects
such as data fetching subscriptions or DOM manipulation using the useEffect
hook with an empty dependency array. This step ensures that side effects
execute only once after the initial render, optimizing performance and
preventing unnecessary re-execution. Here is an example. In this example,
the useEffect hook fetches data from https//api.example.com/data
when the component mounts. It then sets the retrieved data using
setData, which with an empty dependency array to ensure the effect runs
only once after the initial render. We will now discuss the updating phase. During the updating phase, React responds
to changes in the component state or props by re-invoking the function
body of the component. This phase triggers a re-evaluation
of the JavaScript XML (JSX), allowing React to determine
the new UI to render. Here is an example. In the updating phase of
the functional component myComponent, the useState hook initializes
the count state variable to 0 point. On clicking the button, the increment
function invokes updating the count state by incrementing its previous value by one,
using setCount. This step triggers a re-render of
the component displaying the updated count value on the screen. The updating phase involves
responding to user actions and state modifications, ensuring your UI
stays in sync with the underlying data. Let's now learn about
the unmounting phase. During the unmounting phase, React executes cleanup operations when
removing a component from the DOM. These operations involve
the component itself, actively cleaning up event listeners,
subscriptions, timers, or any other resources
it created during its lifecycle. Here is an example. In the unmounting phase of the functional
component, myComponent, the setInterval function within the useEffect
actively sets up an interval timer. This timer executes a callback
method every 1000 milliseconds, logging interval tick to the console. The component actively returns
a cleanup function from the useEffect hook to ensure proper
cleanup and prevent memory leaks. This cleanup function uses clearInterval
to clear the interval timer when the component unmounts, thereby freeing
up the resources associated with it. This active cleanup mechanism ensures
that the interval timer's resources are released when the component
is removed from the DOM, thus preventing potential issues or
memory leaks. But what happens if an error
occurs during rendering or within a child component's
lifecycle method in React? React will handle the error
in such cases by routing it to the nearest error boundary. This
error-handling mechanism is the final phase of the functional component's lifecycle. Error boundaries are special components
in react that catch errors during the rendering phase or lifecycle
methods of their child components. Instead of crashing
the entire application, error boundaries display a fallback UI, preventing the error from propagating
further up the component tree and ensuring the rest of the application
remains functional despite the error in a specific component. In this video, you learned that React's
lifecycle phase includes mounting, updating, unmounting, and error handling. The mounting phase
initializes the component, sets up the initial state,
and performs side effects. In the updating phase, React re-invokes
the function body and re-evaluates JSX. In the unmounting phase, React executes cleanup operations when
removing a component from the DOM. React handles the error by routing
it to the nearest error boundary. [MUSIC]