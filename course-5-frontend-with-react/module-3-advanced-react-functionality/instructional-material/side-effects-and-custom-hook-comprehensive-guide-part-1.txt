================================================================================
SIDE EFFECTS MANAGEMENT AND CUSTOM HOOKS
Comprehensive Study Guide - Part 1
================================================================================

WELCOME
-------
Welcome to Side Effects Management and Custom Hooks. This comprehensive guide 
will teach you everything you need to know about useEffect, side effects, and 
custom hooks in React, from the basics to advanced patterns.

ESTIMATED TIME NEEDED
---------------------
5 minutes (for basic reading)
60-90 minutes (for comprehensive study with practice)

LEARNING OBJECTIVES
-------------------
After studying this guide, you will be able to:
• Define the role of useEffect and side effects in React
• Describe how useEffect and side effects work in React
• Describe the various dependencies in useEffect
• Describe a custom hook in React
• Use useEffect to perform side effects in functional components
• Create and use custom hooks to abstract reusable logic
• Understand when and why to use side effects and custom hooks

OVERVIEW
--------
In React, side effects are operations that need to happen outside the normal 
render cycle. These include fetching data from APIs, subscribing to events, 
manipulating the DOM, or setting timers. The useEffect hook allows you to 
perform these side effects in functional components.

Custom hooks are a powerful feature that allows you to extract and reuse 
stateful logic between components. They enable you to abstract complex logic 
that you can easily reuse across different components in your application.

================================================================================
TABLE OF CONTENTS
================================================================================

PART 1: INTRODUCTION TO SIDE EFFECTS AND USEEFFECT
  SECTION 1.1: WHAT ARE SIDE EFFECTS?
  SECTION 1.2: WHAT IS USEEFFECT?
  SECTION 1.3: WHY DO WE NEED USEEFFECT?
  SECTION 1.4: UNDERSTANDING ASYNCHRONOUS OPERATIONS

PART 2: USEEFFECT IN DETAIL
  SECTION 2.1: USEEFFECT BASIC SYNTAX
  SECTION 2.2: COMPLETE EXAMPLE: FETCHING FOOD ITEMS FROM API
  SECTION 2.3: LINE-BY-LINE EXPLANATION OF FOOD ITEMS EXAMPLE
  SECTION 2.4: HOW USEEFFECT WORKS IN REACT

PART 3: DEPENDENCIES IN USEEFFECT
  SECTION 3.1: WHAT ARE DEPENDENCIES?
  SECTION 3.2: EMPTY DEPENDENCY ARRAY (RUNS ONCE)
  SECTION 3.3: DEPENDENCY ARRAY WITH VALUES (RUNS WHEN VALUES CHANGE)
  SECTION 3.4: NO DEPENDENCY ARRAY (RUNS AFTER EVERY RENDER)
  SECTION 3.5: COMPARING THE THREE DEPENDENCY SCENARIOS

PART 4: COMMON SIDE EFFECT PATTERNS
  SECTION 4.1: FETCHING DATA FROM AN API
  SECTION 4.2: SUBSCRIBING TO EVENTS
  SECTION 4.3: MANIPULATING THE DOM
  SECTION 4.4: SETTING TIMERS
  SECTION 4.5: CLEANUP IN USEEFFECT

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 1.3:") to quickly jump to any section.

================================================================================
PART 1: INTRODUCTION TO SIDE EFFECTS AND USEEFFECT
================================================================================

SECTION 1.1: WHAT ARE SIDE EFFECTS?
------------------------------------

DEFINITION
----------
A side effect refers to any operation that you need to execute as soon as the 
page loads, without calling those operations or functionalities separately, 
such as:
• Fetching data from an API
• Subscribing to events
• Manipulating the DOM
• Setting timers

Side effects are actions that occur asynchronously, and affect the application's 
state or the UI.

DETAILED EXPLANATION
--------------------
In programming, a "side effect" is any operation that affects something outside 
the scope of the function or component. In React, side effects are operations 
that happen outside the normal render cycle.

Think of it this way: when React renders a component, it's like a factory 
producing a product. The normal render process creates the UI (the product). 
But sometimes, you need to do things AFTER the product is made, like:
• Shipping it somewhere (fetching data)
• Setting up a monitoring system (subscribing to events)
• Adding labels or modifications (manipulating the DOM)
• Setting up automatic processes (timers)

These operations are "side effects" because they happen alongside (on the side 
of) the main rendering process.

KEY CHARACTERISTICS OF SIDE EFFECTS:
• They occur asynchronously (not immediately during render)
• They affect the application's state or the UI
• They need to happen at specific times (on mount, on update, etc.)
• They often need cleanup when the component unmounts

REAL-WORLD ANALOGY
------------------
Imagine you're opening a restaurant (your React component). The normal process 
is preparing food (rendering the UI). But side effects are like:
• Ordering ingredients from suppliers (fetching data from API)
• Setting up security cameras (subscribing to events)
• Putting up signs and decorations (manipulating the DOM)
• Setting up automatic timers for ovens (setting timers)

These things need to happen, but they're not part of the main cooking process. 
They're "side effects" of running the restaurant.

COMMON TYPES OF SIDE EFFECTS IN REACT
--------------------------------------
1. DATA FETCHING
   • Fetching user data from an API
   • Loading product information
   • Getting weather data
   • Retrieving messages or notifications

2. SUBSCRIPTIONS
   • Listening to WebSocket connections
   • Subscribing to real-time updates
   • Listening to browser events (scroll, resize, etc.)
   • Subscribing to push notifications

3. DOM MANIPULATION
   • Changing document title
   • Modifying meta tags
   • Focusing on input fields
   • Scrolling to specific positions

4. TIMERS
   • Setting up countdown timers
   • Creating intervals for updates
   • Scheduling delayed actions
   • Creating animation loops

[END SECTION 1.1]
================================================================================

SECTION 1.2: WHAT IS USEEFFECT?
---------------------------------

DEFINITION
----------
useEffect is a React hook that allows you to perform side effects in functional 
components.

DETAILED EXPLANATION
--------------------
useEffect is one of the most important hooks in React. It gives function 
components the ability to perform side effects, which was previously only 
possible in class components using lifecycle methods like componentDidMount, 
componentDidUpdate, and componentWillUnmount.

The useEffect hook combines all these lifecycle methods into one unified API, 
making it easier to manage side effects in functional components.

HOW USEEFFECT WORKS
-------------------
When you use useEffect, you're telling React: "After you finish rendering this 
component, run this code." React will:
1. Render your component
2. Update the DOM
3. Run your useEffect code
4. Optionally clean up when the component unmounts or before the next effect runs

BASIC STRUCTURE
---------------
  useEffect(() => {
    // Side effect code goes here
  }, [dependencies]);

The useEffect hook takes two arguments:
1. A function containing the side effect code
2. An optional dependency array that controls when the effect runs

WHY USEEFFECT EXISTS
-------------------
Before useEffect, if you wanted to perform side effects in a function component, 
you couldn't. You had to convert your function component to a class component, 
which added complexity. useEffect solved this problem by allowing side effects 
in function components.

REAL-WORLD ANALOGY
------------------
Think of useEffect like a personal assistant. When you (the component) finish 
your main work (rendering), the assistant (useEffect) automatically handles 
all the follow-up tasks (side effects) like:
• Making phone calls (API requests)
• Setting reminders (timers)
• Organizing files (DOM manipulation)
• Keeping you updated (subscriptions)

[END SECTION 1.2]
================================================================================

SECTION 1.3: WHY DO WE NEED USEEFFECT?
---------------------------------------

THE PROBLEM WITHOUT USEEFFECT
------------------------------
Before useEffect, function components were limited. They could:
• Render UI
• Handle events
• Use props

But they couldn't:
• Fetch data when the component loads
• Set up subscriptions
• Clean up resources
• Respond to prop or state changes

THE SOLUTION: USEEFFECT
-----------------------
useEffect solves all these problems by allowing you to:
• Run code after the component renders
• Respond to changes in props or state
• Clean up resources when the component unmounts
• Perform operations that affect things outside the component

WHEN TO USE USEEFFECT
---------------------
Use useEffect when you need to:
• Fetch data from an API when a component mounts
• Set up a subscription or event listener
• Manually change the DOM
• Set up or clear timers
• Perform any operation that should happen after render
• Clean up resources when a component unmounts

WHEN NOT TO USE USEEFFECT
-------------------------
Don't use useEffect for:
• Transforming data during render (do this directly in the component)
• Event handlers (use regular functions)
• State updates based on props (use derived state or useMemo)
• Synchronous operations that don't affect outside the component

[END SECTION 1.3]
================================================================================

SECTION 1.4: UNDERSTANDING ASYNCHRONOUS OPERATIONS
----------------------------------------------------

WHAT DOES "ASYNCHRONOUSLY" MEAN?
--------------------------------
When we say side effects occur "asynchronously," we mean they don't happen at 
the exact same time as the component renders. They happen after the render is 
complete.

SYNCHRONOUS VS ASYNCHRONOUS
----------------------------
SYNCHRONOUS (happens immediately):
  function Component() {
    const name = 'John';  // Happens immediately
    return <div>{name}</div>;  // Renders immediately
  }

ASYNCHRONOUS (happens later):
  function Component() {
    useEffect(() => {
      fetch('/api/data')  // Happens AFTER render completes
        .then(data => console.log(data));
    }, []);
    return <div>Loading...</div>;  // Renders first
  }

WHY SIDE EFFECTS ARE ASYNCHRONOUS
----------------------------------
Side effects are asynchronous because:
1. They often involve network requests (which take time)
2. They shouldn't block the render process
3. They need to happen after the DOM is ready
4. They allow React to render quickly, then handle side effects

EXAMPLE: FETCHING DATA
----------------------
When you fetch data from an API:
1. Component renders immediately (showing "Loading...")
2. useEffect runs after render
3. API request is sent (takes time)
4. Response comes back (later)
5. State is updated with the data
6. Component re-renders with the data

This is asynchronous because steps 3-6 happen after the initial render.

[END SECTION 1.4]
[END PART 1]
================================================================================

PART 2: USEEFFECT IN DETAIL
================================================================================

SECTION 2.1: USEEFFECT BASIC SYNTAX
------------------------------------

BASIC SYNTAX
------------
  useEffect(() => {
    // Side effect code here
  }, [dependencies]);

BREAKDOWN
---------
• useEffect - The hook function from React
• First argument: A function containing the side effect code
• Second argument: An optional dependency array
  - Controls when the effect runs
  - Can be empty [], have values, or be omitted entirely

MINIMAL EXAMPLE
---------------
  import React, { useEffect } from 'react';

  function MyComponent() {
    useEffect(() => {
      console.log('Component rendered!');
    });
    
    return <div>Hello World</div>;
  }

LINE-BY-LINE EXPLANATION
-------------------------
Line 1: import React, { useEffect } from 'react';
        • Imports React (needed for JSX)
        • Imports useEffect hook from React
        • This is a named import - useEffect is exported from React

Line 2: function MyComponent() {
        • Declares a function component named MyComponent
        • Function components are the modern way to write React components

Line 3: useEffect(() => {
        • Calls the useEffect hook
        • Passes an arrow function as the first argument
        • This function contains the side effect code

Line 4: console.log('Component rendered!');
        • This is the side effect code
        • It will run after the component renders
        • In this case, it logs a message to the console

Line 5: });
        • Closes the useEffect call
        • No dependency array means it runs after every render

Line 6: (empty line for readability)

Line 7: return <div>Hello World</div>;
        • Returns JSX to render
        • This renders first, then useEffect runs

Line 8: }
        • Closes the component function

WHAT HAPPENS WHEN THIS COMPONENT RENDERS
-----------------------------------------
1. React calls MyComponent()
2. React executes the return statement, rendering <div>Hello World</div>
3. React updates the DOM with the rendered content
4. React runs the useEffect function
5. console.log executes, printing "Component rendered!" to the console

[END SECTION 2.1]
================================================================================

SECTION 2.2: COMPLETE EXAMPLE: FETCHING FOOD ITEMS FROM API
-------------------------------------------------------------

OVERVIEW
--------
As mentioned in the original content: "Here's a simple example to understand 
useEffect and the side effects in React. Suppose we have a component that 
fetches a list of food items from an API and displays them."

This section provides a complete, working example based on that description.

COMPLETE CODE EXAMPLE
---------------------
  import React, { useState, useEffect } from 'react';

  function SideEffect() {
    // State Management with useState
    const [foods, setFoods] = useState([]);

    // Performing Side Effects with useEffect
    useEffect(() => {
      // Data Fetching
      fetch('https://api.example.com/foods')
        .then(response => response.json())
        .then(data => {
          console.log('Fetched data:', data);
          setFoods(data);
        })
        .catch(error => {
          console.error('Error fetching foods:', error);
        });
    }, []);

    // Rendering the Fetched Data
    return (
      <ul>
        {foods.map(food => (
          <li key={food.id}>
            <h3>{food.name}</h3>
            <p>{food.description}</p>
            <p>Price: ${food.price}</p>
            <p>Category: {food.category}</p>
            <p>Ingredients: {food.ingredients.join(', ')}</p>
            <img src={food.image_url} alt={food.name} />
          </li>
        ))}
      </ul>
    );
  }

  // Component Export
  export default SideEffect;

WHAT THIS COMPONENT DOES
------------------------
1. Creates state to store food items (starts as empty array)
2. When component mounts, fetches food data from an API
3. Updates state with fetched data
4. Renders a list of food items with their details
5. Displays images for each food item

[END SECTION 2.2]
================================================================================

SECTION 2.3: LINE-BY-LINE EXPLANATION OF FOOD ITEMS EXAMPLE
------------------------------------------------------------

DETAILED LINE-BY-LINE BREAKDOWN
--------------------------------

IMPORT STATEMENTS
-----------------
Line 1: import React, { useState, useEffect } from 'react';
        • import React - Imports the React library
          - Required for JSX syntax
          - Provides React functionality
        • { useState, useEffect } - Named imports
          - useState: Hook for managing component state
          - useEffect: Hook for performing side effects
          - Both are destructured from React's exports
        • from 'react' - Specifies where to import from
          - React is the package containing these hooks

COMPONENT DECLARATION
---------------------
Line 2: function SideEffect() {
        • function - Declares a function component
        • SideEffect - Component name (must start with capital letter)
          - React convention: component names are PascalCase
          - This name matches the original content's example
        • () - No props needed for this component
        • { - Opens the function body

STATE MANAGEMENT WITH USESTATE
-------------------------------
Line 3: (empty line for readability)

Line 4: // State Management with useState
        • Comment explaining the next section
        • Helps document the code's purpose

Line 5: const [foods, setFoods] = useState([]);
        • const - Declares a constant variable
        • [foods, setFoods] - Array destructuring
          - foods: Current state value (the food items array)
          - setFoods: Function to update the foods state
        • = useState([]) - Calls useState hook
          - [] is the initial value (empty array)
          - Returns [currentValue, setterFunction]
        • ; - Statement terminator
        
        EXPLANATION FROM ORIGINAL CONTENT:
        "The component utilizes the useState hook to manage the state within 
        a functional component. Specifically, it declares a state variable 
        named foods using useState, initializing it with an empty array. This 
        variable will later hold the data fetched from the API."

PERFORMING SIDE EFFECTS WITH USEEFFECT
---------------------------------------
Line 6: (empty line for readability)

Line 7: // Performing Side Effects with useEffect
        • Comment explaining the useEffect section

Line 8: useEffect(() => {
        • useEffect - The hook function
        • () => { - Arrow function as first argument
          - This function contains the side effect code
          - Will execute after component renders
        
        EXPLANATION FROM ORIGINAL CONTENT:
        "The useEffect hook is employed to execute side effects in functional 
        components. In this component, useEffect is utilized to fetch data 
        from an external API when the component mounts."

DATA FETCHING INSIDE USEEFFECT
-------------------------------
Line 9: (empty line for readability)

Line 10: // Data Fetching
         • Comment explaining the fetch operation

Line 11: fetch('https://api.example.com/foods')
         • fetch() - Browser API for making HTTP requests
         • 'https://api.example.com/foods' - API endpoint URL
           - This is the external API endpoint
           - In real apps, replace with actual API URL
         • Returns a Promise that resolves to a Response object
         
         EXPLANATION FROM ORIGINAL CONTENT:
         "Inside the useEffect hook, a fetch request is made to the specified 
         API endpoint, as shown. The fetch function returns a promise that 
         resolves to the response from the server."

Line 12: .then(response => response.json())
         • .then() - Promise method for handling successful responses
         • response - The Response object from fetch
         • => response.json() - Arrow function that:
           - Calls .json() method on the response
           - Parses the response body as JSON
           - Returns another Promise that resolves to the parsed data
         
         EXPLANATION FROM ORIGINAL CONTENT:
         "Upon receiving the response, response.json parses the response body 
         as JSON."

Line 13: .then(data => {
         • .then() - Handles the parsed JSON data
         • data - The parsed JSON data (array of food items)
         • => { - Opens function body for processing the data

Line 14: console.log('Fetched data:', data);
         • console.log() - Debugging function
         • 'Fetched data:' - Label for the log message
         • data - The actual data being logged
         • ; - Statement terminator
         
         EXPLANATION FROM ORIGINAL CONTENT:
         "The parsed JSON data is then available in the next then block, where 
         it is logged to the console for debugging purposes"

Line 15: setFoods(data);
         • setFoods - State setter function from useState
         • data - The fetched food items array
         • Updates the foods state with the fetched data
         • This triggers a re-render with the new data
         
         EXPLANATION FROM ORIGINAL CONTENT:
         "and subsequently passed to setFoods to update the food state variable 
         with the fetched data."

Line 16: })
         • Closes the second .then() callback function

Line 17: .catch(error => {
         • .catch() - Promise method for handling errors
         • error - The error object if something goes wrong
         • => { - Opens error handling function

Line 18: console.error('Error fetching foods:', error);
         • console.error() - Logs errors to console
         • 'Error fetching foods:' - Error message label
         • error - The actual error object
         • ; - Statement terminator
         
         EXPLANATION FROM ORIGINAL CONTENT:
         "If an error occurs during the fetch operation, it is caught in the 
         catch block and an error message is logged to the console."

Line 19: });
         • Closes the .catch() callback
         • Closes the entire fetch promise chain

Line 20: }, []);
         • } - Closes the useEffect function
         • , [] - Dependency array (empty array)
           - Empty array means: run only once when component mounts
           - This ensures the API is called only once, not on every render
         
         EXPLANATION FROM ORIGINAL CONTENT:
         "When you provide an empty dependency array, the effect runs only once 
         when the component will load for the first time."

RENDERING THE FETCHED DATA
--------------------------
Line 21: (empty line for readability)

Line 22: // Rendering the Fetched Data
         • Comment explaining the render section

Line 23: return (
         • return - Returns JSX to render
         • ( - Parentheses allow JSX to span multiple lines

Line 24: <ul>
         • <ul> - Unordered list HTML element
         • Opens the list container
         
         EXPLANATION FROM ORIGINAL CONTENT:
         "In the JSX returned by the component, a list, ul, of food items is 
         rendered."

Line 25: {foods.map(food => (
         • { - Opens JSX expression
         • foods - The state array containing food items
         • .map() - Array method that transforms each item
         • food => - Arrow function parameter (each food item)
         • ( - Parentheses for implicit return
         
         EXPLANATION FROM ORIGINAL CONTENT:
         "The map method is used to iterate over the foods array and generate 
         a list item, li, for each food item."

Line 26: <li key={food.id}>
         • <li> - List item HTML element
         • key={food.id} - React key prop
           - Required for list items
           - Helps React track which items changed
           - Uses food.id as unique identifier

Line 27: <h3>{food.name}</h3>
         • <h3> - Heading level 3 element
         • {food.name} - JSX expression displaying food name
         • food.name - Accesses the name property of the food object
         
         EXPLANATION FROM ORIGINAL CONTENT:
         "For each food item, details such as name, description, price, 
         category, ingredients, and an image are displayed."

Line 28: <p>{food.description}</p>
         • <p> - Paragraph element
         • {food.description} - Displays food description
         • food.description - Accesses the description property

Line 29: <p>Price: ${food.price}</p>
         • <p> - Paragraph element
         • Price: - Static text label
         • ${food.price} - Template literal syntax
           - $ is literal text (dollar sign)
           - {food.price} - JSX expression for price value
         • food.price - Accesses the price property

Line 30: <p>Category: {food.category}</p>
         • <p> - Paragraph element
         • Category: - Static text label
         • {food.category} - Displays food category
         • food.category - Accesses the category property

Line 31: <p>Ingredients: {food.ingredients.join(', ')}</p>
         • <p> - Paragraph element
         • Ingredients: - Static text label
         • {food.ingredients.join(', ')} - JSX expression
           - food.ingredients - Array of ingredient strings
           - .join(', ') - Joins array elements with comma and space
           - Result: "ingredient1, ingredient2, ingredient3"
         • Displays all ingredients as a comma-separated list

Line 32: <img src={food.image_url} alt={food.name} />
         • <img> - Image HTML element (self-closing)
         • src={food.image_url} - Image source URL
           - food.image_url - URL string from food object
           - { } - JSX expression for dynamic URL
         • alt={food.name} - Alternative text for accessibility
           - food.name - Food name used as alt text
           - Helps screen readers describe the image
         
         EXPLANATION FROM ORIGINAL CONTENT:
         "The image is rendered using the image tag with the URL obtained from 
         the image underscore URL property of each food item."

Line 33: </li>
         • Closes the list item element

Line 34: ))}
         • )) - Closes the map arrow function and JSX expression
         • } - Closes the JSX expression block

Line 35: </ul>
         • Closes the unordered list element

Line 36: );
         • Closes the return statement parentheses

COMPONENT EXPORT
----------------
Line 37: }
         • Closes the SideEffect component function

Line 38: (empty line for readability)

Line 39: // Component Export
         • Comment explaining the export

Line 40: export default SideEffect;
         • export default - Exports the component as default export
         • SideEffect - The component being exported
         • ; - Statement terminator
         • Allows importing in other files: import SideEffect from './SideEffect'
         
         EXPLANATION FROM ORIGINAL CONTENT:
         "Finally, the SideEffect component is exported as the default export, 
         making it available for use in other parts of the application."

HOW THIS COMPONENT WORKS STEP-BY-STEP
--------------------------------------
1. Component renders initially with foods = [] (empty array)
2. useEffect runs after first render
3. Fetch request is sent to API
4. While waiting, component shows empty list (or loading state)
5. API responds with food data
6. setFoods(data) updates state
7. Component re-renders with food data
8. map() creates list items for each food
9. Each food item displays with all its details

[END SECTION 2.3]
================================================================================

SECTION 2.4: HOW USEEFFECT WORKS IN REACT
-------------------------------------------

THE RENDER CYCLE
----------------
When React renders a component with useEffect:

1. INITIAL RENDER
   • React calls your component function
   • Component returns JSX
   • React updates the DOM
   • React schedules useEffect to run

2. USEEFFECT EXECUTION
   • React runs your useEffect function
   • Side effects execute (API calls, subscriptions, etc.)
   • State may be updated (triggering re-render)

3. RE-RENDER (if state changed)
   • Component function runs again
   • New JSX is returned
   • DOM is updated
   • useEffect may run again (depending on dependencies)

4. CLEANUP (if provided)
   • Before next effect runs or component unmounts
   • Cleanup function executes
   • Resources are freed (timers cleared, subscriptions removed)

TIMING DIAGRAM
--------------
  Component Render → DOM Update → useEffect Runs → Side Effects Execute
        ↓                                                      ↓
   State Update ← Re-render ← State Change ← API Response/Event

KEY POINTS
----------
• useEffect runs AFTER the DOM is updated
• This prevents blocking the render process
• Side effects can update state, causing re-renders
• Cleanup functions run before the next effect or unmount

[END SECTION 2.4]
[END PART 2]
================================================================================

PART 3: DEPENDENCIES IN USEEFFECT
================================================================================

SECTION 3.1: WHAT ARE DEPENDENCIES?
------------------------------------

DEFINITION
----------
In React's useEffect hook, dependencies refer to variables or values which are 
used to determine when useEffect should run. Dependencies are specified as an 
array argument to the useEffect function.

DETAILED EXPLANATION
--------------------
The dependency array is the second argument to useEffect. It tells React:
• When to run the effect
• What values the effect depends on
• When to skip running the effect

Think of dependencies like a watch list. React watches these values, and when 
any of them change, React runs your effect again.

BASIC STRUCTURE
---------------
  useEffect(() => {
    // Effect code
  }, [dependency1, dependency2, dependency3]);
  //  ↑ This is the dependency array

WHAT CAN BE DEPENDENCIES
------------------------
Dependencies can be:
• State variables (from useState)
• Props (component props)
• Values derived from props or state
• Variables from component scope that are used in the effect

EXAMPLES OF DEPENDENCIES
------------------------
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  const userId = props.userId;

  useEffect(() => {
    // Uses count, name, and userId
  }, [count, name, userId]); // All three are dependencies

WHY DEPENDENCIES MATTER
-----------------------
Without proper dependencies:
• Effects might run too often (performance issues)
• Effects might not run when needed (bugs)
• Effects might use stale values (incorrect behavior)

With proper dependencies:
• Effects run exactly when needed
• Effects always have current values
• Better performance and correctness

[END SECTION 3.1]
================================================================================

SECTION 3.2: EMPTY DEPENDENCY ARRAY (RUNS ONCE)
------------------------------------------------

DEFINITION
----------
When you provide an empty dependency array, the effect runs only once when the 
component will load for the first time. It does not depend on any specific 
variable or state changes. This behavior is used to execute tasks only once at 
the time of loading.

SYNTAX
------
  useEffect(() => {
    // Effect code
  }, []); // Empty array = run once

DETAILED EXPLANATION
--------------------
An empty dependency array [] tells React:
• "This effect has no dependencies"
• "Run this effect only once, after the first render"
• "Don't run it again, even if the component re-renders"

This is equivalent to componentDidMount in class components.

WHEN TO USE EMPTY DEPENDENCY ARRAY
----------------------------------
Use [] when you want to:
• Fetch data when component first loads
• Set up subscriptions once
• Initialize third-party libraries
• Perform one-time setup tasks
• Do something that should only happen once

COMPLETE EXAMPLE
---------------
  import React, { useState, useEffect } from 'react';

  function UserProfile() {
    const [user, setUser] = useState(null);

    useEffect(() => {
      // Fetch user data only once when component mounts
      fetch('/api/user')
        .then(response => response.json())
        .then(data => setUser(data))
        .catch(error => console.error('Error:', error));
    }, []); // Empty array = run once on mount

    if (!user) {
      return <div>Loading...</div>;
    }

    return (
      <div>
        <h1>{user.name}</h1>
        <p>{user.email}</p>
      </div>
    );
  }

LINE-BY-LINE EXPLANATION
-------------------------
Line 1: import React, { useState, useEffect } from 'react';
        • Imports React and necessary hooks

Line 2: function UserProfile() {
        • Component declaration

Line 3: const [user, setUser] = useState(null);
        • Creates state to store user data
        • Initial value is null (no user data yet)

Line 4: (empty line)

Line 5: useEffect(() => {
        • Starts useEffect hook

Line 6-9: fetch('/api/user')
          .then(response => response.json())
          .then(data => setUser(data))
          .catch(error => console.error('Error:', error));
        • Fetches user data from API
        • Converts response to JSON
        • Updates state with user data
        • Handles errors

Line 10: }, []); // Empty array = run once on mount
         • Empty dependency array
         • Effect runs only once when component mounts
         • Won't run again on re-renders

Line 11: (empty line)

Line 12-14: if (!user) {
             return <div>Loading...</div>;
           }
         • Shows loading message if user data not yet loaded
         • Prevents rendering before data is available

Line 15: (empty line)

Line 16-20: return (
              <div>
                <h1>{user.name}</h1>
                <p>{user.email}</p>
              </div>
            );
         • Renders user information once data is loaded

WHAT HAPPENS
------------
1. Component renders first time (user is null)
2. Shows "Loading..." message
3. useEffect runs (because of empty array [])
4. API request is sent
5. Response comes back
6. setUser(data) updates state
7. Component re-renders
8. useEffect does NOT run again (empty array prevents it)
9. User information is displayed

EXAMPLE FROM ORIGINAL CONTENT
-----------------------------
As mentioned: "For example, in the code, the page will only load once at the 
loading of this page."

This refers to the empty dependency array behavior - the effect runs once when 
the page/component first loads.

COMMON USE CASES
----------------
• Fetching initial data
• Setting up WebSocket connections
• Initializing analytics tracking
• One-time DOM manipulation
• Setting up event listeners that don't need cleanup

[END SECTION 3.2]
================================================================================

SECTION 3.3: DEPENDENCY ARRAY WITH VALUES (RUNS WHEN VALUES CHANGE)
---------------------------------------------------------------------

DEFINITION
----------
When you provide values in the dependency array, the effect runs whenever any 
of these values change. If any of the dependencies have changed since the last 
render, React will rerun the effect. In the code, the effect runs only when 
the count state changes, ensuring that the useEffect hook executes whenever 
count is updated. Therefore, the count variable is included in the dependency 
array.

SYNTAX
------
  useEffect(() => {
    // Effect code
  }, [value1, value2, value3]); // Runs when any value changes

DETAILED EXPLANATION
--------------------
When you provide values in the dependency array:
• React watches these values
• If ANY value changes, React runs the effect again
• The effect has access to the latest values
• This ensures the effect stays in sync with its dependencies

This is similar to componentDidUpdate in class components, but more precise 
because you specify exactly which values to watch.

WHEN TO USE DEPENDENCY ARRAY WITH VALUES
----------------------------------------
Use [values] when you want to:
• Re-fetch data when a prop changes
• Update when state changes
• Respond to external changes
• Keep effect synchronized with specific values
• Avoid running effect unnecessarily

COMPLETE EXAMPLE WITH COUNT
---------------------------
  import React, { useState, useEffect } from 'react';

  function Counter() {
    const [count, setCount] = useState(0);
    const [message, setMessage] = useState('');

    useEffect(() => {
      // This runs whenever count changes
      setMessage(`Count is now: ${count}`);
      console.log('Count changed to:', count);
    }, [count]); // count is in dependency array

    return (
      <div>
        <p>Count: {count}</p>
        <p>{message}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
  }

LINE-BY-LINE EXPLANATION
-------------------------
Line 1: import React, { useState, useEffect } from 'react';
        • Imports React and hooks

Line 2: function Counter() {
        • Component declaration

Line 3: const [count, setCount] = useState(0);
        • Creates count state, initial value 0
        • This will be a dependency

Line 4: const [message, setMessage] = useState('');
        • Creates message state for displaying count
        • Initial value is empty string

Line 5: (empty line)

Line 6: useEffect(() => {
        • Starts useEffect hook

Line 7-8: setMessage(`Count is now: ${count}`);
          console.log('Count changed to:', count);
        • Updates message with current count
        • Logs count to console
        • Uses count value inside the effect

Line 9: }, [count]); // count is in dependency array
         • Dependency array contains count
         • Effect runs whenever count changes
         • Ensures effect always has latest count value

Line 10: (empty line)

Line 11-16: return (
              <div>
                <p>Count: {count}</p>
                <p>{message}</p>
                <button onClick={() => setCount(count + 1)}>Increment</button>
              </div>
            );
         • Renders count value
         • Displays message
         • Button increments count when clicked

WHAT HAPPENS
------------
1. Component renders (count = 0, message = '')
2. useEffect runs (count is 0)
3. Message updates to "Count is now: 0"
4. User clicks button
5. setCount(1) updates count to 1
6. Component re-renders
7. useEffect runs AGAIN (because count changed)
8. Message updates to "Count is now: 1"
9. Process repeats each time count changes

EXAMPLE FROM ORIGINAL CONTENT
-----------------------------
As mentioned: "For example, the count value as shown in the code. If any of 
the dependencies have changed since the last render, React will rerun the 
effect. In the code, the effect runs only when the count state changes, 
ensuring that the useEffect hook executes whenever count is updated. Therefore, 
the count variable is included in the dependency array."

This example demonstrates exactly this behavior.

EXAMPLE WITH MULTIPLE DEPENDENCIES
-----------------------------------
  function UserPosts({ userId, filter }) {
    const [posts, setPosts] = useState([]);

    useEffect(() => {
      // Fetches posts when userId OR filter changes
      fetch(`/api/users/${userId}/posts?filter=${filter}`)
        .then(res => res.json())
        .then(data => setPosts(data));
    }, [userId, filter]); // Both are dependencies

    return (
      <div>
        {posts.map(post => (
          <div key={post.id}>{post.title}</div>
        ))}
      </div>
    );
  }

EXPLANATION
-----------
• Effect runs when userId changes
• Effect runs when filter changes
• Effect runs when BOTH change
• Effect does NOT run when other state/props change
• This ensures posts are always in sync with userId and filter

IMPORTANT RULES
---------------
1. Include ALL values used inside the effect
2. If you use a value but don't include it, you'll get a warning
3. React compares dependencies using Object.is()
4. Objects and arrays are compared by reference, not value

COMMON MISTAKES
---------------
WRONG (missing dependency):
  useEffect(() => {
    fetch(`/api/users/${userId}`); // Uses userId but not in array
  }, []); // Missing userId!

RIGHT:
  useEffect(() => {
    fetch(`/api/users/${userId}`);
  }, [userId]); // userId included

[END SECTION 3.3]
================================================================================

SECTION 3.4: NO DEPENDENCY ARRAY (RUNS AFTER EVERY RENDER)
-----------------------------------------------------------

DEFINITION
----------
If you omit the dependency array entirely, the effect will run after every 
render, including the initial render and subsequent updates. This means that 
the effect will execute both after the initial render and after every rerender 
of the component, regardless of whether you change any values. This behavior 
with no dependency will cause the effect to run after every render.

SYNTAX
------
  useEffect(() => {
    // Effect code
  }); // No dependency array = runs after every render

DETAILED EXPLANATION
--------------------
When you omit the dependency array:
• React runs the effect after EVERY render
• This includes the initial render
• This includes every re-render (even if nothing changed)
• The effect runs regardless of whether values changed

This behavior is rarely needed and can cause performance issues if the effect 
does expensive operations or updates state (which would cause infinite loops).

WHEN TO USE NO DEPENDENCY ARRAY
--------------------------------
Use no dependency array when:
• You need to sync with every render (very rare)
• The effect doesn't update state or cause side effects that trigger renders
• You're debugging and want to see effect behavior on every render

WARNING: This can cause infinite loops if the effect updates state!

COMPLETE EXAMPLE
----------------
  import React, { useState, useEffect } from 'react';

  function RenderCounter() {
    const [count, setCount] = useState(0);
    const [renderCount, setRenderCount] = useState(0);

    // This runs after EVERY render
    useEffect(() => {
      console.log('Component rendered!');
      setRenderCount(prev => prev + 1);
    }); // No dependency array

    return (
      <div>
        <p>Count: {count}</p>
        <p>Renders: {renderCount}</p>
        <button onClick={() => setCount(count + 1)}>Increment Count</button>
      </div>
    );
  }

LINE-BY-LINE EXPLANATION
-------------------------
Line 1: import React, { useState, useEffect } from 'react';
        • Imports React and hooks

Line 2: function RenderCounter() {
        • Component declaration

Line 3: const [count, setCount] = useState(0);
        • Creates count state

Line 4: const [renderCount, setRenderCount] = useState(0);
        • Creates renderCount state to track renders

Line 5: (empty line)

Line 6: // This runs after EVERY render
        • Comment explaining the behavior

Line 7: useEffect(() => {
        • Starts useEffect hook
        • No dependency array provided

Line 8: console.log('Component rendered!');
        • Logs every time effect runs
        • Will log on every render

Line 9: setRenderCount(prev => prev + 1);
        • Updates renderCount using function form
        • Function form prevents issues with stale values
        • Increments render count

Line 10: }); // No dependency array
          • Closes useEffect
          • No dependency array means runs after every render

Line 11: (empty line)

Line 12-17: return (
              <div>
                <p>Count: {count}</p>
                <p>Renders: {renderCount}</p>
                <button onClick={() => setCount(count + 1)}>Increment Count</button>
              </div>
            );
         • Renders count and render count
         • Button increments count

WHAT HAPPENS (CAREFUL - INFINITE LOOP RISK!)
---------------------------------------------
1. Component renders (count = 0, renderCount = 0)
2. useEffect runs (no dependency array)
3. setRenderCount updates renderCount to 1
4. Component re-renders (because state changed)
5. useEffect runs AGAIN (no dependency array)
6. setRenderCount updates renderCount to 2
7. Component re-renders again
8. This continues... (potential infinite loop!)

NOTE: In this example, we use the function form of setState (prev => prev + 1) 
which helps, but the effect still runs on every render, which is usually not 
what you want.

EXAMPLE FROM ORIGINAL CONTENT
-----------------------------
As mentioned: "If you omit the dependency array entirely, the effect will run 
after every render, including the initial render and subsequent updates. This 
means that the effect will execute both after the initial render and after 
every rerender of the component, regardless of whether you change any values. 
This behavior with no dependency will cause the effect to run after every render."

WHEN THIS IS ACCEPTABLE
-----------------------
This pattern is acceptable when:
• The effect only reads values (doesn't update state)
• The effect performs side effects that should happen on every render
• You're intentionally syncing with every render

EXAMPLE (SAFE - NO STATE UPDATES)
----------------------------------
  function DocumentTitle({ title }) {
    useEffect(() => {
      // Safe: Only reads title, doesn't update state
      document.title = title;
    }); // Runs on every render to keep title in sync

    return <h1>{title}</h1>;
  }

WHY THIS IS USUALLY AVOIDED
---------------------------
• Performance: Runs unnecessarily
• Risk of infinite loops if state is updated
• Usually not what you want
• Better to specify dependencies explicitly

[END SECTION 3.4]
================================================================================

SECTION 3.5: COMPARING THE THREE DEPENDENCY SCENARIOS
------------------------------------------------------

SIDE-BY-SIDE COMPARISON
----------------------

SCENARIO 1: EMPTY ARRAY []
-------------------------
  useEffect(() => {
    // Code
  }, []);

WHEN IT RUNS:
• Once, after the first render
• Never again, even on re-renders

USE CASE:
• Fetch initial data
• Set up subscriptions once
• One-time initialization

EQUIVALENT TO:
• componentDidMount in class components

SCENARIO 2: WITH VALUES [value1, value2]
-----------------------------------------
  useEffect(() => {
    // Code
  }, [value1, value2]);

WHEN IT RUNS:
• After first render
• Whenever value1 OR value2 changes
• Not on other re-renders

USE CASE:
• Re-fetch when props change
• Update when state changes
• Sync with specific values

EQUIVALENT TO:
• componentDidUpdate with specific conditions

SCENARIO 3: NO ARRAY
--------------------
  useEffect(() => {
    // Code
  });

WHEN IT RUNS:
• After every render
• Initial render and all re-renders
• Regardless of what changed

USE CASE:
• Rare: Syncing with every render
• Debugging
• Effects that don't update state

EQUIVALENT TO:
• componentDidMount + componentDidUpdate combined

VISUAL COMPARISON
-----------------

RENDER 1: Component mounts
  [] → Runs once ✓
  [count] → Runs once ✓
  (none) → Runs once ✓

RENDER 2: count changes
  [] → Does NOT run ✗
  [count] → Runs (count changed) ✓
  (none) → Runs ✓

RENDER 3: Other state changes (count unchanged)
  [] → Does NOT run ✗
  [count] → Does NOT run (count didn't change) ✗
  (none) → Runs ✓

DECISION FLOWCHART
------------------
Need to run effect?
  ↓
When should it run?
  ├─ Only once on mount? → Use []
  ├─ When specific values change? → Use [value1, value2]
  └─ On every render? → Use no array (rare!)

QUICK REFERENCE
---------------
• [] → Run once on mount
• [dep] → Run when dep changes
• (none) → Run on every render

[END SECTION 3.5]
[END PART 3]
================================================================================

PART 4: COMMON SIDE EFFECT PATTERNS
================================================================================

SECTION 4.1: FETCHING DATA FROM AN API
---------------------------------------

PATTERN OVERVIEW
----------------
Fetching data from an API is one of the most common side effects. This pattern 
shows how to properly fetch data using useEffect.

BASIC PATTERN
-------------
  useEffect(() => {
    fetch('/api/data')
      .then(response => response.json())
      .then(data => {
        // Update state with data
      })
      .catch(error => {
        // Handle errors
      });
  }, []); // Empty array for one-time fetch

COMPLETE EXAMPLE WITH LOADING STATE
------------------------------------
  import React, { useState, useEffect } from 'react';

  function DataFetcher() {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
      // Set loading to true when starting fetch
      setLoading(true);
      setError(null);

      fetch('https://api.example.com/data')
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then(data => {
          setData(data);
          setLoading(false);
        })
        .catch(error => {
          setError(error.message);
          setLoading(false);
        });
    }, []); // Fetch once on mount

    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error}</div>;
    if (!data) return <div>No data</div>;

    return (
      <div>
        <h1>Data Loaded</h1>
        <pre>{JSON.stringify(data, null, 2)}</pre>
      </div>
    );
  }

EXPLANATION
-----------
• loading state tracks fetch progress
• error state handles errors
• data state stores fetched data
• Effect runs once on mount (empty array)
• Proper error handling included
• Loading and error states displayed

[END SECTION 4.1]
================================================================================

SECTION 4.2: SUBSCRIBING TO EVENTS
-----------------------------------

PATTERN OVERVIEW
----------------
Subscribing to events (like window resize, scroll, or custom events) requires 
setting up listeners and cleaning them up.

BASIC PATTERN WITH CLEANUP
---------------------------
  useEffect(() => {
    const handleEvent = () => {
      // Handle event
    };

    window.addEventListener('event', handleEvent);

    return () => {
      window.removeEventListener('event', handleEvent);
    };
  }, []);

COMPLETE EXAMPLE: WINDOW RESIZE
--------------------------------
  import React, { useState, useEffect } from 'react';

  function WindowSize() {
    const [windowSize, setWindowSize] = useState({
      width: window.innerWidth,
      height: window.innerHeight
    });

    useEffect(() => {
      const handleResize = () => {
        setWindowSize({
          width: window.innerWidth,
          height: window.innerHeight
        });
      };

      window.addEventListener('resize', handleResize);

      return () => {
        window.removeEventListener('resize', handleResize);
      };
    }, []); // Set up once

    return (
      <div>
        <p>Width: {windowSize.width}px</p>
        <p>Height: {windowSize.height}px</p>
      </div>
    );
  }

EXPLANATION
-----------
• Sets up resize listener on mount
• Updates state when window resizes
• Cleans up listener on unmount
• Prevents memory leaks

[END SECTION 4.2]
================================================================================

SECTION 4.3: MANIPULATING THE DOM
----------------------------------

PATTERN OVERVIEW
----------------
Sometimes you need to directly manipulate the DOM (like focusing an input or 
changing document title).

BASIC PATTERN
-------------
  useEffect(() => {
    // DOM manipulation
    document.title = 'New Title';
    
    return () => {
      // Cleanup if needed
    };
  }, []);

COMPLETE EXAMPLE: DOCUMENT TITLE
---------------------------------
  import React, { useState, useEffect } from 'react';

  function Page({ title }) {
    useEffect(() => {
      document.title = title;
    }, [title]); // Update when title changes

    return <h1>{title}</h1>;
  }

EXPLANATION
-----------
• Updates document title when component mounts
• Updates title when title prop changes
• No cleanup needed for this operation

[END SECTION 4.3]
================================================================================

SECTION 4.4: SETTING TIMERS
---------------------------

PATTERN OVERVIEW
----------------
Setting timers (setTimeout, setInterval) requires cleanup to prevent memory 
leaks and unexpected behavior.

BASIC PATTERN WITH CLEANUP
---------------------------
  useEffect(() => {
    const timer = setInterval(() => {
      // Timer code
    }, 1000);

    return () => {
      clearInterval(timer);
    };
  }, []);

COMPLETE EXAMPLE: COUNTDOWN TIMER
----------------------------------
  import React, { useState, useEffect } from 'react';

  function Countdown({ initialSeconds }) {
    const [seconds, setSeconds] = useState(initialSeconds);

    useEffect(() => {
      if (seconds <= 0) return;

      const timer = setInterval(() => {
        setSeconds(prev => prev - 1);
      }, 1000);

      return () => {
        clearInterval(timer);
      };
    }, [seconds]); // Re-setup when seconds changes

    return <div>Time remaining: {seconds}s</div>;
  }

EXPLANATION
-----------
• Sets up interval timer
• Decrements seconds every second
• Cleans up interval on unmount or when seconds changes
• Prevents timer from running after component unmounts

[END SECTION 4.4]
================================================================================

SECTION 4.5: CLEANUP IN USEEFFECT
----------------------------------

WHY CLEANUP IS IMPORTANT
------------------------
Cleanup functions prevent:
• Memory leaks
• Stale closures
• Unnecessary operations
• Bugs from effects running after unmount

HOW CLEANUP WORKS
-----------------
  useEffect(() => {
    // Setup code
    
    return () => {
      // Cleanup code
    };
  }, [dependencies]);

WHEN CLEANUP RUNS
-----------------
Cleanup runs:
• Before the effect runs again (if dependencies changed)
• When the component unmounts
• Before React re-runs the effect

COMPLETE EXAMPLE: SUBSCRIPTION WITH CLEANUP
---------------------------------------------
  import React, { useState, useEffect } from 'react';

  function ChatRoom({ roomId }) {
    const [messages, setMessages] = useState([]);

    useEffect(() => {
      // Subscribe to room
      const subscription = subscribeToRoom(roomId, (message) => {
        setMessages(prev => [...prev, message]);
      });

      // Cleanup: unsubscribe when done
      return () => {
        unsubscribeFromRoom(subscription);
      };
    }, [roomId]); // Re-subscribe if roomId changes

    return (
      <div>
        <h2>Room: {roomId}</h2>
        {messages.map(msg => (
          <div key={msg.id}>{msg.text}</div>
        ))}
      </div>
    );
  }

EXPLANATION
-----------
• Subscribes when component mounts or roomId changes
• Unsubscribes before re-subscribing or on unmount
• Prevents memory leaks and duplicate subscriptions

[END SECTION 4.5]
[END PART 4]
================================================================================

SUMMARY OF PART 1
-----------------
In Part 1, we covered:
• What side effects are and why they're needed
• How useEffect works in React
• Complete example of fetching food items with line-by-line explanation
• Three dependency scenarios: empty array, with values, and no array
• Common side effect patterns and cleanup

In Part 2, we'll cover:
• Introduction to custom hooks
• Creating custom hooks
• Complete UseToggle example with line-by-line explanation
• Advanced custom hook patterns
• Best practices for custom hooks

================================================================================
END OF PART 1
================================================================================

Author(s)
---------
Based on original content about Side Effects Management and Custom Hooks

Original Content Maintained
----------------------------
All original definitions, explanations, and concepts from the source material 
have been preserved and expanded upon in this comprehensive guide.

