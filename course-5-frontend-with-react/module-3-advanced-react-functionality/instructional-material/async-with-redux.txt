Welcome to Async with Redux. After watching this video, you will be able to Explain the differences between synchronous and asynchronous operations Explain challenges with asynchronous operations in Redux Provide examples of complications posed by asynchronous operations Describe how you can use Thunk and Saga to handle async Compare and contrast Thunk and Saga's pros and cons Code that operates in a synchronous or sync fashion Implies that, given two operations, one operation must complete execution Before the second one begins If your code has two operations and the first operation starts It blocks the second operation until the first operation finishes Asynchronous or async operations run in parallel This means that a second operation can begin execution While the first is still being processed The situation dictates which behavior you need You will generally prefer asynchronous behavior When you don't want an operation to prevent the user From continuing to use the application So operations such as network requests, memory-intensive calculations And loading large files should usually be performed asynchronously These operations can run in the background While the user completes other tasks Synchronous behavior can also pose problems Situations often require processing events one after another For example, if the user wants to add two items to a cart They first need to enter the number of items they want Then click the Add to Cart button to update the cart If the Add to Cart button event occurs before updating the number of items An incorrect number may be added In this case, you prefer synchronous behavior JavaScript behaves asynchronously However, state management in Redux requires synchronous behavior Recall the sequence of a Redux state change It begins with a call to an ActionCreator function Which returns an Action object Next, the Action object is dispatched to the store Then the store calls the appropriate reducer Based on the Action object's type property Consequently, the reducer updates the state object Dispatching actions sometimes requires asynchronous operations For example, say your user needs the application to fetch data from the server If the application behaved in a synchronous manner It would block the user from any other interactions with the application Until the server returns that data Causing a frustrating user experience In this case, you want to dispatch operations asynchronously To manage the application's states and maintain responsiveness Though required, actions and reducers will not suffice to handle this asynchronous behavior Middleware allows you to interact with asynchronous data To perform state changes, you use actions provided by the store If necessary, the middleware intercepts the actions and delays them to support asynchronous behavior Once the asynchronous process is complete The rest of the Redux flow continues as usual Where the reducer receives the action type to compute the new state The final action dispatch restores the synchronous data flow Let's discuss the two most popular middlewares used with Redux to support asynchronous behavior Thunk and Saga Recall that action creators return an action object With Thunk, the action creators also return functions These functions allow you to interact with the Redux store These functions can perform async operations Such as API calls, as well as synchronous ones from within functions The store then dispatches actions based on the results Thunk middleware is suitable for simple applications and relatively easy to learn However, concurrency issues within Thunk require careful consideration Nor does Thunk scale well if your application grows Another middleware option for handling async operations is Redux Saga It uses special functions introduced in ES6 called generators These generator functions, called Sagas, allow you to encapsulate logic for handling asynchronous operations Sagas can multitask with the Redux store dispatch process by pausing and resuming execution as needed Sagas include several features to make testing and debugging easy They are pure functions that enable time travel and complex flow logging Sagas also scales well as your application grows In turn, the robust nature of Saga middleware makes it more complicated to learn An in-depth understanding of generators is required to use them well In this video, you learned that Synchronous operations block the next operation until the previous one finishes Asynchronous operations can run in parallel JavaScript behaves asynchronously, but Redux architecture requires synchronous behavior Thunk action creators return functions that allow you to perform sync and async operations Thunk middleware is suitable for simple applications and relatively easy to learn Thunk does not scale well and requires planning to handle concurrency issues Saga uses generator functions, which allow you to multitask in conjunction with the Redux store dispatch process by pausing and resuming execution as needed Saga includes numerous features that make testing and debugging easy The robust nature of Saga makes it more complicated to learn, requiring an in-depth understanding of generators