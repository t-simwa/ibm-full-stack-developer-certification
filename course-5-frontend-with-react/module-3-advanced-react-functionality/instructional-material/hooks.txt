Welcome to Hooks. After watching this video, you will be able to explain the purpose of using Hooks, list the advantages of Hooks, summarize best practices for Hook development, and contrast standard and custom Hooks. Introduced in React version 16.8, Hooks alleviate many challenges posed by writing class components. Hooks provide a way to write functional components with the same capabilities as class components. Namely, you can access a component state using Hooks with function components. The component preserves its state when it updates and re-renders. So now, function components provide the same functionality as class components, with less complexity in the code. As the name suggests, they enable you to hook into React state and lifecycle features from function components. You can even write customized hooks. You can write a custom hook for multiple components instead of duplicating code from one component to another. Advantages of using Hooks include easier to read code. Your code chunks become more manageable in size. Hooks help to optimize your code, enabling you to write code producing complex behaviors in the UI. They simplify your code. Hooks help you handle events and subsequent logic without classes. Hooks also provide a performance boost to your components. Now let's discuss some best practices when using Hooks. You can only use Hooks exclusively with function components. You must call a hook at the top level of a component tree. In other words, you cannot call hooks within child components. You cannot call a hook from a normal JavaScript function. You cannot call hooks inside loops, conditional statements, or nested functions. Regarding versioning, Hooks require the Node.js version 6 JavaScript platform. In addition, they use the Node Package Manager, NPM, version 5.2 or higher. You should use the npm create vite@latest my-app --template react tool to set up your React app using Vite. It simplifies configuration and the need for multiple build tools and automatically optimizes your app. Let's explore some of the most commonly used hooks. The UseState hook allows you to access the state of the component in your function component. The UseEffect hook manages side effects such as document changes and HTTP requests. You will use it if you need to fetch data from a database. The UseContext hook manages context changes and provides access to a context. The UseReducer hook manages redux state changes. Like a light form of Redux, this hook provides a dispatch function and a state while taking a reducer and an initial state. You will learn more about the Redux library in another lesson. Custom React hooks let you add unique functionality to your React applications. You name custom with use as a prefix. For example, you could create custom hooks named UseLocalStorage or UseAuthentication. A custom hook is a new composition of one or multiple hooks. Since you can treat hooks as functions, they have the same features. You can reuse and combine them as needed. In this code example, this code imports the UseState hook to access the component's local state. This hook returns and assigns values with a destructed array. The current count state is the first array element and the second variable sets the count, allowing you to make updates. The initial count is passed as a parameter in the UseState hook function. After that, you call this function from an event handler to utilize it. In this video, you learned that hooks provide function components with the same capabilities as class components. Hooks enable you to write simpler, more readable, and a lesser amount of code, providing more complex behaviors and improving performance. You must call hooks at the top of the tree and cannot call them from regular or nested functions or inside loops or conditions. Standard hooks include UseState, UseEffect, UseContext, and UseReducer. And finally, you can add unique functionality using custom hooks.