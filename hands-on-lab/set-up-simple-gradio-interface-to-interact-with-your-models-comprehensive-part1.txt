================================================================================
SET UP A SIMPLE GRADIO INTERFACE TO INTERACT WITH YOUR MODELS
Comprehensive Study Guide - Part 1
================================================================================

WELCOME
-------
Welcome to "Set Up a Simple Gradio Interface to Interact with Your Models"! This 
comprehensive guide will teach you everything you need to know about building 
interactive web interfaces for Large Language Models (LLMs) using Gradio. You'll 
learn how to create user-friendly front-end interfaces that allow users to 
interact with backend LLMs seamlessly, without needing any technical expertise.

This guide is designed to take you from beginner to proficient in building Gradio 
interfaces, ensuring you understand every concept deeply and can apply it 
confidently. We'll cover everything from the fundamentals of Gradio to building 
a complete functional chatbot that integrates with IBM watsonx.ai models.

ESTIMATED TIME NEEDED
---------------------
Original lab time: 30 minutes
Comprehensive study: 2-3 hours (with all examples and practice)
Full mastery: 4-5 hours (including experimentation and extensions)

LEARNING OBJECTIVES
-------------------
By the end of this comprehensive guide, you will be able to:

• Use Gradio to build interactive front-end interfaces, enabling users to interact 
  with backend LLMs seamlessly
  - Understand what Gradio is and why it's useful
  - Learn how to create basic Gradio interfaces
  - Master essential Gradio components (text inputs, buttons, displays)
  - Customize interfaces to meet specific needs

• Create a functional chatbot, allowing users to input queries and receive 
  responses from an LLM
  - Integrate Gradio with IBM watsonx.ai models
  - Build a complete Q&A chatbot application
  - Handle user inputs and display model outputs
  - Deploy and test your chatbot interface

• Implement essential and commonly used Gradio elements, such as text input fields, 
  buttons, and display areas, to enhance the users' experience
  - Understand different Gradio component types
  - Learn when to use each component
  - Customize component properties
  - Create intuitive user interfaces

• Customize and deploy web-based applications, facilitating various use cases 
  including customer support, data analysis, and others
  - Understand deployment options
  - Learn best practices for interface design
  - Explore different application types
  - Extend functionality for specific use cases

OVERVIEW
--------
Imagine you're developing a customer support chatbot for a company. The goal is 
to provide a seamless and interactive way for customers to get answers to their 
questions. To achieve this goal, you need an interface where users can input 
their queries and receive responses generated by a large language model (LLM). 
This lab guides you through the creation of such an interface using Gradio. 
You'll learn how to integrate various Gradio components, including text input 
fields, buttons, and display elements, to create an intuitive and user-friendly 
customer support experience.

WHY CREATING AN INTERFACE IS CRUCIAL
------------------------------------
Creating an interface is crucial for several reasons:

1. USER ACCESSIBILITY
   • A front-end interface makes it easy for users to interact with the LLM 
     without needing technical expertise
   • Users don't need to know Python, command-line interfaces, or API calls
   • Non-technical users can access AI capabilities through a simple web interface
   • Example: A customer service representative can use a chatbot interface 
     without understanding how the underlying LLM works

2. ENHANCED USER EXPERIENCE
   • An intuitive interface can provide a better user experience, making 
     interactions smoother and more efficient
   • Visual feedback helps users understand what's happening
   • Clean, organized interfaces reduce confusion and errors
   • Example: A well-designed chatbot interface guides users on how to ask 
     questions effectively

3. CUSTOMIZATION
   • Gradio allows you to customize the interface to meet specific needs, 
     whether for a chatbot, a data analysis tool, or other applications
   • You can add branding, specific layouts, and custom functionality
   • Different use cases require different interface designs
   • Example: A customer support chatbot might need a different layout than a 
     data analysis tool

4. SEAMLESS INTEGRATION
   • Gradio's flexibility enables you to seamlessly integrate the front-end 
     with various backend technologies, including LLMs
   • Works with multiple LLM providers (IBM watsonx.ai, OpenAI, Hugging Face, etc.)
   • Easy to swap backend models without changing the interface
   • Example: You can switch from one LLM model to another without redesigning 
     the entire interface

WHAT YOU'LL BUILD
-----------------
By the end of this guide, you'll have created:

• A simple Gradio demo application (sum calculator)
  - Learn basic Gradio concepts
  - Understand how to create inputs and outputs
  - See how functions connect to interfaces

• A functional LLM chatbot interface
  - Integrate IBM watsonx.ai models
  - Create a question-answering interface
  - Handle user queries and display responses

• Knowledge of essential Gradio components
  - Text inputs and outputs
  - Number inputs
  - Buttons and controls
  - Customization options

================================================================================
TABLE OF CONTENTS - PART 1
================================================================================

This part covers the introduction, setup, and Gradio basics:

PART 1: INTRODUCTION AND OVERVIEW
  SECTION 1.1: WHAT IS GRADIO?
  SECTION 1.2: WHY USE GRADIO?
  SECTION 1.3: GRADIO USE CASES

PART 2: SETTING UP YOUR DEVELOPMENT ENVIRONMENT
  SECTION 2.1: UNDERSTANDING VIRTUAL ENVIRONMENTS
  SECTION 2.2: CREATING A VIRTUAL ENVIRONMENT
  SECTION 2.3: ACTIVATING YOUR VIRTUAL ENVIRONMENT
  SECTION 2.4: UNDERSTANDING THE REQUIRED LIBRARIES
  SECTION 2.5: INSTALLING REQUIRED LIBRARIES
  SECTION 2.6: VERIFYING INSTALLATIONS

PART 3: GRADIO QUICK TUTORIAL
  SECTION 3.1: GRADIO OVERVIEW AND CONCEPTS
  SECTION 3.2: CREATING YOUR FIRST GRADIO DEMO
  SECTION 3.3: UNDERSTANDING GRADIO INTERFACE COMPONENTS
  SECTION 3.4: BUILDING A SUM CALCULATOR DEMO
  SECTION 3.5: LAUNCHING AND TESTING YOUR DEMO
  SECTION 3.6: PRACTICE EXERCISE - SENTENCE COMBINER

NOTE: Part 2 of this guide covers:
  • Understanding LLMs and IBM watsonx.ai
  • Building a simple LLM application
  • Integrating Gradio with LLMs
  • Creating a complete chatbot interface
  • Advanced customization and exercises

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 1.3:") to quickly jump to any section.

================================================================================
PART 1: INTRODUCTION AND OVERVIEW
================================================================================

Before we start building, it's crucial to understand what Gradio is, why we use 
it, and what problems it solves. This foundation will help you make better 
decisions when building your interfaces and troubleshooting issues.

SECTION 1.1: WHAT IS GRADIO?
-----------------------------

OVERVIEW
--------
Gradio is a powerful and user-friendly Python library for creating customizable 
web-based interfaces. It enables developers to effortlessly transform their 
algorithms and machine learning models into accessible, interactive applications.

DEFINITION
----------
Gradio is a Python library that allows you to quickly create web interfaces for 
your machine learning models and Python functions. You can use Gradio to create 
a web interface that seamlessly bridges the gap between machine learning models 
and end-user interactions.

WHAT GRADIO DOES
----------------
Gradio enables developers to effortlessly transform their algorithms into 
accessible, interactive applications. With Gradio, you can quickly design web 
interfaces where users can input data in various formats including text, images, 
or audio, and instantly view the output generated by your model.

KEY FEATURES OF GRADIO
----------------------
1. EASY TO USE
   • Simple Python API - no HTML, CSS, or JavaScript knowledge required
   • Can create interfaces in just a few lines of code
   • Intuitive component-based design

2. FLEXIBLE INPUT/OUTPUT TYPES
   • Text inputs and outputs
   • Number inputs
   • Images (upload and display)
   • Audio (record and play)
   • Video
   • Dataframes (tables)
   • And many more

3. AUTOMATIC UI GENERATION
   • Gradio automatically generates a web interface
   • No need to write front-end code
   • Responsive design out of the box

4. EASY DEPLOYMENT
   • Can run locally or share publicly
   • One-line deployment to Hugging Face Spaces
   • Can be embedded in websites

5. INTERACTIVE AND REAL-TIME
   • Users can interact with your model in real-time
   • Instant feedback on inputs
   • No need to reload pages

REAL-WORLD ANALOGY
------------------
Think of Gradio like a restaurant menu:

• Your Python function or ML model = The kitchen (where the work happens)
• Gradio = The menu and ordering system (how customers interact)
• The web interface = The dining room (where customers experience the service)

Just like a restaurant needs a way for customers to order food (menu) and receive 
it (service), your ML model needs a way for users to provide inputs (interface) 
and receive outputs (display). Gradio provides that "menu and service" layer 
between your users and your models.

HOW GRADIO WORKS - THE BASIC FLOW
----------------------------------
1. You write a Python function that does something (e.g., processes text, 
   makes predictions)
2. You tell Gradio what inputs your function needs (e.g., text box, number input)
3. You tell Gradio what outputs your function produces (e.g., text response, 
   image)
4. Gradio creates a web interface automatically
5. Users interact with the interface, which calls your function
6. Results are displayed back to the user

EXAMPLE FLOW
------------
Let's say you have a function that translates English to Spanish:

Function: translate_english_to_spanish(english_text)
Input: English text (user types in a text box)
Output: Spanish text (displayed in another text box)

Gradio creates:
- A text input box labeled "English Text"
- A button to submit
- A text output box labeled "Spanish Translation"
- The web interface that connects everything

When a user types "Hello" and clicks submit:
1. Gradio captures the input "Hello"
2. Calls your function: translate_english_to_spanish("Hello")
3. Gets the result: "Hola"
4. Displays "Hola" in the output box

[END SECTION 1.1]
================================================================================

SECTION 1.2: WHY USE GRADIO?
-----------------------------

OVERVIEW
--------
Understanding why Gradio is useful will help you appreciate its value and know 
when to use it in your projects.

ADVANTAGES OF USING GRADIO
---------------------------

1. SPEED OF DEVELOPMENT
   • Create interfaces in minutes, not hours or days
   • No need to learn web development (HTML, CSS, JavaScript)
   • Focus on your model/function, not the interface code
   • Example: A simple chatbot interface can be created in under 10 lines of code

2. NO FRONT-END EXPERTISE REQUIRED
   • Python developers can create web interfaces without learning new languages
   • No need for separate front-end and back-end developers
   • One person can build the entire application
   • Example: A data scientist can create a demo without hiring a web developer

3. RAPID PROTOTYPING
   • Quickly test how users interact with your model
   • Get feedback early in the development process
   • Iterate quickly on interface design
   • Example: Test different input formats before building a production system

4. DEMONSTRATION AND SHARING
   • Easy to share your work with others
   • Non-technical stakeholders can interact with your models
   • Great for presentations and demos
   • Example: Show your manager a working prototype during a meeting

5. STANDARDIZED COMPONENTS
   • Pre-built components for common use cases
   • Consistent look and feel
   • Less time spent on styling and layout
   • Example: Text inputs, buttons, and displays all work the same way

6. INTEGRATION WITH ML ECOSYSTEM
   • Works seamlessly with popular ML frameworks (TensorFlow, PyTorch, etc.)
   • Easy integration with LLM APIs (OpenAI, Hugging Face, IBM watsonx.ai)
   • Compatible with LangChain and other ML tools
   • Example: Can easily connect to IBM watsonx.ai models

WHEN TO USE GRADIO
------------------

USE GRADIO WHEN:
• You want to quickly create a demo or prototype
• You need a simple interface for testing your model
• You want to share your work with non-technical users
• You're building an internal tool or dashboard
• You need rapid iteration on interface design
• You want to focus on the model, not the interface

CONSIDER ALTERNATIVES WHEN:
• You need a highly customized, production-grade interface
• You require complex user interactions or workflows
• You need advanced styling and branding
• You're building a large-scale commercial application
• You have specific security or compliance requirements

COMPARISON WITH OTHER TOOLS
----------------------------

GRADIO vs. STREAMLIT
• Gradio: Better for ML model demos, simpler API
• Streamlit: Better for data apps, more components for data visualization

GRADIO vs. CUSTOM WEB APP (Flask/Django)
• Gradio: Faster to build, less flexible
• Custom web app: More control, requires more development time

GRADIO vs. JUPYTER NOTEBOOKS
• Gradio: Interactive web interface, shareable
• Jupyter: Good for exploration, but not as user-friendly for end users

[END SECTION 1.2]
================================================================================

SECTION 1.3: GRADIO USE CASES
------------------------------

OVERVIEW
--------
Gradio can be used for many different types of applications. Understanding these 
use cases will help you see the full potential of Gradio and inspire your own 
projects.

COMMON USE CASES
----------------

1. CHATBOTS AND Q&A SYSTEMS
   • Customer support chatbots
   • FAQ answering systems
   • Educational Q&A bots
   • Example: A chatbot that answers questions about company policies

2. TEXT PROCESSING APPLICATIONS
   • Text summarization tools
   • Translation services
   • Sentiment analysis
   • Grammar checking
   • Example: A tool that summarizes long documents

3. IMAGE PROCESSING APPLICATIONS
   • Image classification
   • Object detection
   • Image generation
   • Style transfer
   • Example: An app that identifies objects in photos

4. DATA ANALYSIS TOOLS
   • Data visualization dashboards
   • Statistical analysis interfaces
   • Report generators
   • Example: A tool that analyzes sales data and generates reports

5. CREATIVE APPLICATIONS
   • Text-to-image generators
   • Music generators
   • Story generators
   • Example: An app that generates stories based on prompts

6. EDUCATIONAL TOOLS
   • Interactive tutorials
   • Learning assistants
   • Quiz generators
   • Example: A tool that helps students learn by answering questions

7. BUSINESS APPLICATIONS
   • Document processors
   • Email analyzers
   • Meeting summarizers
   • Example: A tool that summarizes meeting transcripts

REAL-WORLD EXAMPLE: CUSTOMER SUPPORT CHATBOT
---------------------------------------------
In this lab, we're building a customer support chatbot. Here's how it fits into 
the real world:

SCENARIO:
A company receives hundreds of customer support questions daily. Instead of 
having human agents answer each question, they want an AI chatbot that can 
handle common questions automatically.

SOLUTION WITH GRADIO:
1. Build an LLM-powered chatbot using IBM watsonx.ai
2. Create a Gradio interface for customers to interact with
3. Customers type questions, chatbot provides answers
4. Human agents only handle complex cases

BENEFITS:
• 24/7 availability
• Instant responses
• Consistent answers
• Reduced workload for human agents
• Better customer experience

[END SECTION 1.3]
================================================================================

PART 2: SETTING UP YOUR DEVELOPMENT ENVIRONMENT
================================================================================

Before we can start building Gradio interfaces, we need to set up our development 
environment properly. This involves creating a virtual environment and installing 
the necessary libraries.

SECTION 2.1: UNDERSTANDING VIRTUAL ENVIRONMENTS
------------------------------------------------

OVERVIEW
--------
A virtual environment is an isolated Python environment that allows you to manage 
dependencies for different projects separately. This is crucial for avoiding 
conflicts between package versions.

WHAT IS A VIRTUAL ENVIRONMENT?
-------------------------------
A virtual environment is like a separate workspace for each project. Just like 
you might have different toolboxes for different types of work (one for 
plumbing, one for electrical work), virtual environments let you have different 
sets of Python packages for different projects.

WHY DO WE NEED VIRTUAL ENVIRONMENTS?
-------------------------------------
Using a virtual environment allows you to manage dependencies for different 
projects separately, avoiding conflicts between package versions.

PROBLEMS WITHOUT VIRTUAL ENVIRONMENTS:
• Project A needs Gradio version 4.44.0
• Project B needs Gradio version 5.0.0
• Installing one breaks the other
• All projects share the same packages, causing conflicts

SOLUTION WITH VIRTUAL ENVIRONMENTS:
• Each project has its own isolated environment
• Project A can have Gradio 4.44.0
• Project B can have Gradio 5.0.0
• No conflicts between projects
• Each project has exactly what it needs

REAL-WORLD ANALOGY
-------------------
Think of virtual environments like separate apartments in a building:

• Your computer = The building
• System Python = The shared lobby (everyone uses it)
• Virtual environments = Individual apartments (each project has its own)
• Packages = Furniture and appliances (each apartment can have different ones)

Just like you wouldn't want all your neighbors using your furniture, you don't 
want all your projects sharing the same Python packages.

BENEFITS OF VIRTUAL ENVIRONMENTS
---------------------------------
1. ISOLATION
   • Each project has its own packages
   • Changes in one project don't affect others
   • No version conflicts

2. REPRODUCIBILITY
   • Easy to recreate the exact environment
   • Can share requirements files
   • Consistent across different machines

3. CLEAN ORGANIZATION
   • Easy to see what each project needs
   • Can remove entire environments when done
   • Clear separation of concerns

4. EASIER DEPLOYMENT
   • Know exactly what packages are needed
   • Can replicate environment in production
   • Fewer "it works on my machine" issues

[END SECTION 2.1]
================================================================================

SECTION 2.2: CREATING A VIRTUAL ENVIRONMENT
--------------------------------------------

OVERVIEW
--------
Now that we understand why virtual environments are important, let's create one 
for our Gradio project.

STEP-BY-STEP INSTRUCTIONS
--------------------------

STEP 1: OPEN YOUR TERMINAL
---------------------------
In the terminal of your Cloud IDE, verify that you are in the path /home/project.

NOTE FOR CLOUD IDE USERS:
A terminal window should be open by default in the lower part of your Cloud IDE 
environment. If it is not, go to Terminal → New Terminal in the menu bar at the 
top in order to open a new terminal window.

NOTE FOR LOCAL IDE USERS (VS Code, PyCharm, etc.):
• Open the integrated terminal in your IDE
• Navigate to your project directory
• On Windows: Use PowerShell or Command Prompt
• On Mac/Linux: Use Terminal

STEP 2: VERIFY YOUR CURRENT LOCATION
-------------------------------------
Before creating the virtual environment, make sure you're in the right directory.

Command to check current directory:
• Linux/Mac: pwd
• Windows: cd (without arguments)

You should be in your project directory (e.g., /home/project or 
C:\Users\YourName\Desktop\project).

STEP 3: INSTALL VIRTUALENV (IF NOT ALREADY INSTALLED)
------------------------------------------------------
First, we need to install the virtualenv package, which provides the tool to 
create virtual environments.

Command:
pip install virtualenv

WHAT THIS COMMAND DOES:
• pip = Python's package installer
• install = Command to install a package
• virtualenv = The package we want to install

This installs the virtualenv tool globally on your system, which allows you to 
create virtual environments.

EXPLANATION:
The virtualenv package is a tool that helps create isolated Python environments. 
Once installed, you can use it to create as many virtual environments as you need 
for different projects.

STEP 4: CREATE THE VIRTUAL ENVIRONMENT
---------------------------------------
Now we'll create a virtual environment named "my_env".

Command:
virtualenv my_env

WHAT THIS COMMAND DOES:
• virtualenv = The command to create a virtual environment
• my_env = The name we're giving to our virtual environment

This creates a new directory called "my_env" that contains:
• A copy of Python
• A pip installer
• A place to install packages (isolated from your system)

EXPLANATION:
When you run this command, virtualenv creates a folder called "my_env" in your 
current directory. Inside this folder, it sets up a complete, isolated Python 
environment. You can name it anything you want (e.g., "gradio_env", "chatbot_env"), 
but "my_env" is a simple, generic name.

WHAT HAPPENS BEHIND THE SCENES:
1. Creates a directory called "my_env"
2. Copies Python interpreter into it
3. Sets up pip (package installer) in the environment
4. Creates activation scripts (for different operating systems)
5. Isolates this environment from your system Python

VERIFYING THE CREATION:
After running the command, you should see the "my_env" folder in your directory. 
You can verify this by listing files:

• Linux/Mac: ls
• Windows: dir

You should see "my_env" in the list of files/folders.

[END SECTION 2.2]
================================================================================

SECTION 2.3: ACTIVATING YOUR VIRTUAL ENVIRONMENT
------------------------------------------------

OVERVIEW
--------
Creating a virtual environment is only the first step. Before you can use it, 
you need to activate it. Activation tells your terminal to use the Python and 
packages from the virtual environment instead of your system Python.

WHY ACTIVATION IS NECESSARY
---------------------------
When you activate a virtual environment, you're telling your terminal:
• Use the Python interpreter from this environment
• Use the packages installed in this environment
• Install new packages into this environment (not system-wide)

Without activation, you're still using your system Python, which defeats the 
purpose of having a virtual environment.

STEP-BY-STEP ACTIVATION
-----------------------

FOR LINUX/MAC USERS:
--------------------
Command:
source my_env/bin/activate

WHAT THIS COMMAND DOES:
• source = Command to execute a script in the current shell
• my_env/bin/activate = The activation script for Linux/Mac

After running this command, you should see "(my_env)" at the beginning of your 
terminal prompt, indicating that the virtual environment is active.

EXAMPLE PROMPT CHANGE:
Before activation:
user@computer:~/project$

After activation:
(my_env) user@computer:~/project$

The "(my_env)" prefix shows that you're working in the virtual environment.

FOR WINDOWS USERS (POWERSHELL):
-------------------------------
Command:
my_env\Scripts\Activate.ps1

If you get an execution policy error, you may need to run:
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser

Then try activating again:
my_env\Scripts\Activate.ps1

FOR WINDOWS USERS (COMMAND PROMPT):
-----------------------------------
Command:
my_env\Scripts\activate.bat

After activation, you should see "(my_env)" at the beginning of your prompt.

VERIFYING ACTIVATION
--------------------
To verify that your virtual environment is activated, you can:

1. Check the prompt - it should show "(my_env)" at the beginning
2. Check which Python is being used:
   • Linux/Mac: which python
   • Windows: where python
   
   This should point to your virtual environment's Python, not the system Python.

3. Check Python location:
   python -c "import sys; print(sys.executable)"
   
   This should show a path that includes "my_env".

DEACTIVATING THE VIRTUAL ENVIRONMENT
-------------------------------------
When you're done working, you can deactivate the environment:

Command:
deactivate

This removes the "(my_env)" prefix and returns you to using your system Python.

IMPORTANT NOTES
---------------
• You need to activate the environment every time you open a new terminal
• The activation only affects the current terminal session
• If you close the terminal, you'll need to activate again
• Always verify activation before installing packages

[END SECTION 2.3]
================================================================================

SECTION 2.4: UNDERSTANDING THE REQUIRED LIBRARIES
--------------------------------------------------

OVERVIEW
--------
Before installing libraries, it's important to understand what each library does 
and why we need it. This understanding will help you troubleshoot issues and 
make informed decisions about your project.

THE LIBRARIES WE NEED
---------------------

1. GRADIO (gradio==4.44.0)
   Purpose: Creating user-friendly web interfaces
   
   What it does:
   • Allows you to build interactive web applications quickly
   • Makes your AI models accessible to users with ease
   • Provides pre-built UI components (text boxes, buttons, etc.)
   • Handles the web server and user interface automatically
   
   Why we need it:
   • This is the main library for creating our chatbot interface
   • Without Gradio, we'd need to build a web interface from scratch
   • It's specifically designed for ML/AI applications
   
   Real-world analogy:
   Think of Gradio as the "restaurant front-of-house" - it's what customers see 
   and interact with, while your Python functions are the "kitchen" doing the 
   actual work.

2. PYDANTIC (pydantic==2.10.6)
   Purpose: Data validation using Python type annotations
   
   What it does:
   • Validates data types and structures
   • Ensures data integrity
   • Provides clear error messages for invalid data
   
   Why we need it:
   • Gradio and LangChain use Pydantic for data validation
   • Ensures that inputs and outputs are in the correct format
   • Prevents errors from invalid data types
   
   Note: This is a dependency (required by other libraries), not something we 
   use directly in our code.

3. IBM WATSONX.AI (ibm-watsonx-ai==1.1.2)
   Purpose: Using LLMs from IBM's watsonx.ai platform
   
   What it does:
   • Provides access to IBM's watsonx.ai API
   • Allows you to use various LLM models (Granite, Mistral, etc.)
   • Handles authentication and API calls
   • Manages model parameters and configurations
   
   Why we need it:
   • We need an LLM to power our chatbot
   • IBM watsonx.ai provides access to powerful models
   • This library is the interface to those models
   
   Real-world analogy:
   Think of this as the "power company" - it provides the "electricity" (LLM 
   capabilities) that powers your application.

4. LANGCHAIN (langchain==0.2.11)
   Purpose: Framework for building applications with LLMs
   
   What it does:
   • Provides tools for working with LLMs
   • Simplifies prompt engineering
   • Enables chaining operations together
   • Provides abstractions for different LLM providers
   
   Why we need it:
   • Makes it easier to work with LLMs
   • Provides consistent interface across different models
   • Simplifies integration with IBM watsonx.ai
   
   Real-world analogy:
   Think of LangChain as a "universal adapter" - it lets you use different LLM 
   providers (IBM, OpenAI, etc.) with the same code.

5. LANGCHAIN-COMMUNITY (langchain-community==0.2.10)
   Purpose: Community-contributed integrations for LangChain
   
   What it does:
   • Provides additional integrations and tools
   • Extends LangChain's capabilities
   • Includes community-maintained components
   
   Why we need it:
   • Required by LangChain for certain features
   • Provides additional functionality we might need
   
   Note: This is a dependency, not something we use directly.

6. LANGCHAIN-IBM (langchain-ibm==0.1.11)
   Purpose: Integration between LangChain and IBM watsonx.ai
   
   What it does:
   • Bridges LangChain and IBM watsonx.ai
   • Provides WatsonxLLM class for LangChain
   • Handles the connection between the two systems
   
   Why we need it:
   • Allows LangChain to work with IBM watsonx.ai models
   • Without this, we couldn't use IBM models with LangChain
   • Provides the WatsonxLLM wrapper we'll use
   
   Real-world analogy:
   Think of this as a "translator" - it translates between LangChain's language 
   and IBM watsonx.ai's language so they can work together.

7. HUGGINGFACE_HUB (huggingface_hub==0.23.0)
   Purpose: Accessing models and datasets from Hugging Face
   
   What it does:
   • Provides tools to interact with Hugging Face Hub
   • Can download models and datasets
   • Handles authentication for Hugging Face
   
   Why we need it:
   • Some components might use Hugging Face models
   • Required for certain LangChain features
   • Useful for accessing pre-trained models
   
   Note: We might not use this directly, but it's required by other libraries.

UNDERSTANDING VERSION NUMBERS
-----------------------------
Notice that each library has a specific version number (e.g., "gradio==4.44.0"). 
This is called "version pinning" and it's important because:

• Ensures compatibility: Different versions may have different features or APIs
• Prevents breaking changes: Newer versions might break our code
• Reproducibility: Anyone following this guide gets the same versions
• Stability: We know these versions work together

The format is: package_name==version_number
• package_name: The name of the library
• ==: Exact version match
• version_number: The specific version (major.minor.patch)

[END SECTION 2.4]
================================================================================

SECTION 2.5: INSTALLING REQUIRED LIBRARIES
-------------------------------------------

OVERVIEW
--------
Now that we understand what each library does, let's install them. We'll install 
all the required libraries in one command to ensure they're all installed together 
and compatible.

IMPORTANT PREREQUISITE
----------------------
Before installing, make sure:
1. Your virtual environment is activated (you should see "(my_env)" in your prompt)
2. You're in your project directory
3. You have an internet connection

THE INSTALLATION COMMAND
------------------------
Still using your terminal connection (with my_env activated), install the following 
packages:

Command:
python3.11 -m pip install \
gradio==4.44.0 \
pydantic==2.10.6 \
ibm-watsonx-ai==1.1.2 \
langchain==0.2.11 \
langchain-community==0.2.10 \
langchain-ibm==0.1.11 \
huggingface_hub==0.23.0

LINE-BY-LINE BREAKDOWN
-----------------------
Let's break down this command piece by piece:

python3.11
• python3.11 = Specifies Python version 3.11
• This ensures we're using the correct Python version
• Some libraries require specific Python versions

-m pip
• -m = Run a module as a script
• pip = Python's package installer
• This runs pip as a Python module

install
• install = The pip command to install packages
• This tells pip what action to perform

\ (backslash)
• The backslash is a line continuation character
• It allows us to write the command across multiple lines
• Makes the command more readable
• Each line after a backslash is part of the same command

gradio==4.44.0
• gradio = The package name
• ==4.44.0 = Exact version to install
• This installs Gradio version 4.44.0

pydantic==2.10.6
• pydantic = Data validation library
• ==2.10.6 = Specific version
• Installed as a dependency for other libraries

ibm-watsonx-ai==1.1.2
• ibm-watsonx-ai = IBM's watsonx.ai library
• ==1.1.2 = Specific version
• This gives us access to IBM's LLM models

langchain==0.2.11
• langchain = The LangChain framework
• ==0.2.11 = Specific version
• Core framework for working with LLMs

langchain-community==0.2.10
• langchain-community = Community extensions
• ==0.2.10 = Specific version
• Additional LangChain components

langchain-ibm==0.1.11
• langchain-ibm = IBM integration for LangChain
• ==0.1.11 = Specific version
• Connects LangChain to IBM watsonx.ai

huggingface_hub==0.23.0
• huggingface_hub = Hugging Face Hub access
• ==0.23.0 = Specific version
• For accessing Hugging Face models

WHAT HAPPENS DURING INSTALLATION
---------------------------------
When you run this command, pip will:

1. Connect to PyPI (Python Package Index) - the repository of Python packages
2. Download each package and its dependencies
3. Resolve version conflicts (ensure compatible versions)
4. Install packages into your virtual environment
5. Show progress and completion messages

EXPECTED OUTPUT
---------------
You should see output like:

Collecting gradio==4.44.0
  Downloading gradio-4.44.0-py3-none-any.whl
Collecting pydantic==2.10.6
  Downloading pydantic-2.10.6-cp311-cp311-win_amd64.whl
...
Installing collected packages: ...
Successfully installed gradio-4.44.0 pydantic-2.10.6 ...

The exact output will vary, but you should see "Successfully installed" messages 
for all packages.

TROUBLESHOOTING COMMON ISSUES
------------------------------

ISSUE 1: "pip: command not found"
Solution: Use "python -m pip" instead of just "pip"

ISSUE 2: "Permission denied"
Solution: Make sure your virtual environment is activated

ISSUE 3: "Could not find a version"
Solution: Check your internet connection and Python version

ISSUE 4: Installation takes a long time
Solution: This is normal - some packages are large and have many dependencies

ISSUE 5: Version conflicts
Solution: The versions we specified are tested to work together. If you see 
conflicts, try installing them one at a time to identify the problematic package.

ALTERNATIVE: INSTALLING ONE AT A TIME
-------------------------------------
If you encounter issues with the combined command, you can install packages one 
at a time:

python3.11 -m pip install gradio==4.44.0
python3.11 -m pip install pydantic==2.10.6
python3.11 -m pip install ibm-watsonx-ai==1.1.2
python3.11 -m pip install langchain==0.2.11
python3.11 -m pip install langchain-community==0.2.10
python3.11 -m pip install langchain-ibm==0.1.11
python3.11 -m pip install huggingface_hub==0.23.0

This approach can help identify which package is causing issues if there are any 
problems.

[END SECTION 2.5]
================================================================================

SECTION 2.6: VERIFYING INSTALLATIONS
-------------------------------------

OVERVIEW
--------
After installation, it's important to verify that all packages were installed 
correctly. This helps catch any installation issues early.

VERIFICATION METHODS
--------------------

METHOD 1: CHECK INSTALLED PACKAGES
----------------------------------
List all installed packages to verify they're present:

Command:
pip list

This shows all installed packages. You should see:
• gradio (4.44.0)
• pydantic (2.10.6)
• ibm-watsonx-ai (1.1.2)
• langchain (0.2.11)
• langchain-community (0.2.10)
• langchain-ibm (0.1.11)
• huggingface_hub (0.23.0)

METHOD 2: TEST IMPORTING PACKAGES
----------------------------------
Try importing each package to ensure they work:

Command (run in Python):
python3.11

Then in the Python interpreter, try:
>>> import gradio as gr
>>> import pydantic
>>> from ibm_watsonx.ai.foundation_models import ModelInference
>>> import langchain
>>> import langchain_community
>>> import langchain_ibm
>>> from huggingface_hub import HfFolder

If all imports succeed without errors, the packages are installed correctly.

Exit the Python interpreter:
>>> exit()

METHOD 3: CHECK SPECIFIC VERSIONS
----------------------------------
Verify the exact versions:

Command:
pip show gradio
pip show ibm-watsonx-ai
pip show langchain

This shows detailed information about each package, including the version.

WHAT TO DO IF VERIFICATION FAILS
---------------------------------
If any package fails to import or isn't listed:

1. Check that your virtual environment is activated
2. Try reinstalling the problematic package:
   pip install --upgrade package_name
3. Check for error messages during installation
4. Verify your Python version (should be 3.11 or compatible)
5. Check your internet connection

SUCCESS INDICATORS
------------------
You know everything is set up correctly when:
• All packages appear in "pip list"
• All packages can be imported without errors
• No error messages appear
• You're ready to start coding!

[END SECTION 2.6]
================================================================================

PART 3: GRADIO QUICK TUTORIAL
================================================================================

Now that our environment is set up, let's learn the basics of Gradio by building 
a simple demo application. This will teach you the fundamental concepts before we 
build the more complex chatbot interface.

SECTION 3.1: GRADIO OVERVIEW AND CONCEPTS
------------------------------------------

OVERVIEW
--------
Before we start coding, let's understand the core concepts of Gradio. This will 
make everything else much clearer.

CORE GRADIO CONCEPTS
--------------------

1. INTERFACE
   • The main Gradio class for creating interfaces
   • Connects a Python function to a web interface
   • Automatically generates the UI based on function inputs/outputs
   • Example: gr.Interface() creates a complete interface

2. FUNCTION
   • Your Python function that does the actual work
   • Takes inputs and returns outputs
   • Gradio calls this function when users interact with the interface
   • Example: def add_numbers(a, b): return a + b

3. INPUTS
   • Define what users can provide to your function
   • Can be text, numbers, images, etc.
   • Gradio creates appropriate UI components
   • Example: gr.Number() creates a number input field

4. OUTPUTS
   • Define what your function returns
   • Gradio displays this to users
   • Must match your function's return type
   • Example: gr.Number() displays a number output

5. LAUNCH
   • Starts the web server
   • Makes your interface accessible via a URL
   • Can run locally or share publicly
   • Example: demo.launch() starts the server

THE BASIC GRADIO PATTERN
-------------------------
1. Write a Python function
2. Create inputs (what users provide)
3. Create outputs (what users see)
4. Create an Interface connecting function, inputs, and outputs
5. Launch the interface

EXAMPLE STRUCTURE:
```python
def my_function(input1, input2):
    # Do something with inputs
    result = input1 + input2
    return result

interface = gr.Interface(
    fn=my_function,
    inputs=[gr.Input1(), gr.Input2()],
    outputs=gr.Output()
)

interface.launch()
```

[END SECTION 3.1]
================================================================================

SECTION 3.2: CREATING YOUR FIRST GRADIO DEMO
----------------------------------------------

OVERVIEW
--------
Let's create our first Gradio application - a simple sum calculator. This will 
teach you the basics before we move to more complex applications.

STEP 1: CREATE A PYTHON FILE
------------------------------

FOR CLOUD IDE USERS:
Navigate to the EXPLORER icon in the left pane, select the PROJECT drop-down 
arrow, and select the New file icon on the menu bar.

Alternatively, for some browser types, you might need to right-click PROJECT 
and select New file.

FOR LOCAL IDE USERS:
• Right-click in your project folder
• Select "New File" or "Create File"
• Or use File → New File in your IDE

NAME THE FILE:
Name the file "gradio_demo.py" and select OK (or press Enter).

FILE NAMING CONVENTIONS:
• Use lowercase letters
• Separate words with underscores
• Use .py extension for Python files
• Descriptive names help you remember what the file does

STEP 2: UNDERSTANDING THE SUM CALCULATOR DEMO
----------------------------------------------
We'll create an application that can calculate the sum of two input numbers. 
This is a simple example that demonstrates:
• How to create inputs (two number fields)
• How to create outputs (one number field)
• How to connect a function to the interface
• How to launch and use the interface

[END SECTION 3.2]
================================================================================

SECTION 3.3: UNDERSTANDING GRADIO INTERFACE COMPONENTS
-------------------------------------------------------

OVERVIEW
--------
Before we write the code, let's understand the Gradio components we'll be using.

GR.NUMBER() COMPONENT
---------------------
The gr.Number() element from Gradio creates a numeric field for the user to 
enter numbers as input or can display the numeric output.

PROPERTIES:
• Can be used for both input and output
• Accepts integer and floating-point numbers
• Automatically validates numeric input
• Provides a clean numeric interface

USE CASES:
• Input: User enters a number
• Output: Display a calculated result
• Both: Calculator applications, data processing

GR.INTERFACE() CLASS
--------------------
The main class for creating Gradio interfaces. It connects a function to UI 
components.

PARAMETERS:
• fn: The Python function to call
• inputs: List of input components
• outputs: Output component(s)
• title: Optional title for the interface
• description: Optional description text

HOW IT WORKS:
1. User provides input through UI components
2. Gradio collects the input values
3. Calls your function with those values
4. Takes the function's return value
5. Displays it in the output component(s)

[END SECTION 3.3]
================================================================================

SECTION 3.4: BUILDING A SUM CALCULATOR DEMO
-------------------------------------------

OVERVIEW
--------
Now let's write the complete code for our sum calculator. We'll go through each 
line in detail.

THE COMPLETE CODE
-----------------
In the gradio_demo.py file, enter the following code:

```python
import gradio as gr
from huggingface_hub import HfFolder

def add_numbers(Num1, Num2):
    return Num1 + Num2

# Define the interface
demo = gr.Interface(
    fn=add_numbers,
    inputs=[gr.Number(), gr.Number()],
    outputs=gr.Number()
)

# Launch the interface
demo.launch(server_name="127.0.0.1", server_port=7860)
```

LINE-BY-LINE EXPLANATION
-------------------------

LINE 1: import gradio as gr
----------------------------
• import = Python keyword to import a module
• gradio = The Gradio library we installed
• as gr = Creates an alias "gr" so we can use "gr" instead of typing "gradio"
• This gives us access to all Gradio functionality

Why "as gr"?
• Shorter to type: gr.Interface() vs gradio.Interface()
• Common convention in the Gradio community
• Makes code more readable

LINE 2: from huggingface_hub import HfFolder
--------------------------------------------
• from ... import = Import a specific component from a module
• huggingface_hub = The Hugging Face Hub library
• HfFolder = A class for managing Hugging Face credentials
• This import might be used by Gradio internally for certain features

Note: We're importing this even though we don't use it directly in our code. It's 
included in the original lab, possibly for future use or as a requirement for 
certain Gradio features.

LINE 4-5: def add_numbers(Num1, Num2):
--------------------------------------
• def = Python keyword to define a function
• add_numbers = The name of our function
• (Num1, Num2) = Two parameters the function accepts
• : = Indicates the start of the function body

What this function does:
• Takes two numbers as input (Num1 and Num2)
• Adds them together
• Returns the sum

Function naming:
• Use descriptive names (add_numbers is clear)
• Follow Python naming conventions (lowercase with underscores)
• Num1 and Num2 are parameter names (could be a, b, x, y, etc.)

LINE 5: return Num1 + Num2
---------------------------
• return = Python keyword to return a value from a function
• Num1 + Num2 = Adds the two numbers together
• This is the result that will be displayed in the output

How it works:
• When Gradio calls this function, it passes the user's input values
• The function calculates Num1 + Num2
• Returns the result to Gradio
• Gradio displays it in the output component

LINE 7: # Define the interface
--------------------------------
• # = Python comment (ignored by Python, for human readers)
• This comment explains what the next section does
• Good practice to add comments explaining your code

LINE 8: demo = gr.Interface(
-----------------------------
• demo = Variable name to store our interface
• = = Assignment operator (stores the interface in "demo")
• gr.Interface = Creates a new Gradio Interface object
• ( = Start of parameters for Interface()

What this does:
• Creates a new Interface object
• Stores it in a variable called "demo"
• We'll configure it with the parameters that follow

LINE 9: fn=add_numbers,
------------------------
• fn = Parameter name (short for "function")
• = = Assignment within the parameter
• add_numbers = Our function we defined earlier
• , = Separates this parameter from the next

What this does:
• Tells Gradio which function to call when users interact
• Gradio will call add_numbers() with the user's inputs
• The function must accept the same number of parameters as inputs

LINE 10: inputs=[gr.Number(), gr.Number()],
--------------------------------------------
• inputs = Parameter name for input components
• = = Assignment
• [ ] = Python list (contains multiple items)
• gr.Number() = Creates a number input component
• gr.Number() = Creates a second number input component
• , = Separates parameters

What this creates:
• Two number input fields in the interface
• Users can enter numbers in these fields
• The first input maps to Num1 parameter
• The second input maps to Num2 parameter

Why a list?
• Functions can have multiple inputs
• List allows us to specify multiple input components
• Order matters: first input → first parameter, etc.

LINE 11: outputs=gr.Number()
-----------------------------
• outputs = Parameter name for output components
• = = Assignment
• gr.Number() = Creates a number output component
• No comma (last parameter)

What this creates:
• One number output field in the interface
• Displays the result returned by add_numbers()
• Shows the sum of the two input numbers

Why only one?
• Our function returns one value (the sum)
• One output component displays one return value
• If function returned multiple values, we'd use a list

LINE 12: )
----------
• Closes the gr.Interface() call
• Completes the interface definition

LINE 14: # Launch the interface
-------------------------------
• Comment explaining the next section
• Helps readers understand what's happening

LINE 15: demo.launch(server_name="127.0.0.1", server_port=7860)
------------------------------------------------------------------
• demo = Our interface object
• . = Dot notation (accesses methods/attributes of demo)
• launch = Method that starts the web server
• ( = Start of parameters
• server_name="127.0.0.1" = Sets the server address
• , = Separates parameters
• server_port=7860 = Sets the port number
• ) = Closes the method call

What this does:
• Starts a web server running your interface
• Makes it accessible at http://127.0.0.1:7860
• Keeps running until you stop it (Ctrl+C)

SERVER_NAME EXPLANATION:
• "127.0.0.1" = Localhost (your own computer)
• Only accessible from your machine
• Safe for development (not accessible from internet)
• Alternative: "0.0.0.0" makes it accessible on your network

SERVER_PORT EXPLANATION:
• 7860 = Port number (like a door number)
• Default Gradio port
• Can use any available port (e.g., 7861, 8080)
• If port is busy, Gradio will suggest another

HOW IT ALL WORKS TOGETHER
--------------------------
1. User opens the web interface
2. Sees two number input fields
3. Enters numbers (e.g., 3 and 4)
4. Clicks submit (or presses Enter)
5. Gradio calls add_numbers(3, 4)
6. Function returns 7
7. Gradio displays 7 in the output field
8. User sees the result

[END SECTION 3.4]
================================================================================

SECTION 3.5: LAUNCHING AND TESTING YOUR DEMO
----------------------------------------------

OVERVIEW
--------
Now that we've written the code, let's run it and see our interface in action.

STEP 1: VERIFY VIRTUAL ENVIRONMENT
-----------------------------------
Return to the terminal window and verify that the virtual environment "my_env" 
label appears at the start of the line. This verification confirms that you are 
in the my_env environment that you just created.

Your prompt should look like:
(my_env) user@computer:~/project$

If you don't see "(my_env)", activate it:
• Linux/Mac: source my_env/bin/activate
• Windows: my_env\Scripts\activate

STEP 2: RUN THE PYTHON SCRIPT
------------------------------
Use the following command to run the Python script:

Command:
python3.11 gradio_demo.py

WHAT HAPPENS:
• Python executes the script
• Gradio creates the interface
• Starts a web server
• Shows you the URL where it's running

EXPECTED OUTPUT
---------------
After this code runs successfully, you will see a message in the terminal window 
with the local URL displayed. You'll also see a message that instructs you that 
if you want to create a public link, to set share=True in launch().

Example output:
Running on local URL: http://127.0.0.1:7860

To create a public link, set `share=True` in `launch()`.

WHAT THIS MEANS:
• Your interface is running
• Accessible at http://127.0.0.1:7860
• Only on your local machine
• The server is running and waiting for connections

STEP 3: OPEN THE WEB APPLICATION
----------------------------------

FOR CLOUD IDE USERS:
Select the following Web Application button to view the application you developed.

(Note: if this Web Application button does not work, follow these pictured 
instructions to launch the app.)

1. Select OTHER and Launch Application.
2. Next, type your port number (7860) in the Application Port field and select 
   Your Application.

FOR LOCAL IDE USERS:
Open your web browser and navigate to:
http://127.0.0.1:7860

Or:
http://localhost:7860

Both addresses point to your local machine.

STEP 4: TEST THE APPLICATION
------------------------------
Now let's take a look at the web application, which shows an example of sum of 
3 and 4. You're encouraged to experiment with the web app's inputs and outputs!

WHAT YOU SHOULD SEE:
• A web page with a title (if you added one)
• Two number input fields
• Possibly a "Submit" button
• An output field (initially empty)

HOW TO USE IT:
1. Enter a number in the first field (e.g., 3)
2. Enter a number in the second field (e.g., 4)
3. Click "Submit" or press Enter
4. See the result (7) in the output field

TRY DIFFERENT VALUES:
• Try: 10 + 20 = 30
• Try: 5.5 + 3.2 = 8.7
• Try: 100 + 200 = 300
• Try negative numbers: -5 + 10 = 5

STEP 5: STOPPING THE APPLICATION
--------------------------------
When you are ready to terminate the script, press Ctrl+C in the terminal and 
close the application window.

HOW TO STOP:
1. Go back to your terminal
2. Press Ctrl+C (hold Ctrl, press C)
3. You'll see a message that the server stopped
4. Close the browser tab/window

WHAT HAPPENS:
• The web server stops
• The interface is no longer accessible
• Your terminal is ready for the next command
• No data is lost (just stops the server)

TROUBLESHOOTING
---------------

ISSUE: "ModuleNotFoundError: No module named 'gradio'"
Solution: Make sure your virtual environment is activated and Gradio is installed

ISSUE: "Address already in use"
Solution: Another application is using port 7860. Change the port number in 
launch() or stop the other application

ISSUE: Browser can't connect
Solution: Check that the server started successfully and you're using the correct URL

ISSUE: Interface doesn't update
Solution: Refresh the browser page (F5 or Ctrl+R)

[END SECTION 3.5]
================================================================================

SECTION 3.6: PRACTICE EXERCISE - SENTENCE COMBINER
----------------------------------------------------

OVERVIEW
--------
Now that you understand the basics, let's practice by creating a Gradio 
application that can combine two input sentences together. This exercise will 
reinforce what you've learned.

THE EXERCISE
------------
Can you create a Gradio application that can combine two input sentences together? 
Use what you know from the demo and your Python knowledge to create this app. 
Take your time to complete this exercise.

HINTS
-----
• You'll need a function that takes two sentences as input
• You'll need to use gr.Textbox() for text inputs (instead of gr.Number())
• The function should combine the sentences (maybe with a space?)
• You'll need one text output to display the result

STEP-BY-STEP GUIDE
------------------

STEP 1: CREATE A NEW FILE
--------------------------
Create a new file called "sentence_combiner.py"

STEP 2: WRITE THE FUNCTION
---------------------------
Think about what your function should do:
• Takes two sentences (strings) as input
• Combines them together
• Returns the combined sentence

Example function:
```python
def combine_sentences(sentence1, sentence2):
    # Your code here
    return combined_sentence
```

STEP 3: CREATE THE INTERFACE
-----------------------------
Use gr.Interface() similar to the sum calculator, but:
• Use gr.Textbox() for text inputs instead of gr.Number()
• Use gr.Textbox() for the output as well

STEP 4: LAUNCH AND TEST
------------------------
Launch the interface and test it with different sentences.

SOLUTION (TRY IT YOURSELF FIRST!)
----------------------------------
Here's one possible solution:

```python
import gradio as gr

def combine_sentences(sentence1, sentence2):
    return sentence1 + " " + sentence2

demo = gr.Interface(
    fn=combine_sentences,
    inputs=[gr.Textbox(label="First Sentence"), gr.Textbox(label="Second Sentence")],
    outputs=gr.Textbox(label="Combined Sentence")
)

demo.launch(server_name="127.0.0.1", server_port=7860)
```

EXPLANATION OF THE SOLUTION
----------------------------

gr.Textbox()
• Creates a text input/output field
• Can be used for both input and output
• label parameter adds a label above the field

combine_sentences function:
• Takes two string parameters
• Combines them with a space in between
• Returns the combined string

Why " " (space)?
• Separates the two sentences
• Makes the output readable
• Without it, sentences would run together

VARIATIONS TO TRY
-----------------
• Add punctuation: sentence1 + ". " + sentence2
• Add a separator: sentence1 + " | " + sentence2
• Capitalize: (sentence1 + " " + sentence2).capitalize()
• Add more sentences: Take three inputs instead of two

WHAT YOU LEARNED
----------------
• How to use gr.Textbox() for text inputs/outputs
• How to create a simple text processing function
• How to combine strings in Python
• How to customize labels in Gradio

[END SECTION 3.6]
================================================================================

END OF PART 1
=============

Congratulations! You've completed Part 1 of this comprehensive guide. You've 
learned:

• What Gradio is and why it's useful
• How to set up your development environment
• How to create a basic Gradio interface
• How to use number and text inputs/outputs
• How to launch and test your applications

In Part 2, we'll build on this foundation to:
• Understand LLMs and IBM watsonx.ai
• Create a simple LLM application
• Integrate Gradio with LLMs
• Build a complete chatbot interface
• Add advanced features and customization

Continue to Part 2 to learn how to integrate Gradio with Large Language Models 
and build your chatbot!

================================================================================
