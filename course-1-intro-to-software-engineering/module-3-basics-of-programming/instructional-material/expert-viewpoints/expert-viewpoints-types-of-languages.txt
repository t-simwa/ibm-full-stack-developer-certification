Welcome to Insidersâ€™ Viewpoints: Types of
Languages. In this video, we will hear from experts discussing
if they prefer developing in compiled or interpreted programming languages. most of the time, it doesn't really matter. It just comes down to personal preference,
like what are you going to get moving on the fastest. there are certain situations where it will
make a difference, if you're compiling ahead of time versus interpreting on the fly, if
you're trying to eke out, like very small, incremental performance benefits, I prefer compiled code or compiled language
that's compiled language just because I have a more of a guarantee that it will well maybe
not necessarily work, but will do what I thought it will do. And at least we'll deploy properly. When when when being rolled out. but usually no, it doesn't, doesn't make
that much of a difference to either the development process or the like deployment and use process. There. They, they definitely have advantages and
disadvantages to each of them. But most of the time, doesn't make that much
of a difference to what I'm doing. I think, interpreted languages can you know,
there's a lot of like flexibility there. And often you can do more creative things. And then you know, the compiler, it's sort
of stops, the buck stops with the compiler, and you can't really avoid compiler errors
with the compiled language with interpreted there's more interesting runtime possibilities
there. So I think it really depends on what environment
you're developing for, or what your your risk factor is, when it comes to being okay with,
with potentially buggy code being out in the wild. What do you think are the benefits of object-oriented
programming over procedural programming? Anything can be an object. And object-oriented design puts hierarchies
and patterns onto those things. And that structure can make it easy to keep
designs in mind. And keep in mind how the different objects
interact with each other. It's also very easy in object-oriented programming
to paint yourself into a wall where you have put too much structure around everything. And you now have this like explosion of useless
boilerplate code. So there's a bit of a, not catch 22. But just a balance that you need to find in
between how much structure should your thing have? How much flexibility should it have? And how much should your intentions be imposed
on that design and the way that people interact I think procedural programming can be, you
know, feels more mathematical and more sort of, like pure engineering, in some sense. And I think that that also can lend itself
well to someone who is really looking to not just build software, but really wants to sort
of feel like they're engineering the code, in some sense. It can feel like you're, you're kind of like,
in the machine if you will. So, I know that's a weird answer. But it's, it's I think it doesn't, you know,
depending on how your brain works to one can lend itself more easily than the other. So, but I love I think it's worth trying them
both out. if you get super object-oriented, you can
get a little to a little too prescriptive with the designs, I think. So that's just whenever you're using objects,
it's just a thing to keep in mind that you can go, you can go too far with it. But where that line of too far is kind of
depends on exactly what it is that you're building, sometimes there, sometimes the sky's
the limit, just regulate everything. And sometimes the amount of flexibility that
you require actually does mean that you can't really have an object of any sorts. Most of those situations should be pretty
weird, those would be on the extremes. But most of the time, a few simple objects
will do a lot of good, no matter what the rest of your system looks like. Yeah, I think object-oriented programming
to me is, for me, personally, I think it does lend itself well to like real-world mappings
and data models. And, you know, the sort of classic examples
of you might, in your first object-oriented software, demo, build something like a library
that has books, and it has a checkout. So, like you get there's physical objects
that the way you learn it is very much sort of you think about the software as something
real worlds that helps you make the jump from building something physical with your hands
to building something with, with bits and bytes.