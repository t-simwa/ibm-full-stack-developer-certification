================================================================================
WORKING WITH JSON
Comprehensive Study Guide - Part 2
================================================================================

WELCOME TO PART 2
-----------------
This part covers real-world examples, practical applications, best practices, 
and a comprehensive summary of working with JSON. You'll see complete, 
working examples with detailed line-by-line explanations.

ESTIMATED TIME NEEDED
---------------------
30-45 minutes (for comprehensive study with practice)

================================================================================
TABLE OF CONTENTS - PART 2
================================================================================

PART 4: REAL-WORLD EXAMPLES
  SECTION 4.1: WORKING WITH API ENDPOINTS
  SECTION 4.2: THE ISS ASTRONAUTS API EXAMPLE
  SECTION 4.3: COMPLETE NODE.JS EXAMPLE WITH HTTP
  SECTION 4.4: HANDLING API RESPONSES

PART 5: PRACTICAL PATTERNS AND USE CASES
  SECTION 5.1: READING JSON FROM FILES
  SECTION 5.2: WRITING JSON TO FILES
  SECTION 5.3: WORKING WITH LOCALSTORAGE
  SECTION 5.4: VALIDATING JSON DATA

PART 6: BEST PRACTICES AND COMMON PATTERNS
  SECTION 6.1: JSON BEST PRACTICES
  SECTION 6.2: ERROR HANDLING PATTERNS
  SECTION 6.3: PERFORMANCE CONSIDERATIONS
  SECTION 6.4: SECURITY CONSIDERATIONS

PART 7: SUMMARY AND REFERENCE
  SECTION 7.1: KEY CONCEPTS SUMMARY
  SECTION 7.2: QUICK REFERENCE GUIDE
  SECTION 7.3: COMMON METHODS REFERENCE
  SECTION 7.4: TROUBLESHOOTING GUIDE

================================================================================
PART 4: REAL-WORLD EXAMPLES
================================================================================

SECTION 4.1: WORKING WITH API ENDPOINTS
----------------------------------------

UNDERSTANDING API ENDPOINTS AND JSON
-------------------------------------
An API (Application Programming Interface) endpoint is a URL where you can 
request data from a server. Most modern APIs return data in JSON format. 
When you make an HTTP request to an API endpoint, you typically receive a 
JSON string in the response body, which you then need to parse.

THE TYPICAL WORKFLOW
--------------------
1. Make an HTTP request to an API endpoint
2. Receive the response (usually as a string containing JSON)
3. Parse the JSON string using JSON.parse()
4. Use the parsed JavaScript object in your code

EXAMPLE: BASIC API REQUEST PATTERN
-----------------------------------
// This is the general pattern for working with APIs:

// Step 1: Make HTTP request
// Step 2: Receive JSON string in response
// Step 3: Parse JSON string to JavaScript object
// Step 4: Use the data

REAL-WORLD API EXAMPLES
-----------------------
Many public APIs return JSON data. Some examples include:
• Weather APIs (OpenWeatherMap, WeatherAPI)
• Space APIs (ISS location, NASA APIs)
• News APIs (NewsAPI)
• Social Media APIs (Twitter, Facebook)
• E-commerce APIs (product catalogs)
• Financial APIs (stock prices, exchange rates)

[END SECTION 4.1]
================================================================================

SECTION 4.2: THE ISS ASTRONAUTS API EXAMPLE
-------------------------------------------

THE INTERNATIONAL SPACE STATION API
------------------------------------
The original material mentions using JSON to find out how many astronauts are 
in the International Space Station (ISS). This is a perfect real-world example 
of working with JSON from an API endpoint.

UNDERSTANDING THE EXAMPLE
--------------------------
You can use JSON to find out how many astronauts are in the International 
Space Station (ISS). You have found that the number of astronauts is five.

This example demonstrates:
• Making an HTTP request to an API
• Receiving JSON data in the response
• Parsing the JSON string
• Extracting and using the data

THE ISS ASTRONAUTS API ENDPOINT
--------------------------------
There are several APIs that provide ISS astronaut information. One popular 
endpoint is:
http://api.open-notify.org/astros.json

This API returns JSON data about people currently in space, including those 
on the ISS.

EXAMPLE RESPONSE FROM THE API
------------------------------
When you call this API, you receive a JSON string like this:

{
  "message": "success",
  "number": 5,
  "people": [
    {
      "craft": "ISS",
      "name": "Sergey Prokopyev"
    },
    {
      "craft": "ISS",
      "name": "Dmitry Petelin"
    },
    {
      "craft": "ISS",
      "name": "Frank Rubio"
    },
    {
      "craft": "ISS",
      "name": "Nicole Mann"
    },
    {
      "craft": "ISS",
      "name": "Josh Cassada"
    }
  ]
}

BREAKDOWN OF THE RESPONSE
-------------------------
• "message": "success" - Indicates the API call was successful
• "number": 5 - The total number of people in space (in this case, 5)
• "people": [...] - An array of objects, each containing:
  - "craft": The spacecraft name (e.g., "ISS")
  - "name": The astronaut's name

COMPLETE NODE.JS EXAMPLE
------------------------
Here's a complete example using Node.js to fetch and parse this data:

const http = require('http');

// The API endpoint URL
const apiUrl = 'http://api.open-notify.org/astros.json';

// Make the HTTP request
http.get(apiUrl, (response) => {
  let data = '';
  
  // Collect response data chunks
  response.on('data', (chunk) => {
    data += chunk;
  });
  
  // When all data is received
  response.on('end', () => {
    try {
      // Parse the JSON string into a JavaScript object
      let jsonData = JSON.parse(data);
      
      // Extract the number of astronauts
      let numberOfAstronauts = jsonData.number;
      
      // Display the result
      console.log('Number of astronauts in space:', numberOfAstronauts);
      
      // You can also access the people array
      console.log('Astronauts:');
      jsonData.people.forEach(person => {
        console.log(`- ${person.name} (${person.craft})`);
      });
      
    } catch (error) {
      console.error('Error parsing JSON:', error.message);
    }
  });
  
}).on('error', (error) => {
  console.error('Error making request:', error.message);
});

LINE-BY-LINE EXPLANATION
-------------------------
Line 1: const http = require('http');
        • We import Node.js's built-in http module
        • This module provides functionality for making HTTP requests

Line 3: const apiUrl = 'http://api.open-notify.org/astros.json';
        • We store the API endpoint URL in a constant
        • This is the URL we'll request data from

Line 5: http.get(apiUrl, (response) => { ... });
        • We use http.get() to make a GET request to the API
        • http.get() takes two parameters:
          - First: the URL to request
          - Second: a callback function that receives the response
        • The callback function is called when the server responds

Line 6: let data = '';
        • We create an empty string to accumulate the response data
        • HTTP responses can arrive in multiple chunks, so we need to 
          collect them all before parsing

Line 8-10: response.on('data', (chunk) => { data += chunk; });
           • We listen for 'data' events on the response
           • Each time a chunk of data arrives, the callback is called
           • We add each chunk to our data string
           • This continues until all data is received

Line 13: response.on('end', () => { ... });
         • We listen for the 'end' event
         • This fires when all data has been received
         • Now we can process the complete response

Line 14: try { ... }
         • We wrap the parsing in a try block
         • This allows us to catch any errors that occur

Line 16: let jsonData = JSON.parse(data);
         • This is the key line! We parse the JSON string
         • data is a string containing JSON (like '{"number": 5, ...}')
         • JSON.parse() converts it to a JavaScript object
         • Now jsonData is an object we can work with

Line 19: let numberOfAstronauts = jsonData.number;
         • We access the "number" property from the parsed object
         • This gives us the number of astronauts (5 in this example)
         • We store it in a variable

Line 22: console.log('Number of astronauts in space:', numberOfAstronauts);
         • We display the number of astronauts
         • Output: "Number of astronauts in space: 5"

Line 25-28: jsonData.people.forEach(...);
            • We access the "people" array from the parsed object
            • forEach() iterates over each person in the array
            • For each person, we log their name and craft
            • This displays all the astronauts

Line 30-32: catch (error) { ... }
            • If JSON.parse() fails (invalid JSON), we catch the error
            • We display an error message to help debug

Line 35-37: .on('error', (error) => { ... });
            • This handles network errors (connection failed, etc.)
            • If the HTTP request itself fails, this callback runs

EXPECTED OUTPUT
---------------
When you run this code, you should see output like:

Number of astronauts in space: 5
Astronauts:
- Sergey Prokopyev (ISS)
- Dmitry Petelin (ISS)
- Frank Rubio (ISS)
- Nicole Mann (ISS)
- Josh Cassada (ISS)

ALTERNATIVE: USING MODERN FETCH (NODE.JS 18+)
---------------------------------------------
If you're using Node.js 18 or later, you can use the built-in fetch:

// Note: This requires Node.js 18+ or a fetch polyfill
fetch('http://api.open-notify.org/astros.json')
  .then(response => response.json())  // Automatically parses JSON
  .then(data => {
    console.log('Number of astronauts in space:', data.number);
    data.people.forEach(person => {
      console.log(`- ${person.name} (${person.craft})`);
    });
  })
  .catch(error => {
    console.error('Error:', error.message);
  });

LINE-BY-LINE EXPLANATION (FETCH VERSION)
----------------------------------------
Line 1: fetch('http://api.open-notify.org/astros.json')
        • fetch() makes an HTTP GET request to the URL
        • It returns a Promise

Line 2: .then(response => response.json())
        • When the response arrives, we call .json() on it
        • response.json() automatically parses the JSON
        • It also returns a Promise with the parsed data

Line 3: .then(data => { ... })
        • When parsing is complete, we receive the JavaScript object
        • data is now the parsed object (not a string)
        • We can directly access data.number, data.people, etc.

Line 4: console.log('Number of astronauts in space:', data.number);
        • We access the number property directly
        • No need to parse - it's already an object

Line 5-7: data.people.forEach(...);
         • We iterate over the people array
         • Display each astronaut's information

Line 9-11: .catch(error => { ... });
          • Handles any errors (network, parsing, etc.)

USING ASYNC/AWAIT (MODERN SYNTAX)
----------------------------------
You can also use async/await for cleaner code:

async function getAstronauts() {
  try {
    const response = await fetch('http://api.open-notify.org/astros.json');
    const data = await response.json();
    
    console.log('Number of astronauts in space:', data.number);
    data.people.forEach(person => {
      console.log(`- ${person.name} (${person.craft})`);
    });
  } catch (error) {
    console.error('Error:', error.message);
  }
}

getAstronauts();

LINE-BY-LINE EXPLANATION (ASYNC/AWAIT)
---------------------------------------
Line 1: async function getAstronauts() { ... }
        • We define an async function
        • async allows us to use await inside

Line 2: try { ... }
        • We wrap the code in try-catch for error handling

Line 3: const response = await fetch(...);
        • await pauses execution until fetch completes
        • response is the HTTP response object

Line 4: const data = await response.json();
        • await pauses until JSON parsing completes
        • data is the parsed JavaScript object
        • No need to manually call JSON.parse()

Line 6: console.log('Number of astronauts in space:', data.number);
        • We can directly access properties
        • data is already a JavaScript object

Line 7-9: data.people.forEach(...);
         • Iterate and display astronauts

Line 11-13: catch (error) { ... }
          • Handle any errors that occur

[END SECTION 4.2]
================================================================================

SECTION 4.3: COMPLETE NODE.JS EXAMPLE WITH HTTP
------------------------------------------------

A MORE COMPLETE EXAMPLE WITH ERROR HANDLING
-------------------------------------------
Let's create a more robust example that handles various scenarios:

const http = require('http');

function getISSData() {
  return new Promise((resolve, reject) => {
    const apiUrl = 'http://api.open-notify.org/astros.json';
    
    http.get(apiUrl, (response) => {
      // Check if request was successful
      if (response.statusCode !== 200) {
        reject(new Error(`HTTP Error: ${response.statusCode}`));
        return;
      }
      
      let data = '';
      
      // Collect response data
      response.on('data', (chunk) => {
        data += chunk;
      });
      
      // Process when complete
      response.on('end', () => {
        try {
          // Parse JSON string to JavaScript object
          const jsonData = JSON.parse(data);
          
          // Validate the data structure
          if (!jsonData.number || !jsonData.people) {
            reject(new Error('Invalid data structure'));
            return;
          }
          
          // Resolve with the parsed data
          resolve(jsonData);
          
        } catch (error) {
          reject(new Error(`JSON Parse Error: ${error.message}`));
        }
      });
      
    }).on('error', (error) => {
      reject(new Error(`Request Error: ${error.message}`));
    });
  });
}

// Use the function
getISSData()
  .then(data => {
    console.log('=== ISS Astronaut Information ===');
    console.log(`Total astronauts in space: ${data.number}`);
    console.log('\nAstronauts:');
    data.people.forEach((person, index) => {
      console.log(`${index + 1}. ${person.name} - ${person.craft}`);
    });
  })
  .catch(error => {
    console.error('Failed to get ISS data:', error.message);
  });

DETAILED LINE-BY-LINE EXPLANATION
----------------------------------
Line 1: const http = require('http');
        • Import the http module for making requests

Line 3: function getISSData() { ... }
        • We create a function that returns a Promise
        • This makes it easier to use with .then() and .catch()

Line 4: return new Promise((resolve, reject) => { ... });
        • We return a Promise so we can use async/await or .then()
        • resolve: called when successful
        • reject: called when there's an error

Line 5: const apiUrl = 'http://api.open-notify.org/astros.json';
        • Store the API URL

Line 7: http.get(apiUrl, (response) => { ... });
        • Make the HTTP GET request
        • response object contains status code, headers, and data stream

Line 9-12: if (response.statusCode !== 200) { ... }
           • Check if the HTTP request was successful
           • Status code 200 means "OK"
           • Other codes (404, 500, etc.) indicate errors
           • If not 200, we reject the Promise with an error

Line 14: let data = '';
        • Initialize empty string to collect response data

Line 17-19: response.on('data', (chunk) => { data += chunk; });
            • Listen for data chunks
            • Add each chunk to our data string
            • Continues until all data is received

Line 22: response.on('end', () => { ... });
         • Fires when all data has been received
         • Now we can process the complete response

Line 23: try { ... }
         • Wrap parsing in try-catch for error handling

Line 25: const jsonData = JSON.parse(data);
         • THE KEY LINE: Parse JSON string to JavaScript object
         • data is a string like '{"number": 5, ...}'
         • jsonData is now an object: { number: 5, ... }

Line 28-31: if (!jsonData.number || !jsonData.people) { ... }
            • Validate that the parsed data has expected structure
            • Check if required properties exist
            • If not, reject with an error

Line 34: resolve(jsonData);
         • If everything is successful, resolve the Promise
         • Pass the parsed JavaScript object to .then()

Line 37: catch (error) { ... }
         • If JSON.parse() fails, catch the error
         • Reject the Promise with a descriptive error message

Line 41-43: .on('error', (error) => { ... });
            • Handle network-level errors
            • Connection failures, DNS errors, etc.
            • Reject the Promise with error details

Line 46: getISSData()
        • Call our function
        • It returns a Promise

Line 47: .then(data => { ... })
         • When successful, data is the parsed JavaScript object
         • We can directly access data.number, data.people, etc.

Line 48-49: console.log('=== ISS Astronaut Information ===');
            console.log(`Total astronauts in space: ${data.number}`);
            • Display formatted output
            • Access the number property directly

Line 50-53: data.people.forEach((person, index) => { ... });
            • Iterate over the people array
            • person is each astronaut object
            • index is the position in the array
            • Display each astronaut's information

Line 55-57: .catch(error => { ... });
            • Handle any errors that occurred
            • Display user-friendly error message

[END SECTION 4.3]
================================================================================

SECTION 4.4: HANDLING API RESPONSES
------------------------------------

UNDERSTANDING API RESPONSE STRUCTURES
-------------------------------------
Different APIs return JSON in different structures. It's important to 
understand the structure of the response so you can parse and use it correctly.

COMMON API RESPONSE PATTERNS
----------------------------

PATTERN 1: SIMPLE OBJECT
------------------------
{
  "status": "success",
  "data": {
    "name": "John",
    "age": 30
  }
}

Access: response.data.name

PATTERN 2: ARRAY OF OBJECTS
---------------------------
[
  {"id": 1, "name": "Item 1"},
  {"id": 2, "name": "Item 2"}
]

Access: response[0].name

PATTERN 3: NESTED STRUCTURE
---------------------------
{
  "results": {
    "users": [
      {"name": "Alice"},
      {"name": "Bob"}
    ]
  }
}

Access: response.results.users[0].name

EXAMPLE: HANDLING DIFFERENT RESPONSE STRUCTURES
------------------------------------------------
function handleAPIResponse(jsonString) {
  try {
    // Parse the JSON string
    const data = JSON.parse(jsonString);
    
    // Check the structure and handle accordingly
    if (Array.isArray(data)) {
      // Response is an array
      console.log('Received array with', data.length, 'items');
      return data;
      
    } else if (data.data) {
      // Response has a "data" property
      console.log('Data found in response.data');
      return data.data;
      
    } else if (data.results) {
      // Response has a "results" property
      console.log('Data found in response.results');
      return data.results;
      
    } else {
      // Direct object
      console.log('Direct object response');
      return data;
    }
    
  } catch (error) {
    console.error('Error parsing JSON:', error.message);
    return null;
  }
}

// Example usage
const response1 = '[{"name": "Item 1"}]';
const response2 = '{"data": {"name": "John"}}';
const response3 = '{"name": "Direct"}';

console.log(handleAPIResponse(response1));
console.log(handleAPIResponse(response2));
console.log(handleAPIResponse(response3));

[END SECTION 4.4]
================================================================================

PART 5: PRACTICAL PATTERNS AND USE CASES
================================================================================

SECTION 5.1: READING JSON FROM FILES
-------------------------------------

READING AND PARSING JSON FILES
-------------------------------
In Node.js, you often need to read JSON data from files. The file system 
module (fs) reads files as strings, so you need to parse the JSON.

BASIC EXAMPLE
-------------
const fs = require('fs');

// Read the file (returns a string)
let fileContent = fs.readFileSync('data.json', 'utf8');

// Parse the JSON string to a JavaScript object
let data = JSON.parse(fileContent);

// Use the data
console.log(data);

LINE-BY-LINE EXPLANATION
-------------------------
Line 1: const fs = require('fs');
        • Import the file system module
        • This module provides file reading/writing functions

Line 3: let fileContent = fs.readFileSync('data.json', 'utf8');
        • Read the file synchronously (blocks until complete)
        • 'data.json' is the file path
        • 'utf8' specifies the encoding (text format)
        • fileContent is now a string containing the file contents

Line 5: let data = JSON.parse(fileContent);
        • Parse the JSON string into a JavaScript object
        • fileContent is a string like '{"name": "John"}'
        • data is now an object like { name: "John" }

Line 7: console.log(data);
        • Use the parsed object
        • Output: { name: "John" } (as an object, not a string)

EXAMPLE: READING WITH ERROR HANDLING
-------------------------------------
const fs = require('fs');

function readJSONFile(filePath) {
  try {
    // Read file as string
    const fileContent = fs.readFileSync(filePath, 'utf8');
    
    // Parse JSON string to object
    const data = JSON.parse(fileContent);
    
    return data;
    
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.error('File not found:', filePath);
    } else if (error instanceof SyntaxError) {
      console.error('Invalid JSON in file:', error.message);
    } else {
      console.error('Error reading file:', error.message);
    }
    return null;
  }
}

// Usage
const data = readJSONFile('config.json');
if (data) {
  console.log('Config loaded:', data);
}

EXAMPLE: ASYNCHRONOUS FILE READING
-----------------------------------
const fs = require('fs').promises;

async function readJSONFileAsync(filePath) {
  try {
    // Read file (returns a Promise)
    const fileContent = await fs.readFile(filePath, 'utf8');
    
    // Parse JSON string to object
    const data = JSON.parse(fileContent);
    
    return data;
    
  } catch (error) {
    console.error('Error:', error.message);
    return null;
  }
}

// Usage
readJSONFileAsync('data.json')
  .then(data => {
    if (data) {
      console.log('Data loaded:', data);
    }
  });

[END SECTION 5.1]
================================================================================

SECTION 5.2: WRITING JSON TO FILES
-----------------------------------

WRITING JAVASCRIPT OBJECTS TO JSON FILES
----------------------------------------
To save data to a file, you need to:
1. Convert the JavaScript object to a JSON string using JSON.stringify()
2. Write the string to a file

BASIC EXAMPLE
-------------
const fs = require('fs');

// Create a JavaScript object
let data = {
  name: "John",
  age: 30,
  city: "New York"
};

// Convert to JSON string
let jsonString = JSON.stringify(data);

// Write to file
fs.writeFileSync('data.json', jsonString, 'utf8');

console.log('Data saved to data.json');

LINE-BY-LINE EXPLANATION
-------------------------
Line 1: const fs = require('fs');
        • Import the file system module

Line 3-7: let data = { name: "John", age: 30, city: "New York" };
          • Create a JavaScript object
          • This is a regular JavaScript object (not a string)

Line 9: let jsonString = JSON.stringify(data);
        • Convert the object to a JSON string
        • data is an object: { name: "John", ... }
        • jsonString is now a string: '{"name":"John",...}'

Line 11: fs.writeFileSync('data.json', jsonString, 'utf8');
         • Write the JSON string to a file
         • 'data.json' is the file path
         • jsonString is the content to write
         • 'utf8' specifies text encoding

EXAMPLE: WRITING FORMATTED JSON
--------------------------------
const fs = require('fs');

let data = {
  name: "John",
  age: 30,
  hobbies: ["reading", "coding"]
};

// Convert to formatted JSON string (with indentation)
let jsonString = JSON.stringify(data, null, 2);

// Write to file
fs.writeFileSync('data.json', jsonString, 'utf8');

// The file will contain nicely formatted JSON:
// {
//   "name": "John",
//   "age": 30,
//   "hobbies": [
//     "reading",
//     "coding"
//   ]
// }

EXAMPLE: WRITING WITH ERROR HANDLING
------------------------------------
const fs = require('fs');

function writeJSONFile(filePath, data) {
  try {
    // Convert object to JSON string
    const jsonString = JSON.stringify(data, null, 2);
    
    // Write to file
    fs.writeFileSync(filePath, jsonString, 'utf8');
    
    console.log('Data written successfully to', filePath);
    return true;
    
  } catch (error) {
    console.error('Error writing file:', error.message);
    return false;
  }
}

// Usage
let userData = {
  username: "johndoe",
  email: "john@example.com"
};

writeJSONFile('user.json', userData);

[END SECTION 5.2]
================================================================================

SECTION 5.3: WORKING WITH LOCALSTORAGE
---------------------------------------

STORING AND RETRIEVING JSON IN BROWSER LOCALSTORAGE
----------------------------------------------------
In web browsers, localStorage only stores strings. To store objects, you must 
convert them to JSON strings first. To retrieve them, you must parse the JSON 
strings back to objects.

STORING DATA
------------
// Create a JavaScript object
let userData = {
  name: "John",
  preferences: {
    theme: "dark",
    language: "en"
  }
};

// Convert to JSON string
let jsonString = JSON.stringify(userData);

// Store in localStorage (only accepts strings)
localStorage.setItem('userData', jsonString);

LINE-BY-LINE EXPLANATION
-------------------------
Line 1-6: let userData = { ... };
          • Create a JavaScript object
          • Can contain nested objects, arrays, etc.

Line 8: let jsonString = JSON.stringify(userData);
        • Convert object to JSON string
        • Required because localStorage only stores strings

Line 10: localStorage.setItem('userData', jsonString);
         • Store the JSON string in localStorage
         • 'userData' is the key
         • jsonString is the value (must be a string)

RETRIEVING DATA
---------------
// Retrieve the JSON string from localStorage
let jsonString = localStorage.getItem('userData');

// Parse the JSON string back to a JavaScript object
let userData = JSON.parse(jsonString);

// Use the object
console.log(userData.name);
console.log(userData.preferences.theme);

LINE-BY-LINE EXPLANATION
-------------------------
Line 1: let jsonString = localStorage.getItem('userData');
        • Retrieve the stored string
        • jsonString is a string like '{"name":"John",...}'

Line 3: let userData = JSON.parse(jsonString);
        • Parse the JSON string to a JavaScript object
        • userData is now an object: { name: "John", ... }

Line 5-6: console.log(userData.name);
          console.log(userData.preferences.theme);
          • Access properties of the parsed object
          • Can use dot notation, bracket notation, etc.

COMPLETE EXAMPLE WITH ERROR HANDLING
------------------------------------
function saveToLocalStorage(key, data) {
  try {
    // Convert to JSON string
    const jsonString = JSON.stringify(data);
    
    // Store in localStorage
    localStorage.setItem(key, jsonString);
    
    return true;
  } catch (error) {
    console.error('Error saving to localStorage:', error.message);
    return false;
  }
}

function loadFromLocalStorage(key) {
  try {
    // Retrieve JSON string
    const jsonString = localStorage.getItem(key);
    
    if (jsonString === null) {
      return null;  // Key doesn't exist
    }
    
    // Parse to object
    const data = JSON.parse(jsonString);
    
    return data;
  } catch (error) {
    console.error('Error loading from localStorage:', error.message);
    return null;
  }
}

// Usage
let userData = { name: "John", age: 30 };

// Save
saveToLocalStorage('user', userData);

// Load
let loadedData = loadFromLocalStorage('user');
console.log(loadedData);  // { name: "John", age: 30 }

[END SECTION 5.3]
================================================================================

SECTION 5.4: VALIDATING JSON DATA
----------------------------------

VALIDATING JSON BEFORE PARSING
-------------------------------
It's good practice to validate JSON data before trying to parse it, especially 
when dealing with user input or external APIs.

BASIC VALIDATION FUNCTION
--------------------------
function isValidJSON(str) {
  try {
    JSON.parse(str);
    return true;
  } catch (error) {
    return false;
  }
}

// Usage
console.log(isValidJSON('{"name": "John"}'));  // true
console.log(isValidJSON('invalid json'));      // false

VALIDATING AND PARSING
----------------------
function validateAndParse(jsonString) {
  try {
    const data = JSON.parse(jsonString);
    return { valid: true, data: data };
  } catch (error) {
    return { valid: false, error: error.message };
  }
}

// Usage
let result = validateAndParse('{"name": "John"}');
if (result.valid) {
  console.log('Valid JSON:', result.data);
} else {
  console.log('Invalid JSON:', result.error);
}

VALIDATING DATA STRUCTURE
-------------------------
function validateDataStructure(data, requiredFields) {
  for (let field of requiredFields) {
    if (!(field in data)) {
      return { valid: false, missing: field };
    }
  }
  return { valid: true };
}

// Usage
let userData = { name: "John", age: 30 };
let validation = validateDataStructure(userData, ['name', 'email']);

if (!validation.valid) {
  console.log('Missing field:', validation.missing);
}

[END SECTION 5.4]
================================================================================

PART 6: BEST PRACTICES AND COMMON PATTERNS
================================================================================

SECTION 6.1: JSON BEST PRACTICES
--------------------------------

BEST PRACTICE 1: ALWAYS HANDLE ERRORS
--------------------------------------
Always wrap JSON.parse() in try-catch blocks:

// GOOD
try {
  const data = JSON.parse(jsonString);
} catch (error) {
  console.error('Invalid JSON:', error.message);
}

// BAD
const data = JSON.parse(jsonString);  // Can throw error

BEST PRACTICE 2: VALIDATE DATA STRUCTURE
-----------------------------------------
After parsing, validate that the data has the expected structure:

// GOOD
const data = JSON.parse(jsonString);
if (data && data.users && Array.isArray(data.users)) {
  // Safe to use data.users
}

// BAD
const data = JSON.parse(jsonString);
data.users.forEach(...);  // Might fail if users doesn't exist

BEST PRACTICE 3: USE FORMATTED JSON FOR FILES
---------------------------------------------
When writing JSON to files that humans will read, use formatting:

// GOOD
JSON.stringify(data, null, 2);  // Readable

// BAD (for human-readable files)
JSON.stringify(data);  // Minified, hard to read

BEST PRACTICE 4: MINIFY FOR NETWORK TRANSMISSION
------------------------------------------------
When sending JSON over networks, use minified version:

// GOOD (for APIs)
JSON.stringify(data);  // Smaller, faster

// OK (for debugging)
JSON.stringify(data, null, 2);  // Larger, but readable

BEST PRACTICE 5: DON'T STORE SENSITIVE DATA IN JSON
----------------------------------------------------
JSON is plain text - don't store passwords, tokens, etc. without encryption:

// BAD
{
  "username": "john",
  "password": "secret123"  // Never do this!
}

[END SECTION 6.1]
================================================================================

SECTION 6.2: ERROR HANDLING PATTERNS
-------------------------------------

PATTERN 1: BASIC ERROR HANDLING
--------------------------------
function parseJSON(jsonString) {
  try {
    return JSON.parse(jsonString);
  } catch (error) {
    console.error('JSON Parse Error:', error.message);
    return null;
  }
}

PATTERN 2: ERROR HANDLING WITH DEFAULT VALUE
--------------------------------------------
function parseJSONWithDefault(jsonString, defaultValue = {}) {
  try {
    return JSON.parse(jsonString);
  } catch (error) {
    console.error('JSON Parse Error:', error.message);
    return defaultValue;
  }
}

// Usage
const data = parseJSONWithDefault(invalidJSON, { name: "Unknown" });

PATTERN 3: DETAILED ERROR HANDLING
----------------------------------
function parseJSONDetailed(jsonString) {
  try {
    return {
      success: true,
      data: JSON.parse(jsonString)
    };
  } catch (error) {
    return {
      success: false,
      error: {
        message: error.message,
        type: error.name,
        position: error.toString().match(/position (\d+)/)?.[1]
      }
    };
  }
}

[END SECTION 6.2]
================================================================================

SECTION 6.3: PERFORMANCE CONSIDERATIONS
----------------------------------------

LARGE JSON FILES
----------------
For very large JSON files, consider:
• Streaming parsers for large files
• Processing data in chunks
• Using specialized libraries for huge datasets

CACHING PARSED DATA
-------------------
If you parse the same JSON multiple times, cache the result:

let cachedData = null;

function getData() {
  if (cachedData === null) {
    const jsonString = fs.readFileSync('data.json', 'utf8');
    cachedData = JSON.parse(jsonString);
  }
  return cachedData;
}

[END SECTION 6.3]
================================================================================

SECTION 6.4: SECURITY CONSIDERATIONS
------------------------------------

NEVER EVAL() JSON
-----------------
Never use eval() to parse JSON - it's a security risk:

// NEVER DO THIS
const data = eval('(' + jsonString + ')');  // DANGEROUS!

// ALWAYS DO THIS
const data = JSON.parse(jsonString);  // SAFE

VALIDATE INPUT SOURCES
----------------------
Always validate JSON from untrusted sources:

function safeParseJSON(jsonString, schema) {
  try {
    const data = JSON.parse(jsonString);
    // Validate against schema
    return data;
  } catch (error) {
    return null;
  }
}

[END SECTION 6.4]
================================================================================

PART 7: SUMMARY AND REFERENCE
================================================================================

SECTION 7.1: KEY CONCEPTS SUMMARY
----------------------------------

WHAT IS JSON?
-------------
• JSON stands for JavaScript Object Notation
• It is the standard format for API data exchange
• It is the standard representation of native JavaScript objects
• Node.js handles it easily

KEY METHODS
-----------
1. JSON.parse(jsonString)
   • Parses a JSON string into a JavaScript object
   • Use when receiving JSON data (from APIs, files, etc.)

2. JSON.stringify(javascriptObject)
   • Converts a JavaScript object into a JSON string
   • Use when sending data (to APIs, files, localStorage, etc.)

JSON STRUCTURE
--------------
• Uses attribute-value pairs
• Keys must be in double quotes
• Values can be: strings, numbers, booleans, null, arrays, objects
• No trailing commas
• No comments

COMMON USE CASES
----------------
• Parsing JSON data from HTTP messages
• Converting JavaScript objects to JSON strings
• Reading/writing JSON files
• Storing data in localStorage
• API communication
• Configuration files

[END SECTION 7.1]
================================================================================

SECTION 7.2: QUICK REFERENCE GUIDE
-----------------------------------

JSON.PARSE() QUICK REFERENCE
-----------------------------
Syntax: JSON.parse(jsonString)

Purpose: Convert JSON string to JavaScript object

Example:
  const jsonString = '{"name": "John"}';
  const obj = JSON.parse(jsonString);
  console.log(obj.name);  // "John"

JSON.STRINGIFY() QUICK REFERENCE
---------------------------------
Syntax: JSON.stringify(value, replacer, space)

Purpose: Convert JavaScript object to JSON string

Example:
  const obj = { name: "John" };
  const jsonString = JSON.stringify(obj);
  console.log(jsonString);  // '{"name":"John"}'

COMMON PATTERNS
---------------

Pattern 1: Parse JSON from API
  fetch(url)
    .then(response => response.json())  // Auto-parses
    .then(data => console.log(data));

Pattern 2: Parse JSON from File
  const jsonString = fs.readFileSync('file.json', 'utf8');
  const data = JSON.parse(jsonString);

Pattern 3: Save Object to File
  const data = { name: "John" };
  const jsonString = JSON.stringify(data, null, 2);
  fs.writeFileSync('file.json', jsonString);

Pattern 4: Store in localStorage
  localStorage.setItem('key', JSON.stringify(data));
  const data = JSON.parse(localStorage.getItem('key'));

[END SECTION 7.2]
================================================================================

SECTION 7.3: COMMON METHODS REFERENCE
-------------------------------------

JSON.PARSE()
------------
• Converts JSON string → JavaScript object
• Throws error if JSON is invalid
• Always wrap in try-catch

JSON.STRINGIFY()
----------------
• Converts JavaScript object → JSON string
• Excludes functions, undefined, Symbols
• Can format with space parameter

[END SECTION 7.3]
================================================================================

SECTION 7.4: TROUBLESHOOTING GUIDE
-----------------------------------

PROBLEM: "Unexpected token" error
SOLUTION: Check for:
  • Missing quotes around keys
  • Trailing commas
  • Single quotes instead of double quotes
  • Invalid JSON syntax

PROBLEM: "Cannot read property" error
SOLUTION: 
  • Validate data structure after parsing
  • Check if properties exist before accessing
  • Use optional chaining: data?.property

PROBLEM: Functions/undefined not in JSON
SOLUTION:
  • This is expected - JSON doesn't support these
  • Use null instead of undefined
  • Convert functions to strings if needed

PROBLEM: Dates become strings
SOLUTION:
  • Convert dates to strings before stringifying
  • Or use a custom replacer function
  • Parse dates back when reading

[END SECTION 7.4]
================================================================================

FINAL SUMMARY
=============

In this comprehensive guide, you have learned:

✓ What JSON is and why it's the standard for API data exchange
✓ How JSON represents native JavaScript objects
✓ How to parse JSON strings using JSON.parse()
✓ How to convert objects to JSON using JSON.stringify()
✓ How to work with JSON in HTTP messages
✓ Real-world examples including the ISS astronauts API
✓ Best practices and common patterns
✓ Error handling and troubleshooting

KEY TAKEAWAYS
-------------
1. JSON is the standard format for API data exchange
2. Node.js handles JSON easily with built-in methods
3. Always parse JSON strings before using the data
4. Always stringify objects before sending/storing
5. Always handle errors when parsing JSON
6. Validate data structure after parsing

Remember: JSON.parse() converts strings to objects, and JSON.stringify() 
converts objects to strings. These two methods are the foundation of working 
with JSON in Node.js and JavaScript.

================================================================================
END OF COMPREHENSIVE GUIDE
================================================================================

