================================================================================
CREATING CALLBACK FUNCTIONS IN NODE.JS
Comprehensive Study Guide - Part 1
================================================================================

WELCOME
-------
Welcome to Creating Callback Functions in Node.js. This comprehensive guide 
will teach you everything you need to know about creating callback functions 
to intercept Hypertext Transfer Protocol (HTTP) method calls, understanding 
the error-first callback pattern, and implementing nested callback functions 
in Node.js modules.

ESTIMATED TIME NEEDED
---------------------
5 minutes (for basic reading)
60-90 minutes (for comprehensive study with practice)

LEARNING OBJECTIVES
-------------------
After studying this guide, you will be able to:
• Understand what callback functions are and why they're essential in Node.js
• Create callback functions to intercept HTTP method calls
• Understand the error-first callback convention used in Node.js
• Implement error handling in callback functions
• Pass callback functions between Node.js modules and main applications
• Understand nested callback patterns (callback functions calling other callbacks)
• Create custom Node.js modules that use callback functions
• Handle HTTP requests and responses using callbacks
• Understand the asynchronous flow of callback functions

OVERVIEW
--------
As an asynchronous framework, Node.js makes extensive use of callback functions 
to return results to the calling function. Node.js modules in the Software 
Development Kit (SDK) pass an error object as the first parameter in a callback 
function. This guide will teach you how to create, use, and chain callback 
functions effectively in Node.js applications, particularly when working with 
HTTP requests and custom modules.

================================================================================
TABLE OF CONTENTS - PART 1
================================================================================

This part covers the fundamentals of callback functions:

PART 1: INTRODUCTION TO CALLBACK FUNCTIONS
  SECTION 1.1: WHAT ARE CALLBACK FUNCTIONS?
  SECTION 1.2: WHY NODE.JS USES CALLBACK FUNCTIONS
  SECTION 1.3: UNDERSTANDING ASYNCHRONOUS PROGRAMMING
  SECTION 1.4: CALLBACK FUNCTIONS VS SYNCHRONOUS FUNCTIONS

PART 2: THE ERROR-FIRST CALLBACK PATTERN
  SECTION 2.1: WHAT IS THE ERROR-FIRST CALLBACK CONVENTION?
  SECTION 2.2: WHY ERROR-FIRST CALLBACKS?
  SECTION 2.3: IMPLEMENTING ERROR-FIRST CALLBACKS
  SECTION 2.4: ERROR HANDLING IN CALLBACK FUNCTIONS

PART 3: CALLBACK FUNCTIONS WITH HTTP REQUESTS
  SECTION 3.1: HTTP REQUESTS IN NODE.JS
  SECTION 3.2: CREATING CALLBACKS FOR HTTP REQUESTS
  SECTION 3.3: HANDLING HTTP RESPONSES WITH CALLBACKS

NOTE: Part 2 of this guide covers:
  • Passing callbacks between modules and main applications
  • Nested callback patterns
  • Complete weather API example with detailed code explanations
  • Summary, key definitions, quick reference guide, and best practices

================================================================================
NAVIGATION TIP
================================================================================
Most text editors support code folding. You can:
• Fold sections by clicking the fold icon next to section headers
• Use Ctrl+Shift+[ (Windows/Linux) or Cmd+Option+[ (Mac) to fold
• Use Ctrl+Shift+] (Windows/Linux) or Cmd+Option+] (Mac) to unfold
• Fold all sections: Ctrl+K Ctrl+0 (Windows/Linux) or Cmd+K Cmd+0 (Mac)
• Unfold all: Ctrl+K Ctrl+J (Windows/Linux) or Cmd+K Cmd+J (Mac)

Search for section numbers (e.g., "SECTION 1.3:") to quickly jump to any section.

================================================================================
PART 1: INTRODUCTION TO CALLBACK FUNCTIONS
================================================================================

SECTION 1.1: WHAT ARE CALLBACK FUNCTIONS?
------------------------------------------

DEFINITION
----------
A callback function is a function that is passed as an argument to another 
function and is executed at a later time, typically after an asynchronous 
operation completes. In Node.js, callback functions are extensively used to 
return results to the calling function.

DETAILED EXPLANATION
--------------------
Think of a callback function like leaving a phone number with a restaurant. 
You place your order (call a function), and instead of waiting at the counter 
(blocking), you leave your number (pass a callback function). When your order 
is ready (the operation completes), the restaurant calls you back (executes 
the callback function) to let you know.

KEY CHARACTERISTICS OF CALLBACK FUNCTIONS:
• They are passed as arguments to other functions
• They are executed after an operation completes
• They allow code to continue running without waiting (non-blocking)
• They handle the results of asynchronous operations
• They can be named functions or anonymous functions

BASIC EXAMPLE
-------------
  // A simple callback function example
  function greet(name, callback) {
    console.log('Hello, ' + name);
    callback(); // Execute the callback function
  }

  function sayGoodbye() {
    console.log('Goodbye!');
  }

  // Pass sayGoodbye as a callback
  greet('John', sayGoodbye);

  // Output:
  // Hello, John
  // Goodbye!

LINE-BY-LINE EXPLANATION
------------------------
Line 1: function greet(name, callback) {
        • Defines a function named greet
        • Takes two parameters: name (a string) and callback (a function)
        • The callback parameter expects a function to be passed in

Line 2: console.log('Hello, ' + name);
        • Prints a greeting message
        • Uses the name parameter to personalize the greeting

Line 3: callback(); // Execute the callback function
        • Calls the callback function that was passed in
        • This executes whatever function was provided as the second argument
        • The parentheses () invoke/execute the function

Line 4: }
        • Closes the greet function

Line 6: function sayGoodbye() {
        • Defines a function named sayGoodbye
        • This will be used as a callback function

Line 7: console.log('Goodbye!');
        • Prints a goodbye message

Line 8: }
        • Closes the sayGoodbye function

Line 11: greet('John', sayGoodbye);
        • Calls the greet function
        • Passes 'John' as the name parameter
        • Passes sayGoodbye as the callback parameter (note: no parentheses)
        • When you pass a function as a callback, you don't use parentheses
        • If you wrote sayGoodbye(), it would execute immediately instead of 
          being passed as a callback

ANONYMOUS CALLBACK FUNCTIONS
----------------------------
You can also pass anonymous functions (functions without names) as callbacks:

  greet('John', function() {
    console.log('Goodbye!');
  });

Or using arrow function syntax (ES6):

  greet('John', () => {
    console.log('Goodbye!');
  });

Both examples do the same thing as passing sayGoodbye, but the function is 
defined inline without a name.

REAL-WORLD ANALOGY
------------------
Imagine you're ordering food delivery:
1. You call the restaurant (call a function)
2. You place your order (pass parameters)
3. You give them your address (pass a callback function)
4. You hang up and continue with other tasks (code continues running)
5. When food is ready, they deliver it to your address (callback executes)

This is non-blocking - you don't wait on the phone for the food to be cooked!

[END SECTION 1.1]
================================================================================

SECTION 1.2: WHY NODE.JS USES CALLBACK FUNCTIONS
-------------------------------------------------

THE NATURE OF NODE.JS
---------------------
Node.js is an asynchronous framework. This means it can handle multiple 
operations at the same time without waiting for each one to complete before 
starting the next. Callback functions are essential for this asynchronous 
behavior.

WHY ASYNCHRONOUS PROGRAMMING?
------------------------------
Traditional synchronous programming works like this:

  // Synchronous (blocking) code
  const data = readFile('file.txt');  // Waits here until file is read
  console.log(data);                   // Only runs after file is read
  doSomethingElse();                   // Only runs after console.log

If reading the file takes 5 seconds, your entire program stops for 5 seconds. 
This is inefficient, especially for web servers that need to handle many 
requests simultaneously.

Asynchronous programming with callbacks works like this:

  // Asynchronous (non-blocking) code
  readFile('file.txt', function(data) {  // Starts reading, doesn't wait
    console.log(data);                   // Runs when file is ready
  });
  doSomethingElse();                     // Runs immediately, doesn't wait!

Now doSomethingElse() runs immediately while the file is being read in the 
background. When the file is ready, the callback function executes.

BENEFITS OF CALLBACK FUNCTIONS IN NODE.JS
------------------------------------------
1. NON-BLOCKING OPERATIONS
   • Code continues executing while waiting for operations
   • Multiple operations can run simultaneously
   • Better performance and responsiveness

2. HANDLING ASYNCHRONOUS RESULTS
   • Callbacks provide a way to handle results when they're ready
   • Essential for I/O operations (file system, network, database)
   • Allows Node.js to handle many requests efficiently

3. EVENT-DRIVEN PROGRAMMING
   • Node.js is built on an event-driven architecture
   • Callbacks respond to events (file read complete, HTTP response received)
   • Natural fit for handling events

EXAMPLE: WHY CALLBACKS ARE NEEDED
----------------------------------
Imagine a web server handling multiple requests:

  // Without callbacks (synchronous - BAD for servers)
  function handleRequest(request) {
    const data = readDatabase();  // Takes 2 seconds - blocks everything!
    return processData(data);     // Takes 1 second - still blocking!
  }
  // Server can only handle one request at a time

  // With callbacks (asynchronous - GOOD for servers)
  function handleRequest(request, callback) {
    readDatabase(function(data) {  // Starts reading, doesn't block
      processData(data, callback); // Processes when data is ready
    });
  }
  // Server can handle many requests simultaneously!

[END SECTION 1.2]
================================================================================

SECTION 1.3: UNDERSTANDING ASYNCHRONOUS PROGRAMMING
----------------------------------------------------

WHAT IS ASYNCHRONOUS PROGRAMMING?
----------------------------------
Asynchronous programming allows code to start a long-running operation and 
continue with other code without waiting for that operation to complete. When 
the operation finishes, a callback function is executed with the result.

SYNCHRONOUS VS ASYNCHRONOUS
---------------------------
SYNCHRONOUS (Blocking):
  Step 1: Start operation A
  Step 2: Wait for operation A to complete
  Step 3: Start operation B
  Step 4: Wait for operation B to complete
  Total time: Time(A) + Time(B)

ASYNCHRONOUS (Non-blocking):
  Step 1: Start operation A (with callback)
  Step 2: Start operation B (with callback) - doesn't wait for A!
  Step 3: Operation A completes, callback executes
  Step 4: Operation B completes, callback executes
  Total time: Maximum(Time(A), Time(B))

VISUAL REPRESENTATION
---------------------
Synchronous Flow:
  [Start] → [Operation A - 3 seconds] → [Operation B - 2 seconds] → [End]
  Total: 5 seconds

Asynchronous Flow:
  [Start] → [Operation A - 3 seconds] ─┐
           [Operation B - 2 seconds] ──┤ → [Both complete] → [End]
  Total: 3 seconds (the longer of the two)

EXAMPLE: READING MULTIPLE FILES
--------------------------------
Synchronous approach:

  const fs = require('fs');
  
  // Read file 1 (takes 2 seconds)
  const file1 = fs.readFileSync('file1.txt');
  console.log('File 1 read');
  
  // Read file 2 (takes 2 seconds) - waits for file 1 first!
  const file2 = fs.readFileSync('file2.txt');
  console.log('File 2 read');
  
  // Total time: 4 seconds

Asynchronous approach with callbacks:

  const fs = require('fs');
  
  // Read file 1 (takes 2 seconds, but doesn't block)
  fs.readFile('file1.txt', function(err, data) {
    console.log('File 1 read');
  });
  
  // Read file 2 (starts immediately, also takes 2 seconds)
  fs.readFile('file2.txt', function(err, data) {
    console.log('File 2 read');
  });
  
  // Both files read simultaneously!
  // Total time: ~2 seconds (the time of the slower operation)

THE CALLBACK EXECUTION TIMELINE
-------------------------------
When you call an asynchronous function with a callback:

  1. Function call starts the operation
  2. Function returns immediately (doesn't wait)
  3. Your code continues executing
  4. Operation runs in the background
  5. When operation completes, callback executes
  6. Callback receives the result

EXAMPLE TIMELINE:
-----------------
  console.log('1. Start');
  
  setTimeout(function() {
    console.log('3. Callback executed');
  }, 1000);
  
  console.log('2. Continue');
  
  // Output:
  // 1. Start
  // 2. Continue
  // (1 second passes)
  // 3. Callback executed

Notice that "2. Continue" prints before "3. Callback executed" even though 
the callback code appears first in the file. This is because the callback 
executes later, after the timeout completes.

[END SECTION 1.3]
================================================================================

SECTION 1.4: CALLBACK FUNCTIONS VS SYNCHRONOUS FUNCTIONS
----------------------------------------------------------

SYNCHRONOUS FUNCTIONS
---------------------
Synchronous functions execute immediately and return a value directly:

  function add(a, b) {
    return a + b;  // Returns immediately
  }
  
  const result = add(2, 3);  // result = 5 immediately
  console.log(result);       // Prints: 5

CHARACTERISTICS:
• Execute immediately
• Block execution until complete
• Return values directly
• Simple to understand (linear flow)
• Not suitable for I/O operations (file, network, database)

ASYNCHRONOUS FUNCTIONS WITH CALLBACKS
-------------------------------------
Asynchronous functions start an operation and use a callback to return results:

  function addAsync(a, b, callback) {
    // Simulate async operation (like reading a file)
    setTimeout(function() {
      const result = a + b;
      callback(result);  // Return result via callback
    }, 1000);
  }
  
  addAsync(2, 3, function(result) {
    console.log(result);  // Prints: 5 (after 1 second)
  });
  
  console.log('This runs immediately!');  // Prints first

CHARACTERISTICS:
• Start operation and return immediately
• Don't block execution
• Return results via callback function
• More complex flow (callback executes later)
• Essential for I/O operations

COMPARISON EXAMPLE
------------------
Reading a file synchronously:

  const fs = require('fs');
  
  // Synchronous - blocks until file is read
  const data = fs.readFileSync('file.txt', 'utf8');
  console.log(data);           // Prints file contents
  console.log('Done reading'); // Runs after file is read

Reading a file asynchronously with callback:

  const fs = require('fs');
  
  // Asynchronous - doesn't block
  fs.readFile('file.txt', 'utf8', function(err, data) {
    console.log(data);           // Prints file contents when ready
  });
  console.log('Done reading');   // Runs immediately (before file is read!)

WHEN TO USE EACH
----------------
Use Synchronous Functions:
• Simple calculations
• Operations that complete instantly
• Scripts that don't need to handle multiple things
• When blocking is acceptable

Use Asynchronous Functions with Callbacks:
• File I/O operations
• Network requests (HTTP)
• Database queries
• Any operation that takes time
• Web servers and applications
• When you need non-blocking behavior

[END SECTION 1.4]
[END PART 1]
================================================================================

PART 2: THE ERROR-FIRST CALLBACK PATTERN
================================================================================

SECTION 2.1: WHAT IS THE ERROR-FIRST CALLBACK CONVENTION?
----------------------------------------------------------

DEFINITION
----------
The error-first callback convention is a standard pattern in Node.js where 
callback functions receive an error object as the first parameter. If the 
operation succeeds, the first parameter is null or undefined. If the operation 
fails, the first parameter contains an error object with information about 
what went wrong.

DETAILED EXPLANATION
--------------------
Node.js modules in the Software Development Kit (SDK) pass an error object as 
the first parameter in a callback function. This convention ensures consistent 
error handling across all Node.js modules and makes it easy to check for errors.

THE PATTERN
-----------
Every error-first callback follows this pattern:

  function callback(error, result) {
    // error is the first parameter
    // result is the second parameter (or more)
  }

RULES OF ERROR-FIRST CALLBACKS:
1. First parameter is always the error (or null/undefined if no error)
2. Subsequent parameters contain the result data
3. If error exists, result parameters may be undefined
4. If no error, error parameter is null or undefined

REAL-WORLD ANALOGY
------------------
Think of error-first callbacks like a restaurant order:
• If there's a problem (error): They call and say "Sorry, we have a problem" 
  (error object), and you don't get your food (no result)
• If everything is fine (no error): They call and say "Everything is fine" 
  (null), and deliver your food (result)

BASIC EXAMPLE
-------------
  function divide(a, b, callback) {
    if (b === 0) {
      // Error case: pass error as first parameter
      callback(new Error('Cannot divide by zero'), null);
    } else {
      // Success case: pass null as first parameter, result as second
      callback(null, a / b);
    }
  }
  
  // Using the function
  divide(10, 2, function(error, result) {
    if (error) {
      console.log('Error:', error.message);
    } else {
      console.log('Result:', result);
    }
  });

LINE-BY-LINE EXPLANATION
------------------------
Line 1: function divide(a, b, callback) {
        • Defines a function that divides two numbers
        • Takes three parameters: a (dividend), b (divisor), callback (function)
        • The callback will follow the error-first pattern

Line 2: if (b === 0) {
        • Checks if divisor is zero (division by zero is not allowed)
        • This is an error condition

Line 3: callback(new Error('Cannot divide by zero'), null);
        • Calls the callback with an error
        • new Error('...') creates an Error object with a message
        • Error object is passed as the first parameter
        • null is passed as the second parameter (no result when there's an error)
        • This follows the error-first callback convention

Line 4: } else {
        • If no error (divisor is not zero)

Line 5: callback(null, a / b);
        • Calls the callback with no error
        • null is passed as the first parameter (no error)
        • a / b is the result, passed as the second parameter
        • This follows the error-first callback convention

Line 6: }
        • Closes the else block

Line 7: }
        • Closes the divide function

Line 10: divide(10, 2, function(error, result) {
        • Calls divide function with 10 and 2
        • Passes an anonymous callback function
        • Callback receives error as first parameter, result as second
        • This is the standard error-first callback pattern

Line 11: if (error) {
        • Checks if error parameter has a value
        • If error is not null/undefined, an error occurred

Line 12: console.log('Error:', error.message);
        • Prints the error message
        • error.message contains the error description

Line 13: } else {
        • If no error (error is null/undefined)

Line 14: console.log('Result:', result);
        • Prints the result of the division

Line 15: }
        • Closes the else block

Line 16: });
        • Closes the callback function

[END SECTION 2.1]
================================================================================

SECTION 2.2: WHY ERROR-FIRST CALLBACKS?
---------------------------------------

CONSISTENCY ACROSS NODE.JS
--------------------------
The error-first pattern is used by all Node.js SDK modules. This means:
• Every callback you write follows the same pattern
• You always know where to look for errors (first parameter)
• Code is predictable and easier to understand
• No need to remember different error handling patterns

EASY ERROR CHECKING
-------------------
With error-first callbacks, checking for errors is always the same:

  function callback(error, result) {
    if (error) {
      // Handle error - same pattern everywhere!
      return;
    }
    // Use result - we know there's no error
  }

You don't need to check multiple places or remember different patterns.

PREVENTS MISSED ERRORS
----------------------
If errors were passed in different positions, you might forget to check them. 
With error-first callbacks, the error is always the first thing you see:

  // Error-first pattern - error is obvious
  callback(error, result);
  if (error) { /* handle */ }  // Can't miss it!

STANDARDIZED ERROR HANDLING
---------------------------
All Node.js modules use this pattern, so you can handle errors the same way 
everywhere:

  // File system
  fs.readFile('file.txt', function(error, data) {
    if (error) { /* handle */ }
  });
  
  // HTTP requests
  http.get('url', function(error, response) {
    if (error) { /* handle */ }
  });
  
  // Database queries
  db.query('SELECT *', function(error, results) {
    if (error) { /* handle */ }
  });

Same pattern everywhere makes code easier to write and maintain!

[END SECTION 2.2]
================================================================================

SECTION 2.3: IMPLEMENTING ERROR-FIRST CALLBACKS
------------------------------------------------

CREATING FUNCTIONS THAT USE ERROR-FIRST CALLBACKS
-------------------------------------------------
When you create a function that performs an asynchronous operation, you should 
follow the error-first callback pattern:

  function readUserData(userId, callback) {
    // Simulate async operation (like reading from database)
    setTimeout(function() {
      if (userId < 0) {
        // Error case: pass error as first parameter
        callback(new Error('Invalid user ID'), null);
      } else {
        // Success case: pass null, then result
        callback(null, { id: userId, name: 'John Doe' });
      }
    }, 1000);
  }

LINE-BY-LINE EXPLANATION
------------------------
Line 1: function readUserData(userId, callback) {
        • Defines function that reads user data
        • Takes userId (number) and callback (function) as parameters

Line 2: setTimeout(function() {
        • Simulates an asynchronous operation
        • In real code, this might be a database query or file read
        • setTimeout delays execution by 1000ms (1 second)

Line 3: if (userId < 0) {
        • Checks for invalid input (error condition)
        • Negative user IDs are not valid

Line 4: callback(new Error('Invalid user ID'), null);
        • Calls callback with error
        • new Error('...') creates Error object with message
        • Error is first parameter (error-first pattern)
        • null is second parameter (no data when error occurs)

Line 5: } else {
        • If userId is valid (no error condition)

Line 6: callback(null, { id: userId, name: 'John Doe' });
        • Calls callback with success
        • null is first parameter (no error)
        • Object with user data is second parameter (the result)
        • This is the data the caller requested

Line 7: }
        • Closes else block

Line 8: }, 1000);
        • Closes setTimeout function, sets delay to 1000ms

Line 9: }
        • Closes readUserData function

USING ERROR-FIRST CALLBACKS
---------------------------
When calling functions that use error-first callbacks, always check the error 
first:

  readUserData(123, function(error, userData) {
    // Always check error first!
    if (error) {
      console.error('Error:', error.message);
      return; // Stop execution if there's an error
    }
    
    // If we get here, there's no error, so we can use userData
    console.log('User:', userData.name);
  });

LINE-BY-LINE EXPLANATION
------------------------
Line 1: readUserData(123, function(error, userData) {
        • Calls readUserData with userId 123
        • Passes callback function with error-first pattern
        • error is first parameter (will be Error object or null)
        • userData is second parameter (will be user object or undefined)

Line 2: if (error) {
        • Checks if error parameter has a value
        • This is the standard error check pattern
        • Should always be done first

Line 3: console.error('Error:', error.message);
        • Prints error message if error occurred
        • console.error is for error messages (different from console.log)
        • error.message contains the error description

Line 4: return; // Stop execution if there's an error
        • Exits the callback function early
        • Prevents code below from running when there's an error
        • Important: don't try to use userData if there's an error!

Line 6: // If we get here, there's no error, so we can use userData
        • Comment explaining that code below only runs if no error
        • This is safe because we returned early if there was an error

Line 7: console.log('User:', userData.name);
        • Uses the userData (safe because we know there's no error)
        • Accesses the name property of the user object

Line 8: });
        • Closes the callback function

COMMON PATTERNS
---------------
Pattern 1: Early return on error

  function callback(error, result) {
    if (error) {
      // Handle error and exit
      return;
    }
    // Continue with success case
  }

Pattern 2: Error handling with cleanup

  function callback(error, result) {
    if (error) {
      // Handle error
      // Clean up any open connections
      cleanup();
      return;
    }
    // Use result
  }

Pattern 3: Logging errors

  function callback(error, result) {
    if (error) {
      console.error('Operation failed:', error.message);
      return;
    }
    console.log('Operation succeeded:', result);
  }

[END SECTION 2.3]
================================================================================

SECTION 2.4: ERROR HANDLING IN CALLBACK FUNCTIONS
----------------------------------------------------

THE STANDARD ERROR HANDLING PATTERN
-----------------------------------
With this convention, the callback function checks if the first parameter 
holds an error object. If error is defined, the callback function handles the 
error and cleans up any open network or database connections. If the error is 
not defined, then the callback function examines the result from the call.

STEP-BY-STEP ERROR HANDLING
---------------------------
1. Check if error parameter exists
2. If error exists:
   a. Handle the error (log it, notify user, etc.)
   b. Clean up resources (close connections, free memory)
   c. Return early (don't continue with success code)
3. If no error:
   a. Process the result
   b. Continue with normal operation

COMPLETE EXAMPLE
----------------
  const fs = require('fs');
  
  fs.readFile('data.txt', 'utf8', function(error, data) {
    // Step 1: Check for error
    if (error) {
      // Step 2a: Handle the error
      console.error('Error reading file:', error.message);
      
      // Step 2b: Clean up (in this case, no cleanup needed for file read)
      // But in other cases, you might close database connections, etc.
      
      // Step 2c: Return early
      return;
    }
    
    // Step 3: Process the result (only runs if no error)
    console.log('File contents:', data);
    processData(data);
  });

LINE-BY-LINE EXPLANATION
------------------------
Line 1: const fs = require('fs');
        • Imports the Node.js file system module
        • fs provides functions for reading/writing files

Line 3: fs.readFile('data.txt', 'utf8', function(error, data) {
        • Calls readFile to read 'data.txt' asynchronously
        • 'utf8' specifies the file encoding (text format)
        • Passes callback function following error-first pattern
        • error will be Error object if read fails, null if succeeds
        • data will be file contents if read succeeds, undefined if fails

Line 4: if (error) {
        • Checks if error parameter has a value
        • This is the standard error check (always do this first!)

Line 5: console.error('Error reading file:', error.message);
        • Prints error message using console.error (for errors)
        • error.message contains the error description
        • This is step 2a: Handle the error

Line 6: (empty line for readability)

Line 7: // Step 2b: Clean up (in this case, no cleanup needed for file read)
        • Comment explaining cleanup step
        • For file reads, no cleanup is needed
        • For database connections or network requests, you'd close them here

Line 8: (empty line)

Line 9: return;
        • Exits the callback function early
        • Prevents code below from executing when there's an error
        • This is step 2c: Return early

Line 10: }
        • Closes the if (error) block

Line 12: // Step 3: Process the result (only runs if no error)
        • Comment explaining that code below only runs if no error
        • This is safe because we returned early if there was an error

Line 13: console.log('File contents:', data);
        • Prints the file contents
        • data contains the file contents (only available if no error)

Line 14: processData(data);
        • Calls a function to process the data
        • Assumes processData is defined elsewhere
        • This only runs if file was read successfully

Line 15: });
        • Closes the callback function

ERROR HANDLING WITH RESOURCE CLEANUP
------------------------------------
When working with resources that need cleanup (like database connections):

  function queryDatabase(query, callback) {
    const connection = openDatabaseConnection();
    
    connection.query(query, function(error, results) {
      if (error) {
        // Handle error
        console.error('Query failed:', error.message);
        
        // Clean up: close the database connection
        connection.close();
        
        // Return error to caller
        callback(error, null);
        return;
      }
      
      // Success: close connection and return results
      connection.close();
      callback(null, results);
    });
  }

In this example:
• If error occurs: log it, close connection, pass error to callback
• If success: close connection, pass results to callback
• Connection is always closed (cleanup happens in both cases)

[END SECTION 2.4]
[END PART 2]
================================================================================

PART 3: CALLBACK FUNCTIONS WITH HTTP REQUESTS
================================================================================

SECTION 3.1: HTTP REQUESTS IN NODE.JS
--------------------------------------

WHAT IS HTTP?
-------------
HTTP (Hypertext Transfer Protocol) is the protocol used for communication 
between web browsers and servers. When you create a callback function to 
intercept HTTP method calls, you're setting up functions that handle HTTP 
requests and responses.

HTTP REQUEST FLOW
-----------------
1. Client (browser, app) sends HTTP request to server
2. Server receives request and processes it
3. Server sends HTTP response back to client
4. Client receives response and processes it

In Node.js, this flow is asynchronous - you don't wait for the response, you 
provide a callback function to handle it when it arrives.

THE HTTP MODULE
---------------
Node.js provides an http module for making HTTP requests:

  const http = require('http');

This module contains functions for:
• Creating HTTP servers
• Making HTTP requests (client side)
• Handling HTTP responses

BASIC HTTP REQUEST
------------------
  const http = require('http');
  
  http.get('http://example.com', function(response) {
    // Handle response here
  });

This makes a GET request to 'http://example.com'. When the response arrives, 
the callback function is executed with the response object.

ASYNCHRONOUS NATURE
-------------------
HTTP requests are asynchronous operations:
• The request is sent immediately
• Your code continues running (doesn't wait)
• When response arrives, callback executes
• This is non-blocking - other code can run while waiting

EXAMPLE TIMELINE
----------------
  console.log('1. Starting request');
  
  http.get('http://example.com', function(response) {
    console.log('3. Response received');
  });
  
  console.log('2. Request sent, continuing...');
  
  // Output:
  // 1. Starting request
  // 2. Request sent, continuing...
  // (network delay...)
  // 3. Response received

Notice that "2. Request sent, continuing..." prints before "3. Response 
received" because the HTTP request is asynchronous.

[END SECTION 3.1]
================================================================================

SECTION 3.2: CREATING CALLBACKS FOR HTTP REQUESTS
---------------------------------------------------

THE HTTP.REQUEST FUNCTION
--------------------------
The http.request() function (or http.get() for GET requests) is used to make 
HTTP requests. It takes a URL and a callback function that handles the response.

BASIC PATTERN
-------------
  const http = require('http');
  
  http.get(url, function(response) {
    // Handle the HTTP response
  });

The callback function receives a response object when the HTTP response message 
arrives from the remote server.

COMPLETE EXAMPLE
----------------
  const http = require('http');
  
  http.get('http://api.example.com/data', function(response) {
    let data = '';
    
    // Collect response data
    response.on('data', function(chunk) {
      data += chunk;
    });
    
    // When response is complete
    response.on('end', function() {
      console.log('Response:', data);
    });
  });
  
  console.log('Request sent!');

LINE-BY-LINE EXPLANATION
------------------------
Line 1: const http = require('http');
        • Imports Node.js HTTP module
        • Provides functions for making HTTP requests

Line 3: http.get('http://api.example.com/data', function(response) {
        • Makes a GET HTTP request to the specified URL
        • http.get() is a convenience method for GET requests
        • Passes a callback function that receives the response
        • response is an object representing the HTTP response
        • This is asynchronous - doesn't block execution

Line 4: let data = '';
        • Creates a variable to accumulate response data
        • Starts as empty string
        • Will collect all chunks of data as they arrive

Line 6: response.on('data', function(chunk) {
        • Sets up event listener for 'data' events
        • HTTP responses arrive in chunks (pieces)
        • Each chunk triggers a 'data' event
        • chunk parameter contains a piece of the response data

Line 7: data += chunk;
        • Appends each chunk to the data variable
        • Accumulates all chunks into complete response
        • += operator adds chunk to existing data string

Line 8: });
        • Closes the 'data' event handler

Line 10: response.on('end', function() {
        • Sets up event listener for 'end' event
        • 'end' event fires when all data has been received
        • This is when the response is complete

Line 11: console.log('Response:', data);
        • Prints the complete response data
        • data now contains the full response (all chunks combined)
        • This only runs after all data is received

Line 12: });
        • Closes the 'end' event handler

Line 13: });
        • Closes the http.get callback function

Line 15: console.log('Request sent!');
        • Prints immediately after request is sent
        • Doesn't wait for response (asynchronous!)
        • This will print before the response is received

WHY CHUNKS?
-----------
HTTP responses can be large. Instead of waiting for the entire response, 
Node.js receives it in chunks (small pieces). This allows:
• Processing data as it arrives
• Handling large responses efficiently
• Not blocking while waiting for complete response

The 'data' event fires for each chunk, and 'end' event fires when all chunks 
are received.

[END SECTION 3.2]
================================================================================

SECTION 3.3: HANDLING HTTP RESPONSES WITH CALLBACKS
-----------------------------------------------------

THE RESPONSE OBJECT
-------------------
When an HTTP request completes, the callback function receives a response 
object. This object is a stream that emits events as data arrives.

RESPONSE EVENTS
---------------
The response object emits several events:
• 'data' - Fired when a chunk of data arrives
• 'end' - Fired when all data has been received
• 'error' - Fired if an error occurs

HANDLING THE COMPLETE RESPONSE
------------------------------
To get the complete response, you need to:
1. Listen for 'data' events to collect chunks
2. Accumulate all chunks into a complete response
3. Listen for 'end' event to know when complete
4. Process the complete response in the 'end' handler

COMPLETE EXAMPLE WITH ERROR HANDLING
------------------------------------
  const http = require('http');
  
  http.get('http://api.example.com/weather', function(response) {
    let responseData = '';
    
    // Handle incoming data chunks
    response.on('data', function(chunk) {
      responseData += chunk;
    });
    
    // Handle response completion
    response.on('end', function() {
      console.log('Complete response:', responseData);
      // Process the response data here
    });
    
    // Handle errors
    response.on('error', function(error) {
      console.error('Response error:', error.message);
    });
  }).on('error', function(error) {
    console.error('Request error:', error.message);
  });

LINE-BY-LINE EXPLANATION
------------------------
Line 1: const http = require('http');
        • Imports HTTP module for making requests

Line 3: http.get('http://api.example.com/weather', function(response) {
        • Makes GET request to weather API
        • Callback receives response object when request is sent
        • Note: response arrives asynchronously

Line 4: let responseData = '';
        • Variable to accumulate response data
        • Will hold complete response when all chunks arrive

Line 6: response.on('data', function(chunk) {
        • Listens for 'data' events
        • Each chunk of response data triggers this
        • chunk contains a piece of the response

Line 7: responseData += chunk;
        • Adds each chunk to responseData
        • Builds complete response from pieces
        • += concatenates strings

Line 8: });
        • Closes 'data' event handler

Line 10: response.on('end', function() {
        • Listens for 'end' event
        • Fires when all data chunks have been received
        • This is when response is complete

Line 11: console.log('Complete response:', responseData);
        • Prints the complete response
        • responseData now contains full response (all chunks)
        • This is safe to process now

Line 12: // Process the response data here
        • Comment indicating where to add processing logic
        • Could parse JSON, extract data, etc.

Line 13: });
        • Closes 'end' event handler

Line 15: response.on('error', function(error) {
        • Listens for errors in the response stream
        • Handles errors that occur while receiving response
        • error parameter contains error information

Line 16: console.error('Response error:', error.message);
        • Prints error message if response has error
        • console.error is for error messages

Line 17: });
        • Closes response 'error' event handler

Line 18: }).on('error', function(error) {
        • Chains .on('error') to http.get() call
        • Handles errors in making the request itself
        • Different from response errors (network issues, invalid URL, etc.)

Line 19: console.error('Request error:', error.message);
        • Prints error if request fails to send
        • Could be network error, DNS error, etc.

Line 20: });
        • Closes request 'error' event handler

TWO TYPES OF ERRORS
-------------------
1. REQUEST ERRORS (line 18-20):
   • Errors in sending the request
   • Network failures, invalid URLs, connection refused
   • Handled with .on('error') on http.get()

2. RESPONSE ERRORS (line 15-17):
   • Errors while receiving the response
   • Problems with the response stream
   • Handled with response.on('error')

Both should be handled for robust error handling!

[END SECTION 3.3]
[END PART 3]
================================================================================

This is Part 1 of the comprehensive guide. Part 2 will cover passing 
callbacks between modules and main applications, nested callback patterns, 
and a complete weather API example with detailed code explanations.

================================================================================
END OF PART 1
================================================================================

